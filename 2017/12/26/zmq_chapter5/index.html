<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="zmq,网络编程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="第五章 高级发布-订阅模式第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。 本章涉及的内容有：  处理慢订阅者（自杀的蜗牛模式） 高速订阅者（黑箱模式） 构建一个共享键值缓存（克隆模式）">
<meta name="keywords" content="zmq,网络编程">
<meta property="og:type" content="article">
<meta property="og:title" content="zmq学习第五章">
<meta property="og:url" content="https://dearamaze.com/2017/12/26/zmq_chapter5/index.html">
<meta property="og:site_name" content="DearAmaze-桀骜良">
<meta property="og:description" content="第五章 高级发布-订阅模式第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。 本章涉及的内容有：  处理慢订阅者（自杀的蜗牛模式） 高速订阅者（黑箱模式） 构建一个共享键值缓存（克隆模式）">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_1.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_2.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_3.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_4.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_5.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_6.png">
<meta property="og:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_7.png">
<meta property="og:updated_time" content="2017-12-31T14:36:36.799Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zmq学习第五章">
<meta name="twitter:description" content="第五章 高级发布-订阅模式第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。 本章涉及的内容有：  处理慢订阅者（自杀的蜗牛模式） 高速订阅者（黑箱模式） 构建一个共享键值缓存（克隆模式）">
<meta name="twitter:image" content="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dearamaze.com/2017/12/26/zmq_chapter5/"/>





  <title> zmq学习第五章 | DearAmaze-桀骜良 </title>
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?05e47eef3e87bfa03fe6dfcdad14b688";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  
  <!--<script type="text/javascript" color="0,191,255" opacity="0.7" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>-->
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DearAmaze-桀骜良</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">test_subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/12/26/zmq_chapter5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                zmq学习第五章
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-26T00:00:00+08:00">
                2017-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/26/zmq_chapter5/" class="leancloud_visitors" data-flag-title="zmq学习第五章">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第五章-高级发布-订阅模式"><a href="#第五章-高级发布-订阅模式" class="headerlink" title="第五章 高级发布-订阅模式"></a>第五章 高级发布-订阅模式</h2><p>第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。</p>
<p>本章涉及的内容有：</p>
<ul>
<li>处理慢订阅者（自杀的蜗牛模式）</li>
<li>高速订阅者（黑箱模式）</li>
<li>构建一个共享键值缓存（克隆模式）</li>
</ul>
<a id="more"></a>
<h3 id="检测慢订阅者（自杀的蜗牛模式）"><a href="#检测慢订阅者（自杀的蜗牛模式）" class="headerlink" title="检测慢订阅者（自杀的蜗牛模式）"></a>检测慢订阅者（自杀的蜗牛模式）</h3><p>在使用发布-订阅模式的时候，最常见的问题之一是如何处理响应较慢的订阅者。理想状况下，发布者能以全速发送消息给订阅者，但现实中，订阅者会需要对消息做较长时间的处理，或者写得不够好，无法跟上发布者的脚步。</p>
<p>如何处理慢订阅者？最好的方法当然是让订阅者高效起来，不过这需要额外的工作。以下是一些处理慢订阅者的方法：</p>
<ul>
<li><p><strong>在发布者中贮存消息</strong>。这是Gmail的做法，如果过去的几小时里没有阅读邮件的话，它会把邮件保存起来。但在高吞吐量的应用中，发布者堆积消息往往会导致内存溢出，最终崩溃。特别是当同是有多个订阅者时，或者无法用磁盘来做一个缓冲，情况就会变得更为复杂。</p>
</li>
<li><p><strong>在订阅者中贮存消息</strong>。这种做法要好的多，其实ZMQ默认的行为就是这样的。如果非得有一个人会因为内存溢出而崩溃，那也只会是订阅者，而非发布者，这挺公平的。然而，这种做法只对瞬间消息量很大的应用才合理，订阅者只是一时处理不过来，但最终会赶上进度。但是，这还是没有解决订阅者速度过慢的问题。</p>
</li>
<li><p><strong>暂停发送消息</strong>。这也是Gmail的做法，当我的邮箱容量超过7.554GB时，新的邮件就会被Gmail拒收或丢弃。这种做法对发布者来说很有益，ZMQ中若设置了阈值（HWM），其默认行为也就是这样的。但是，我们仍不能解决慢订阅者的问题，我们只是让消息变得断断续续而已。</p>
</li>
<li><p><strong>断开与满订阅者的连接</strong>。这是hotmail的做法，如果连续两周没有登录，它就会断开，这也是为什么我正在使用第十五个hotmail邮箱。不过这种方案在ZMQ里是行不通的，因为对于发布者而言，订阅者是不可见的，无法做相应处理。</p>
</li>
</ul>
<p>看来没有一种经典的方式可以满足我们的需求，所以我们就要进行创新了。我们可以让订阅者自杀，而不仅仅是断开连接。这就是“自杀的蜗牛”模式。当订阅者发现自身运行得过慢时（对于慢速的定义应该是一个配置项，当达到这个标准时就大声地喊出来吧，让程序员知道），它会哀嚎一声，然后自杀。</p>
<p>订阅者如何检测自身速度过慢呢？一种方式是为消息进行编号，并在发布者端设置阈值。当订阅者发现消息编号不连续时，它就知道事情不对劲了。这里的阈值就是订阅者自杀的值。</p>
<p>这种方案有两个问题：一、如果我们连接的多个发布者，我们要如何为消息进行编号呢？解决方法是为每一个发布者设定一个唯一的编号，作为消息编号的一部分。二、如果订阅者使用ZMQ_SUBSRIBE选项对消息进行了过滤，那么我们精心设计的消息编号机制就毫无用处了。</p>
<p>有些情形不会进行消息的过滤，所以消息编号还是行得通的。不过更为普遍的解决方案是，发布者为消息标注时间戳，当订阅者收到消息时会检测这个时间戳，如果其差别达到某一个值，就发出警报并自杀。</p>
<p>当订阅者有自身的客户端或服务协议，需要保证最大延迟时间时，自杀的蜗牛模式会很合适。撤销一个订阅者也许并不是最周全的方案，但至少不会引发后续的问题。如果订阅者收到了过时的消息，那可能会对数据造成进一步的破坏，而且很难被发现。</p>
<p>以下是自杀的蜗牛模式的最简实现：</p>
<p><strong>suisnail: Suicidal Snail in C</strong></p>
<pre><code class="c">//
//  自杀的蜗牛模式
//
#include &quot;czmq.h&quot;

//  ---------------------------------------------------------------------
//  该订阅者会连接至发布者，接收所有的消息，
//  运行过程中它会暂停一会儿，模拟复杂的运算过程，
//  当发现收到的消息超过1秒的延迟时，就自杀。

#define MAX_ALLOWED_DELAY   1000    //  毫秒

static void
subscriber (void *args, zctx_t *ctx, void *pipe)
{
    //  订阅所有消息
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5556&quot;);

    //  获取并处理消息
    while (1) {
        char *string = zstr_recv (subscriber);
        int64_t clock;
        int terms = sscanf (string, &quot;%&quot; PRId64, &amp;clock);
        assert (terms == 1);
        free (string);

        //  自杀逻辑
        if (zclock_time () - clock &gt; MAX_ALLOWED_DELAY) {
            fprintf (stderr, &quot;E: 订阅者无法跟进, 取消中\n&quot;);
            break;
        }
        //  工作一定时间
        zclock_sleep (1 + randof (2));
    }
    zstr_send (pipe, &quot;订阅者中止&quot;);
}


//  ---------------------------------------------------------------------
//  发布者每毫秒发送一条用时间戳标记的消息

static void
publisher (void *args, zctx_t *ctx, void *pipe)
{
    //  准备发布者
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5556&quot;);

    while (1) {
        //  发送当前时间（毫秒）给订阅者
        char string [20];
        sprintf (string, &quot;%&quot; PRId64, zclock_time ());
        zstr_send (publisher, string);
        char *signal = zstr_recv_nowait (pipe);
        if (signal) {
            free (signal);
            break;
        }
        zclock_sleep (1);            //  等待1毫秒
    }
}


//  下面的代码会启动一个订阅者和一个发布者，当订阅者死亡时停止运行
//
int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *pubpipe = zthread_fork (ctx, publisher, NULL);
    void *subpipe = zthread_fork (ctx, subscriber, NULL);
    free (zstr_recv (subpipe));
    zstr_send (pubpipe, &quot;break&quot;);
    zclock_sleep (100);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>示例程序中的消息包含了系统当前的时间戳（毫秒）。在现实应用中，你应该使用时间戳作为消息头，并提供消息内容。</li>
<li>示例程序中的发布者和订阅者是同一个进程的两个线程。在现实应用中，他们应该是两个不同的进程。示例中这么做只是为了演示的方便</li>
</ul>
<h3 id="高速订阅者（黑箱模式）"><a href="#高速订阅者（黑箱模式）" class="headerlink" title="高速订阅者（黑箱模式）"></a>高速订阅者（黑箱模式）</h3><p>发布-订阅模式的一个典型应用场景是大规模分布式数据处理。如要处理从证券市场上收集到的数据，可以在证券交易系统上设置一个发布者，获取价格信息，并发送给一组订阅者。如果我们有很多订阅者，我们可以使用TCP。如果订阅者到达一定的量，那我们就应该使用可靠的广播协议，如pgm。</p>
<p>假设我们的发布者每秒产生10万条100个字节的消息。在剔除了不需要的市场信息后，这个比率还是比较合理的。现在我们需要记录一天的数据（8小时约有250GB），再将其传入一个模拟网络，即一组订阅者。虽然10万条数据对ZMQ来说很容易处理，但我们需要更高的速度。</p>
<p>假设我们有多台机器，一台做发布者，其他的做订阅者。这些机器都是8核的，发布者那台有12核。</p>
<p>在我们开始发布消息时，有两点需要注意：</p>
<ol>
<li>即便只是处理很少的数据，订阅者仍有可能跟不上发布者的速度；</li>
<li>当处理到6M/s的数据量时，发布者和订阅者都有可能达到极限。</li>
</ol>
<p>首先，我们需要将订阅者设计为一种多线程的处理程序，这样我们就能在一个线程中读取消息，使用其他线程来处理消息。一般来说，我们对每种消息的处理方式都是不同的。这样一来，订阅者可以对收到的消息进行一次过滤，如根据头信息来判别。当消息满足某些条件，订阅者会将消息交给worker处理。用ZMQ的语言来说，订阅者会将消息转发给worker来处理。</p>
<p>这样一来，订阅者看上去就像是一个队列装置，我们可以用各种方式去连接队列装置和worker。如我们建立单向的通信，每个worker都是相同的，可以使用PUSH和PULL套接字，分发的工作就交给ZMQ吧。这是最简单也是最快速的方式：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_1.png" alt="1"></p>
<p>订阅者和发布者之间的通信使用TCP或PGM协议，订阅者和worker的通信由于是在同一个进程中完成的，所以使用inproc协议。</p>
<p>下面我们看看如何突破瓶颈。由于订阅者是单线程的，当它的CPU占用率达到100%时，它无法使用其他的核心。单线程程序总是会遇到瓶颈的，不管是2M、6M还是更多。我们需要将工作量分配到不同的线程中去，并发地执行。</p>
<p>很多高性能产品使用的方案是分片，就是将工作量拆分成独立并行的流。如，一半的专题数据由一个流媒体传输，另一半由另一个流媒体传输。我们可以建立更多的流媒体，但如果CPU核心数不变，那就没有必要了。<br>让我们看看如何将工作量分片为两个流：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_2.png" alt="2"></p>
<p>要让两个流全速工作，需要这样配置ZMQ：</p>
<ul>
<li>使用两个I/O线程，而不是一个；</li>
<li>使用两个独立的网络接口；</li>
<li>每个I/O线程绑定至一个网络接口；</li>
<li>两个订阅者线程，分别绑定至一个核心；</li>
<li>使用两个SUB套接字；</li>
<li>剩余的核心供worker使用；</li>
<li>worker线程同时绑定至两个订阅者线程的PUSH套接字。</li>
</ul>
<p>创建的线程数量应和CPU核心数一致，如果我们建立的线程数量超过核心数，那其处理速度只会减少。另外，开放多个I/O线程也是没有必要的。</p>
<h3 id="共享键值缓存（克隆模式）"><a href="#共享键值缓存（克隆模式）" class="headerlink" title="共享键值缓存（克隆模式）"></a>共享键值缓存（克隆模式）</h3><p>发布-订阅模式和无线电广播有些类似，在你收听之前发送的消息你将无从得知，收到消息的多少又会取决于你的接收能力。让人吃惊的是，对于那些追求完美的工程师来说，这种机器恰恰符合他们的需求，且广为传播，成为现实生活中分发消息的最佳机制。想想非死不可、推特、BBS新闻、体育新闻等应用就知道了。</p>
<p>但是，在很多情形下，可靠的发布-订阅模式同样是有价值的。正如我们讨论请求-应答模式一样，我们会根据“故障”来定义“可靠性”，下面几项便是发布-订阅模式中可能发生的故障：</p>
<ul>
<li>订阅者连接太慢，因此没有收到发布者最初发送的消息；</li>
<li>订阅者速度太慢，同样会丢失消息；</li>
<li>订阅者可能会断开，其间的消息也会丢失。</li>
</ul>
<p>还有一些情况我们碰到的比较少，但不是没有：</p>
<ul>
<li>订阅者崩溃、重启，从而丢失了所有已收到的消息；</li>
<li>订阅者处理消息的速度过慢，导致消息在队列中堆砌并溢出；</li>
<li>因网络过载而丢失消息（特别是PGM协议下的连接）；</li>
<li>网速过慢，消息在发布者处溢出，从而崩溃。</li>
</ul>
<p>其实还会有其他出错的情况，只是以上这些在现实应用中是比较典型的。</p>
<p>我们已经有方法解决上面的某些问题了，比如对于慢速订阅者可以使用自杀的蜗牛模式。但是，对于其他的问题，我们最后能有一个可复用的框架来编写可靠的发布-订阅模式。</p>
<p>难点在于，我们并不知道目标应用程序会怎样处理这些数据。它们会进行过滤、只处理一部分消息吗？它们是否会将消息记录起来供日后使用？它们是否会将消息转发给其下的worker进行处理？需要考虑的情况实在太多了，每种情况都有其所谓的可靠性。</p>
<p>所以，我们将问题抽象出来，供多种应用程序使用。这种抽象应用我们称之为共享的键值缓存，它的功能是通过唯一的键名存储二进制数据块。</p>
<p>不要将这个抽象应用和分布式哈希表混淆起来，它是用来解决节点在分布式网络中相连接的问题的；也不要和分布式键值表混淆，它更像是一个NoSQL数据库。我们要建立的应用是将内存中的状态可靠地传递给一组客户端，它要做到的是：</p>
<ul>
<li>客户端可以随时加入网络，并获得服务端当前的状态；</li>
<li>任何客户端都可以改变键值缓存（插入、更新、删除）；</li>
<li>将这种变化以最短的延迟可靠地传达给所有的客户端；</li>
<li>能够处理大量的客户端，成百上千。</li>
</ul>
<p>克隆模式的要点在于客户端会反过来和服务端进行通信，这在简单的发布-订阅模式中并不常见。所以我这里使用“服务端”、“客户端”而不是“发布者”、“订阅者”这两个词。我们会使用发布-订阅模式作为核心消息模式，不过还需要夹杂其他模式。</p>
<h4 id="分发键值更新事件"><a href="#分发键值更新事件" class="headerlink" title="分发键值更新事件"></a>分发键值更新事件</h4><p>我们会分阶段实施克隆模式。首先，我们看看如何从服务器发送键值更新事件给所有的客户端。我们将第一章中使用的天气服务模型进行改造，以键值对的方式发送信息，并让客户端使用哈希表来保存：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_3.png" alt="3"></p>
<p>以下是服务端代码：</p>
<p><strong>clonesrv1: Clone server, Model One in C</strong></p>
<pre><code class="c">//
//  克隆模式服务端模型1
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和PUB套接字
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5556&quot;);
    zclock_sleep (200);

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    while (!zctx_interrupted) {
        //  使用键值对分发消息
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
        kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_store   (&amp;kvmsg, kvmap);
    }
    printf (&quot; 已中止\n已发送 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli1: Clone client, Model One in C</strong></p>
<pre><code class="c">//
//  克隆模式客户端模型1
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *updates = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (updates, &quot;tcp://localhost:5556&quot;);

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;

    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (updates);
        if (!kvmsg)
            break;          //  中断
        kvmsg_store (&amp;kvmsg, kvmap);
        sequence++;
    }
    printf (&quot; 已中断\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>所有复杂的工作都在kvmsg类中完成了，这个类能够处理键值对类型的消息对象，其实质上是一个ZMQ多帧消息，共有三帧：键（ZMQ字符串）、编号（64位，按字节顺序排列）、二进制体（保存所有附加信息）。</li>
<li>服务端随机生成消息，使用四位数作为键，这样可以模拟大量而不是过量的哈希表（1万个条目）。</li>
<li>服务端绑定套接字后会等待200毫秒，以避免订阅者连接延迟而丢失数据的问题。我们会在后面的模型中解决这一点。</li>
<li>我们使用“发布者”和“订阅者”来命名程序中使用的套接字，这样可以避免和后续模型中的其他套接字发生混淆。</li>
</ul>
<p>以下是kvmsg的代码，已经经过了精简：<br><strong>kvsimple: Key-value message class in C</strong></p>
<pre><code class="c">/*  =====================================================================
    kvsimple - simple key-value message class for example applications

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;kvsimple.h&quot;
#include &quot;zlist.h&quot;

//  键是一个短字符串
#define KVMSG_KEY_MAX   255

//  消息被格式化成三帧
//  frame 0: 键（ZMQ字符串）
//  frame 1: 编号（8个字节，按顺序排列）
//  frame 2: 内容（二进制数据块）
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_BODY      2
#define KVMSG_FRAMES    3

//  类结构
struct _kvmsg {
    //  消息中某帧是否存在
    int present [KVMSG_FRAMES];
    //  对应的ZMQ消息帧
    zmq_msg_t frame [KVMSG_FRAMES];
    //  将键转换为C语言字符串
    char key [KVMSG_KEY_MAX + 1];
};


//  ---------------------------------------------------------------------
//  构造函数，设置编号

kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    kvmsg_set_sequence (self, sequence);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

//  释放消息中的帧，可供zhash_freefn()函数调用
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  销毁消息中的帧
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  释放对象本身
        free (self);
    }
}

void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  从套接字中读取键值消息，返回kvmsg实例

kvmsg_t *
kvmsg_recv (void *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (0);

    //  读取所有帧，出错则销毁对象
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = 1;
        if (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], 0) == -1) {
            kvmsg_destroy (&amp;self);
            break;
        }
        //  验证多帧消息
        int rcvmore = (frame_nbr &lt; KVMSG_FRAMES - 1)? 1: 0;
        if (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            break;
        }
    }
    return self;
}


//  ---------------------------------------------------------------------
//  向套接字发送键值对消息，不检验消息帧的内容

void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        if (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - 1)? ZMQ_SNDMORE: 0);
        zmq_msg_close (&amp;copy);
    }
}


//  ---------------------------------------------------------------------
//  从消息中获取键值，不存在则返回NULL

char *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_KEY]) {
        if (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            if (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = 0;
        }
        return self-&gt;key;
    }
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的编号

int64_t
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == 8);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        int64_t sequence = ((int64_t) (source [0]) &lt;&lt; 56)
                         + ((int64_t) (source [1]) &lt;&lt; 48)
                         + ((int64_t) (source [2]) &lt;&lt; 40)
                         + ((int64_t) (source [3]) &lt;&lt; 32)
                         + ((int64_t) (source [4]) &lt;&lt; 24)
                         + ((int64_t) (source [5]) &lt;&lt; 16)
                         + ((int64_t) (source [6]) &lt;&lt; 8)
                         +  (int64_t) (source [7]);
        return sequence;
    }
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  返回消息内容，不存在则返回NULL

byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息内容的大小

size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  设置消息的键

void
kvmsg_set_key (kvmsg_t *self, char *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    if (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的编号

void
kvmsg_set_sequence (kvmsg_t *self, int64_t sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    if (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, 8);

    byte *source = zmq_msg_data (msg);
    source [0] = (byte) ((sequence &gt;&gt; 56) &amp; 255);
    source [1] = (byte) ((sequence &gt;&gt; 48) &amp; 255);
    source [2] = (byte) ((sequence &gt;&gt; 40) &amp; 255);
    source [3] = (byte) ((sequence &gt;&gt; 32) &amp; 255);
    source [4] = (byte) ((sequence &gt;&gt; 24) &amp; 255);
    source [5] = (byte) ((sequence &gt;&gt; 16) &amp; 255);
    source [6] = (byte) ((sequence &gt;&gt; 8)  &amp; 255);
    source [7] = (byte) ((sequence)       &amp; 255);

    self-&gt;present [FRAME_SEQ] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息内容

void
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    if (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = 1;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息键

void
kvmsg_fmt_key (kvmsg_t *self, char *format, ...)
{
    char value [KVMSG_KEY_MAX + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}


//  ---------------------------------------------------------------------
//  使用springf()格式设置消息内容

void
kvmsg_fmt_body (kvmsg_t *self, char *format, ...)
{
    char value [255 + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}


//  ---------------------------------------------------------------------
//  若kvmsg结构的键值均存在，则存入哈希表；
//  如果kvmsg结构已没有引用，则自动销毁和释放。

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (self-&gt;present [FRAME_KEY]
        &amp;&amp;  self-&gt;present [FRAME_BODY]) {
            zhash_update (hash, kvmsg_key (self), self);
            zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
        }
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  将消息内容打印至标准错误输出，用以调试和跟踪

void
kvmsg_dump (kvmsg_t *self)
{
    if (self) {
        if (!self) {
            fprintf (stderr, &quot;NULL&quot;);
            return;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, &quot;[seq:%&quot; PRId64 &quot;]&quot;, kvmsg_sequence (self));
        fprintf (stderr, &quot;[key:%s]&quot;, kvmsg_key (self));
        fprintf (stderr, &quot;[size:%zd] &quot;, size);
        int char_nbr;
        for (char_nbr = 0; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, &quot;%02X&quot;, body [char_nbr]);
        fprintf (stderr, &quot;\n&quot;);
    }
    else
        fprintf (stderr, &quot;NULL message\n&quot;);
}


//  ---------------------------------------------------------------------
//  测试用例

int
kvmsg_test (int verbose)
{
    kvmsg_t
        *kvmsg;

    printf (&quot; * kvmsg: &quot;);

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *output = zsocket_new (ctx, ZMQ_DEALER);
    int rc = zmq_bind (output, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);
    void *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);

    zhash_t *kvmap = zhash_new ();

    //  测试简单消息的发送和接受
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    kvmsg_store (&amp;kvmsg, kvmap);

    //  关闭并销毁所有对象
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    printf (&quot;OK\n&quot;);
    return 0;
}
</code></pre>
<p>我们会在下文编写一个更为完整的kvmsg类，可以用到现实环境中。</p>
<p>客户端和服务端都会维护一个哈希表，但这个模型需要所有的客户端都比服务端启动得早，而且不能崩溃，这显然不能满足可靠性的要求。</p>
<h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><p>为了让后续连接的（或从故障中恢复的）客户端能够获取服务器上的状态信息，需要让它在连接时获取一份快照。正如我们将“消息”的概念简化为“已编号的键值对”，我们也可以将“状态”简化为“一个哈希表”。为获取服务端状态，客户端会打开一个REQ套接字进行请求：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_4.png" alt="4"></p>
<p>我们需要考虑时间的问题，因为生成快照是需要一定时间的，我们需要知道应从哪个更新事件开始更新快照，服务端是不知道何时有更新事件的。一种方法是先开始订阅消息，收到第一个消息之后向服务端请求“将该条更新之前的所有内容发送给”。这样一来，服务器需要为每一次更新保存一份快照，这显然是不现实的。</p>
<p>所以，我们会在客户端用以下方式进行同步：</p>
<ul>
<li><p>客户端开始订阅服务器的更新事件，然后请求一份快照。这样就能保证这份快照是在上一次更新事件之后产生的。</p>
</li>
<li><p>客户端开始等待服务器的快照，并将更新事件保存在队列中，做法很简单，不要从套接字中读取消息就可以了，ZMQ会自动将这些消息保存起来，这时不应设置阈值（HWM）。</p>
</li>
<li><p>当客户端获取到快照后，它将再次开始读取更新事件，但是需要丢弃那些早于快照生成时间的事件。如快照生成时包含了200次更新，那客户端会从第201次更新开始读取。</p>
</li>
<li><p>随后，客户端就会用更新事件去更新自身的状态了。</p>
</li>
</ul>
<p>这是一个比较简单的模型，因为它用到了ZMQ消息队列的机制。服务端代码如下：</p>
<p><strong>clonesrv2: Clone server, Model Two in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 服务端 - 模型2
//

//  让我们直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);
static void state_manager (void *args, zctx_t *ctx, void *pipe);

int main (void)
{
    //  准备套接字和上下文
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);

    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    //  开启状态管理器，并等待同步信号
    void *updates = zthread_fork (ctx, state_manager, NULL);
    free (zstr_recv (updates));

    while (!zctx_interrupted) {
        //  分发键值消息
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
        kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_send     (kvmsg, updates);
        kvmsg_destroy (&amp;kvmsg);
    }
    printf (&quot; 已中断\n已发送 %d 条消息\n&quot;, (int) sequence);
    zctx_destroy (&amp;ctx);
    return 0;
}

//  快照请求方信息
typedef struct {
    void *socket;           //  用于发送快照的ROUTER套接字
    zframe_t *identity;     //  请求方的标识
} kvroute_t;

//  发送快照中单个键值对
//  使用kvmsg对象作为载体
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  先发送接收方标识
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}

//  该线程维护服务端状态，并处理快照请求。
//
static void
state_manager (void *args, zctx_t *ctx, void *pipe)
{
    zhash_t *kvmap = zhash_new ();

    zstr_send (pipe, &quot;READY&quot;);
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);

    zmq_pollitem_t items [] = {
        { pipe, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    int64_t sequence = 0;       //  当前快照版本
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, -1);
        if (rc == -1 &amp;&amp; errno == ETERM)
            break;              //  上下文异常

        //  等待主线程的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (pipe);
            if (!kvmsg)
                break;          //  中断
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        //  执行快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  中断

            //  请求内容在第二帧中
            char *request = zstr_recv (snapshot);
            if (streq (request, &quot;ICANHAZ?&quot;))
                free (request);
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照给客户端
            kvroute_t routing = { snapshot, identity };

            //  逐项发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识，内含快照版本号
            printf (&quot;正在发送快照，版本号 %d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    zhash_destroy (&amp;kvmap);
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli2: Clone client, Model Two in C</strong></p>
<pre><code class="c">//
// 克隆模式 - 客户端 - 模型2
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);

    zhash_t *kvmap = zhash_new ();

    //  获取快照
    int64_t sequence = 0;
    zstr_send (snapshot, &quot;ICANHAZ?&quot;);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  中断
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;已获取快照，版本号=%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  完成
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    //  应用队列中的更新事件，丢弃过时事件
    while (!zctx_interrupted) {
        kvmsg_t *kvmsg = kvmsg_recv (subscriber);
        if (!kvmsg)
            break;          //  中断
        if (kvmsg_sequence (kvmsg) &gt; sequence) {
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>客户端使用两个线程，一个用来生成随机的更新事件，另一个用来管理状态。两者之间使用PAIR套接字通信。可能你会考虑使用SUB套接字，但是“慢连接”的问题会影响到程序运行。PAIR套接字会让两个线程严格同步的。</p>
</li>
<li><p>我们在updates套接字上设置了阈值（HWM），避免更新服务内存溢出。在inproc协议的连接中，阈值是两端套接字阈值的加和，所以要分别设置。</p>
</li>
<li><p>客户端比较简单，用C语言编写，大约60行代码。大多数工作都在kvmsg类中完成了，不过总的来说，克隆模式实现起来还是比较简单的。</p>
</li>
<li><p>我们没有用特别的方式来序列化状态内容。键值对用kvmsg对象表示，保存在一个哈希表中。在不同的时间请求状态时会得到不同的快照。</p>
</li>
<li><p>我们假设客户端只和一个服务进行通信，而且服务必须是正常运行的。我们暂不考虑如何从服务崩溃的情形中恢复过来。</p>
</li>
</ul>
<p>现在，这两段程序都还没有真正地工作起来，但已经能够正确地同步状态了。这是一个多种消息模式的混合体：进程内的PAIR、发布-订阅、ROUTER-DEALER等。</p>
<h4 id="重发键值更新事件"><a href="#重发键值更新事件" class="headerlink" title="重发键值更新事件"></a>重发键值更新事件</h4><p>第二个模型中，键值更新事件都来自于服务器，构成了一个中心化的模型。但是我们需要的是一个能够在客户端进行更新的缓存，并能同步到其他客户端中。这时，服务端只是一个无状态的中间件，带来的好处有：</p>
<ul>
<li>我们不用太过关心服务端的可靠性，因为即使它崩溃了，我们仍能从客户端中获取完整的数据。</li>
<li>我们可以使用键值缓存在动态节点之间分享数据。</li>
</ul>
<p>客户端的键值更新事件会通过PUSH-PULL套接字传达给服务端：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_5.png" alt="5"></p>
<p>我们为什么不让客户端直接将更新信息发送给其他客户端呢？虽然这样做可以减少延迟，但是就无法为更新事件添加自增的唯一编号了。很多应用程序都需要更新事件以某种方式排序，只有将消息发给服务端，由服务端分发更新消息，才能保证更新事件的顺序。</p>
<p>有了唯一的编号后，客户端还能检测到更多的故障：网络堵塞或队列溢出。如果客户端发现消息输入流有一段空白，它能采取措施。可能你会觉得此时让客户端通知服务端，让它重新发送丢失的信息，可以解决问题。但事实上没有必要这么做。消息流的空挡表示网络状况不好，如果再进行这样的请求，只会让事情变得更糟。所以一般的做法是由客户端发出警告，并停止运行，等到有专人来维护后再继续工作。<br>我们开始创建在客户端进行状态更新的模型。以下是客户端代码：</p>
<p><strong>clonesrv3: Clone server, Model Three in C</strong></p>
<pre><code class="c">//
//  克隆模式 服务端 模型3
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);

//  快照请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
} kvroute_t;


int main (void)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);
    void *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, &quot;tcp://*:5558&quot;);

    int64_t sequence = 0;
    zhash_t *kvmap = zhash_new ();

    zmq_pollitem_t items [] = {
        { collector, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC);

        //  执行来自客户端的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            if (!kvmsg)
                break;          //  中断
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (&quot;I: 发布更新事件 %5d\n&quot;, (int) sequence);
        }
        //  响应快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  中断

            //  请求内容在消息的第二帧中
            char *request = zstr_recv (snapshot);
            if (streq (request, &quot;ICANHAZ?&quot;))
                free (request);
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照
            kvroute_t routing = { snapshot, identity };

            //  逐条发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识和编号
            printf (&quot;I: 正在发送快照，版本号：%d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    printf (&quot; 已中断\n已处理 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    return 0;
}

//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  Send identity of recipient first
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli3: Clone client, Model Three in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 客户端 - 模型3
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, &quot;tcp://localhost:5558&quot;);

    zhash_t *kvmap = zhash_new ();
    srandom ((unsigned) time (NULL));

    //  获取状态快照
    int64_t sequence = 0;
    zstr_send (snapshot, &quot;ICANHAZ?&quot;);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  中断
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;I: 已收到快照，版本号：%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  完成
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    int64_t alarm = zclock_time () + 1000;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, 0, ZMQ_POLLIN, 0 } };
        int tickless = (int) ((alarm - zclock_time ()));
        if (tickless &lt; 0)
            tickless = 0;
        int rc = zmq_poll (items, 1, tickless * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文被关闭

        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            if (!kvmsg)
                break;          //  中断

            //  丢弃过时消息，包括心跳
            if (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (&quot;I: 收到更新事件：%d\n&quot;, (int) sequence);
            }
            else
                kvmsg_destroy (&amp;kvmsg);
        }
        //  创建一个随机的更新事件
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
            kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
    }
    printf (&quot; 已准备\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>服务端整合为一个线程，负责收集来自客户端的更新事件并转发给其他客户端。它使用PULL套接字获取更新事件，ROUTER套接字处理快照请求，以及PUB套接字发布更新事件。</p>
</li>
<li><p>客户端会每隔1秒左右发送随机的更新事件给服务端，现实中这一动作由应用程序触发。</p>
</li>
</ul>
<h4 id="子树克隆"><a href="#子树克隆" class="headerlink" title="子树克隆"></a>子树克隆</h4><p>现实中的键值缓存会越变越多，而客户端可能只会需要部分缓存。我们可以使用子树的方式来实现：客户端在发送快照请求时告诉服务端它需要的子树，在订阅更新事件时也指明子树。</p>
<p>关于子树的语法有很多，一种是“分层路径”结构，另一种是“主题树”：</p>
<ul>
<li>分层路径：/some/list/of/paths<ul>
<li>主题树：some.list.of.topics</li>
</ul>
</li>
</ul>
<p>这里我们会使用分层路径结构，以此扩展服务端和客户端，进行子树操作。维护多个子树其实并不太困难，因此我们不在这里演示。</p>
<p>下面是服务端代码，由模型3衍化而来：</p>
<p><strong>clonesrv4: Clone server, Model Four in C</strong></p>
<pre><code class="c">//
//  克隆模式 服务端 模型4
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);

//  快照请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
    char *subtree;          //  指定的子树
} kvroute_t;


int main (void)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);
    void *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, &quot;tcp://*:5558&quot;);

    int64_t sequence = 0;
    zhash_t *kvmap = zhash_new ();

    zmq_pollitem_t items [] = {
        { collector, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC);

        //  执行来自客户端的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            if (!kvmsg)
                break;          //  Interrupted
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (&quot;I: 发布更新事件 %5d\n&quot;, (int) sequence);
        }
        //  响应快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  Interrupted

            //  请求内容在消息的第二帧中
            char *request = zstr_recv (snapshot);
            char *subtree = NULL;
            if (streq (request, &quot;ICANHAZ?&quot;)) {
                free (request);
                subtree = zstr_recv (snapshot);
            }
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照
            kvroute_t routing = { snapshot, identity, subtree };

            //  逐条发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识和编号
            printf (&quot;I: 正在发送快照，版本号：%d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    printf (&quot; 已中断\n已处理 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    return 0;
}

//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方的标识
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}
</code></pre>
<p>下面是客户端代码：</p>
<p><strong>clonecli4: Clone client, Model Four in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 客户端 - 模型4
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

#define SUBTREE &quot;/client/&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);
    zsockopt_set_subscribe (subscriber, SUBTREE);
    void *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, &quot;tcp://localhost:5558&quot;);

    zhash_t *kvmap = zhash_new ();
    srandom ((unsigned) time (NULL));

    //  获取状态快照
    int64_t sequence = 0;
    zstr_sendm (snapshot, &quot;ICANHAZ?&quot;);
    zstr_send  (snapshot, SUBTREE);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  Interrupted
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;I: 已收到快照，版本号：%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  Done
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }

    int64_t alarm = zclock_time () + 1000;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, 0, ZMQ_POLLIN, 0 } };
        int tickless = (int) ((alarm - zclock_time ()));
        if (tickless &lt; 0)
            tickless = 0;
        int rc = zmq_poll (items, 1, tickless * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文被关闭

        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            if (!kvmsg)
                break;          //  中断

            //  丢弃过时消息，包括心跳
            if (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (&quot;I: 收到更新事件：%d\n&quot;, (int) sequence);
            }
            else
                kvmsg_destroy (&amp;kvmsg);
        }
        //  创建一个随机的更新事件
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, &quot;%s%d&quot;, SUBTREE, randof (10000));
            kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
    }
    printf (&quot; 已准备\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<h4 id="瞬间值"><a href="#瞬间值" class="headerlink" title="瞬间值"></a>瞬间值</h4><p>瞬间值指的是那些会立刻过期的值。如果你用克隆模式搭建一个类似DNS的服务时，就可以用瞬间值来模拟动态DNS解析了。当节点连接网络，对外发布它的地址，并不断地更新地址。如果节点断开连接，则它的地址也会失效。</p>
<p>瞬间值可以和会话（session）联系起来，当会话结束时，瞬间值也就失效了。克隆模式中，会话是由客户端定义的，并会在客户端断开连接时消亡。</p>
<p>更简单的方法是为每一个瞬间值设定一个过期时间，客户端会不断延长这个时间，当断开连接时这个时间将得不到更新，服务器就会自动将其删除。</p>
<p>我们会用这种简单的方法来实现瞬间值，因为太过复杂的方法可能不值当，它们的差别仅在性能上体现。如果客户端有很多瞬间值，那为每个值设定过期时间是恰当的；如果瞬间值到达一定的量，那最好还是将其和会话相关联，统一进行过期处理。</p>
<p>首先，我们需要设法在键值对消息中加入过期时间。我们可以增加一个消息帧，但这样一来每当我们需要增加消息内容时就需要修改kvmsg类库了，这并不合适。所以，我们一次性增加一个“属性”消息帧，用于添加不同的消息属性。</p>
<p>其次，我们需要设法删除这条数据。目前为止服务端和客户端会盲目地增改哈希表中的数据，我们可以这样定义：当消息的值是空的，则表示删除这个键的数据。</p>
<p>下面是一个更为完整的kvmsg类代码，它实现了“属性”帧，以及一个UUID帧，我们后面会用到。该类还会负责处理值为空的消息，达到删除的目的：</p>
<p><strong>kvmsg: Key-value message class - full in C</strong></p>
<pre><code class="c">/*  =====================================================================
    kvmsg - key-value message class for example applications

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;kvmsg.h&quot;
#include &lt;uuid/uuid.h&gt;
#include &quot;zlist.h&quot;

//  键是短字符串
#define KVMSG_KEY_MAX   255

//  消息包含五帧
//  frame 0: 键(ZMQ字符串)
//  frame 1: 编号(8个字节，按顺序排列)
//  frame 2: UUID(二进制块，16个字节)
//  frame 3: 属性(ZMQ字符串)
//  frame 4: 值(二进制块)
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_UUID      2
#define FRAME_PROPS     3
#define FRAME_BODY      4
#define KVMSG_FRAMES    5

//  类结构
struct _kvmsg {
    //  帧是否存在
    int present [KVMSG_FRAMES];
    //  对应消息帧
    zmq_msg_t frame [KVMSG_FRAMES];
    //  键，C语言字符串格式
    char key [KVMSG_KEY_MAX + 1];
    //  属性列表，key=value形式
    zlist_t *props;
    size_t props_size;
};


//  将属性列表序列化为字符串
static void
s_encode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    if (self-&gt;present [FRAME_PROPS])
        zmq_msg_close (msg);

    zmq_msg_init_size (msg, self-&gt;props_size);
    char *prop = zlist_first (self-&gt;props);
    char *dest = (char *) zmq_msg_data (msg);
    while (prop) {
        strcpy (dest, prop);
        dest += strlen (prop);
        *dest++ = &#39;\n&#39;;
        prop = zlist_next (self-&gt;props);
    }
    self-&gt;present [FRAME_PROPS] = 1;
}

//  从字符串中解析属性列表
static void
s_decode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    self-&gt;props_size = 0;
    while (zlist_size (self-&gt;props))
        free (zlist_pop (self-&gt;props));

    size_t remainder = zmq_msg_size (msg);
    char *prop = (char *) zmq_msg_data (msg);
    char *eoln = memchr (prop, &#39;\n&#39;, remainder);
    while (eoln) {
        *eoln = 0;
        zlist_append (self-&gt;props, strdup (prop));
        self-&gt;props_size += strlen (prop) + 1;
        remainder -= strlen (prop) + 1;
        prop = eoln + 1;
        eoln = memchr (prop, &#39;\n&#39;, remainder);
    }
}


//  ---------------------------------------------------------------------
//  构造函数，指定消息编号

kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    self-&gt;props = zlist_new ();
    kvmsg_set_sequence (self, sequence);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

//  释放内存函数，供zhash_free_fn()调用
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  释放所有消息帧
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  释放属性列表
        while (zlist_size (self-&gt;props))
            free (zlist_pop (self-&gt;props));
        zlist_destroy (&amp;self-&gt;props);

        //  释放对象本身
        free (self);
    }
}

void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  复制kvmsg对象

kvmsg_t *
kvmsg_dup (kvmsg_t *self)
{
    kvmsg_t *kvmsg = kvmsg_new (0);
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr]) {
            zmq_msg_t *src = &amp;self-&gt;frame [frame_nbr];
            zmq_msg_t *dst = &amp;kvmsg-&gt;frame [frame_nbr];
            zmq_msg_init_size (dst, zmq_msg_size (src));
            memcpy (zmq_msg_data (dst),
                    zmq_msg_data (src), zmq_msg_size (src));
            kvmsg-&gt;present [frame_nbr] = 1;
        }
    }
    kvmsg-&gt;props = zlist_copy (self-&gt;props);
    return kvmsg;
}


//  ---------------------------------------------------------------------
//  从套接字总读取键值对，返回kvmsg实例

kvmsg_t *
kvmsg_recv (void *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (0);

    //  读取所有帧，若有异常则直接返回空
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = 1;
        if (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], 0) == -1) {
            kvmsg_destroy (&amp;self);
            break;
        }
        //  验证多帧消息
        int rcvmore = (frame_nbr &lt; KVMSG_FRAMES - 1)? 1: 0;
        if (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            break;
        }
    }
    if (self)
        s_decode_props (self);
    return self;
}


//  ---------------------------------------------------------------------
//  向套接字发送键值对消息，空消息也发送

void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    s_encode_props (self);
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        if (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - 1)? ZMQ_SNDMORE: 0);
        zmq_msg_close (&amp;copy);
    }
}


//  ---------------------------------------------------------------------
//  返回消息的键

char *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_KEY]) {
        if (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            if (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = 0;
        }
        return self-&gt;key;
    }
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的编号

int64_t
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == 8);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        int64_t sequence = ((int64_t) (source [0]) &lt;&lt; 56)
                         + ((int64_t) (source [1]) &lt;&lt; 48)
                         + ((int64_t) (source [2]) &lt;&lt; 40)
                         + ((int64_t) (source [3]) &lt;&lt; 32)
                         + ((int64_t) (source [4]) &lt;&lt; 24)
                         + ((int64_t) (source [5]) &lt;&lt; 16)
                         + ((int64_t) (source [6]) &lt;&lt; 8)
                         +  (int64_t) (source [7]);
        return sequence;
    }
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  返回消息的UUID

byte *
kvmsg_uuid (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_UUID]
    &amp;&amp;  zmq_msg_size (&amp;self-&gt;frame [FRAME_UUID]) == sizeof (uuid_t))
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_UUID]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的内容

byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息内容的长度

size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  设置消息的键

void
kvmsg_set_key (kvmsg_t *self, char *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    if (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的编号

void
kvmsg_set_sequence (kvmsg_t *self, int64_t sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    if (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, 8);

    byte *source = zmq_msg_data (msg);
    source [0] = (byte) ((sequence &gt;&gt; 56) &amp; 255);
    source [1] = (byte) ((sequence &gt;&gt; 48) &amp; 255);
    source [2] = (byte) ((sequence &gt;&gt; 40) &amp; 255);
    source [3] = (byte) ((sequence &gt;&gt; 32) &amp; 255);
    source [4] = (byte) ((sequence &gt;&gt; 24) &amp; 255);
    source [5] = (byte) ((sequence &gt;&gt; 16) &amp; 255);
    source [6] = (byte) ((sequence &gt;&gt; 8)  &amp; 255);
    source [7] = (byte) ((sequence)       &amp; 255);

    self-&gt;present [FRAME_SEQ] = 1;
}


//  ---------------------------------------------------------------------
//  生成并设置消息的UUID

void
kvmsg_set_uuid (kvmsg_t *self)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_UUID];
    uuid_t uuid;
    uuid_generate (uuid);
    if (self-&gt;present [FRAME_UUID])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, sizeof (uuid));
    memcpy (zmq_msg_data (msg), uuid, sizeof (uuid));
    self-&gt;present [FRAME_UUID] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的内容

void
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    if (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = 1;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息的键
void
kvmsg_fmt_key (kvmsg_t *self, char *format, ...)
{
    char value [KVMSG_KEY_MAX + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息内容

void
kvmsg_fmt_body (kvmsg_t *self, char *format, ...)
{
    char value [255 + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}


//  ---------------------------------------------------------------------
//  获取消息属性，无则返回空字符串

char *
kvmsg_get_prop (kvmsg_t *self, char *name)
{
    assert (strchr (name, &#39;=&#39;) == NULL);
    char *prop = zlist_first (self-&gt;props);
    size_t namelen = strlen (name);
    while (prop) {
        if (strlen (prop) &gt; namelen
        &amp;&amp;  memcmp (prop, name, namelen) == 0
        &amp;&amp;  prop [namelen] == &#39;=&#39;)
            return prop + namelen + 1;
        prop = zlist_next (self-&gt;props);
    }
    return &quot;&quot;;
}


//  ---------------------------------------------------------------------
//  设置消息属性
//  属性名称不能包含=号，值的最大长度是255

void
kvmsg_set_prop (kvmsg_t *self, char *name, char *format, ...)
{
    assert (strchr (name, &#39;=&#39;) == NULL);

    char value [255 + 1];
    va_list args;
    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);

    //  分配空间
    char *prop = malloc (strlen (name) + strlen (value) + 2);

    //  删除已存在的属性
    sprintf (prop, &quot;%s=&quot;, name);
    char *existing = zlist_first (self-&gt;props);
    while (existing) {
        if (memcmp (prop, existing, strlen (prop)) == 0) {
            self-&gt;props_size -= strlen (existing) + 1;
            zlist_remove (self-&gt;props, existing);
            free (existing);
            break;
        }
        existing = zlist_next (self-&gt;props);
    }
    //  添加新属性
    strcat (prop, value);
    zlist_append (self-&gt;props, prop);
    self-&gt;props_size += strlen (prop) + 1;
}


//  ---------------------------------------------------------------------
//  在哈希表中保存kvmsg对象
//  当kvmsg对象不再被使用时进行释放操作；
//  若传入的值为空，则删除该对象。

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (kvmsg_size (self)) {
            if (self-&gt;present [FRAME_KEY]
            &amp;&amp;  self-&gt;present [FRAME_BODY]) {
                zhash_update (hash, kvmsg_key (self), self);
                zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
            }
        }
        else
            zhash_delete (hash, kvmsg_key (self));

        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  将消息内容输出到标准错误输出

void
kvmsg_dump (kvmsg_t *self)
{
    if (self) {
        if (!self) {
            fprintf (stderr, &quot;NULL&quot;);
            return;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, &quot;[seq:%&quot; PRId64 &quot;]&quot;, kvmsg_sequence (self));
        fprintf (stderr, &quot;[key:%s]&quot;, kvmsg_key (self));
        fprintf (stderr, &quot;[size:%zd] &quot;, size);
        if (zlist_size (self-&gt;props)) {
            fprintf (stderr, &quot;[&quot;);
            char *prop = zlist_first (self-&gt;props);
            while (prop) {
                fprintf (stderr, &quot;%s;&quot;, prop);
                prop = zlist_next (self-&gt;props);
            }
            fprintf (stderr, &quot;]&quot;);
        }
        int char_nbr;
        for (char_nbr = 0; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, &quot;%02X&quot;, body [char_nbr]);
        fprintf (stderr, &quot;\n&quot;);
    }
    else
        fprintf (stderr, &quot;NULL message\n&quot;);
}


//  ---------------------------------------------------------------------
//  测试用例

int
kvmsg_test (int verbose)
{
    kvmsg_t
        *kvmsg;

    printf (&quot; * kvmsg: &quot;);

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *output = zsocket_new (ctx, ZMQ_DEALER);
    int rc = zmq_bind (output, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);
    void *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);

    zhash_t *kvmap = zhash_new ();

    //  测试简单消息的收发
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    kvmsg_store (&amp;kvmsg, kvmap);

    // 测试带有属性的消息的收发
    kvmsg = kvmsg_new (2);
    kvmsg_set_prop (kvmsg, &quot;prop1&quot;, &quot;value1&quot;);
    kvmsg_set_prop (kvmsg, &quot;prop2&quot;, &quot;value1&quot;);
    kvmsg_set_prop (kvmsg, &quot;prop2&quot;, &quot;value2&quot;);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    assert (streq (kvmsg_get_prop (kvmsg, &quot;prop2&quot;), &quot;value2&quot;));
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_destroy (&amp;kvmsg);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    assert (streq (kvmsg_get_prop (kvmsg, &quot;prop2&quot;), &quot;value2&quot;));
    kvmsg_destroy (&amp;kvmsg);

    //  关闭并销毁所有对象
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    printf (&quot;OK\n&quot;);
    return 0;
}
</code></pre>
<p>客户端模型5和模型4没有太大区别，只是kvmsg类库变了。在更新消息的时候还需要添加一个过期时间的属性：</p>
<pre><code class="c">kvmsg_set_prop (kvmsg, &quot;ttl&quot;, &quot;%d&quot;, randof (30));
</code></pre>
<p>服务端模型5有较大的变化，我们会用反应堆来代替轮询，这样就能混合处理定时事件和套接字事件了，只是在C语言中是比较麻烦的。下面是代码：</p>
<p><strong>clonesrv5: Clone server, Model Five in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 服务端 - 模型5
//

//  直接编译，不建类库
#include &quot;kvmsg.c&quot;

//  反应堆处理器
static int s_snapshots  (zloop_t *loop, void *socket, void *args);
static int s_collector  (zloop_t *loop, void *socket, void *args);
static int s_flush_ttl  (zloop_t *loop, void *socket, void *args);

//  服务器属性
typedef struct {
    zctx_t *ctx;                //  上下文
    zhash_t *kvmap;             //  键值对存储
    zloop_t *loop;              //  zloop反应堆
    int port;                   //  主端口
    int64_t sequence;           //  更新事件编号
    void *snapshot;             //  处理快照请求
    void *publisher;            //  发布更新事件
    void *collector;            //  从客户端收集接收更新事件
} clonesrv_t;


int main (void)
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));

    self-&gt;port = 5556;
    self-&gt;ctx = zctx_new ();
    self-&gt;kvmap = zhash_new ();
    self-&gt;loop = zloop_new ();
    zloop_set_verbose (self-&gt;loop, FALSE);

    //  打开克隆模式服务端套接字
    self-&gt;snapshot  = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_PULL);
    zsocket_bind (self-&gt;snapshot,  &quot;tcp://*:%d&quot;, self-&gt;port);
    zsocket_bind (self-&gt;publisher, &quot;tcp://*:%d&quot;, self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, &quot;tcp://*:%d&quot;, self-&gt;port + 2);

    //  注册反应堆处理程序
    zloop_reader (self-&gt;loop, self-&gt;snapshot, s_snapshots, self);
    zloop_reader (self-&gt;loop, self-&gt;collector, s_collector, self);
    zloop_timer  (self-&gt;loop, 1000, 0, s_flush_ttl, self);

    //  运行反应堆，直至中断
    zloop_start (self-&gt;loop);

    zloop_destroy (&amp;self-&gt;loop);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);
    return 0;
}


//  ---------------------------------------------------------------------
//  发送快照内容

static int s_send_single (char *key, void *data, void *args);

//  请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
    char *subtree;          //  子树信息
} kvroute_t;

static int
s_snapshots (zloop_t *loop, void *snapshot, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zframe_t *identity = zframe_recv (snapshot);
    if (identity) {
        //  请求位于消息第二帧
        char *request = zstr_recv (snapshot);
        char *subtree = NULL;
        if (streq (request, &quot;ICANHAZ?&quot;)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        else
            printf (&quot;E: 错误的请求，程序中止\n&quot;);

        if (subtree) {
            //  发送状态快照
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);

            //  发送结束符和版本号
            zclock_log (&quot;I: 正在发送快照，版本号：%d&quot;, (int) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    return 0;
}


//  每次发送一个快照键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方标识
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  收集更新事件

static int
s_collector (zloop_t *loop, void *collector, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (collector);
    if (kvmsg) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        int ttl = atoi (kvmsg_get_prop (kvmsg, &quot;ttl&quot;));
        if (ttl)
            kvmsg_set_prop (kvmsg, &quot;ttl&quot;,
                &quot;%&quot; PRId64, zclock_time () + ttl * 1000);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布更新事件 %d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  删除过期的瞬间值

static int s_flush_single (char *key, void *data, void *args);

static int
s_flush_ttl (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    return 0;
}

//  删除过期的键值对，并广播该事件
static int
s_flush_single (char *key, void *data, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = (kvmsg_t *) data;
    int64_t ttl;
    sscanf (kvmsg_get_prop (kvmsg, &quot;ttl&quot;), &quot;%&quot; PRId64, &amp;ttl);
    if (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 发布删除事件 %d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}
</code></pre>
<h4 id="克隆服务器的可靠性"><a href="#克隆服务器的可靠性" class="headerlink" title="克隆服务器的可靠性"></a>克隆服务器的可靠性</h4><p>克隆模型1至5相对比较简单，下面我们会探讨一个非常复杂的模型。可以发现，为了构建可靠的消息队列，我们需要花费非常多的精力。所以我们经常会问：有必要这么做吗？如果说你能够接受可靠性不够高的、或者说已经足够好的架构，那恭喜你，你在成本和收益之间找到了平衡。虽然我们会偶尔丢失一些消息，但从经济的角度来说还是合理的。不管怎样，下面我们就来介绍这个复杂的模型。</p>
<p>在模型3中，你会关闭和重启服务，这会导致数据的丢失。任何后续加入的客户端只能得到重启之后的那些数据，而非所有的。下面就让我们想办法让克隆模式能够承担服务器重启的故障。</p>
<p>以下列举我们需要处理的问题：</p>
<ul>
<li><p>克隆服务器进程崩溃并自动或手工重启。进程丢失了所有数据，所以必须从别处进行恢复。</p>
</li>
<li><p>克隆服务器硬件故障，长时间不能恢复。客户端需要切换至另一个可用的服务端。</p>
</li>
<li><p>克隆服务器从网络上断开，如交换机发生故障等。它会在某个时点重连，但期间的数据就需要替代的服务器负责处理。</p>
</li>
</ul>
<p>第一步我们需要增加一个服务器。我们可以使用第四章中提到的双子星模式，它是一个反应堆，而我们的程序经过整理后也是一个反应堆，因此可以互相协作。</p>
<p>我们需要保证更新事件在主服务器崩溃时仍能保留，最简单的机制就是同时发送给两台服务器。</p>
<p>备机就可以当做一台客户端来运行，像其他客户端一样从主机获取更新事件。同时它又能从客户端获取更新事件——虽然不应该以此更新数据，但可以先暂存起来。</p>
<p>所以，相较于模型5，模型6中引入了以下特性：</p>
<ul>
<li><p>客户端发送更新事件改用PUB-SUB套接字，而非PUSH-PULL。原因是PUSH套接字会在没有接收方时阻塞，且会进行负载均衡——我们需要两台服务器都接收到消息。我们会在服务器端绑定SUB套接字，在客户端连接PUB套接字。</p>
</li>
<li><p>我们在服务器发送给客户端的更新事件中加入心跳，这样客户端可以知道主机是否已死，然后切换至备机。</p>
</li>
<li><p>我们使用双子星模式的bstar反应堆类来创建主机和备机。双子星模式中需要有一个“投票”套接字，来协助判定对方节点是否已死。这里我们使用快照请求来作为“投票”。</p>
</li>
<li><p>我们将为所有的更新事件添加UUID属性，它由客户端生成，服务端会将其发布给所有客户端。</p>
</li>
<li><p>备机将维护一个“待处理列表”，保存来自客户端、尚未由服务端发布的更新事件；或者反过来，来自服务端、尚未从客户端收到的更新事件。这个列表从旧到新排列，这样就能方便地从顶部删除消息。</p>
</li>
</ul>
<p>我们可以为客户端设计一个有限状态机，它有三种状态：</p>
<ul>
<li><p>客户端打开并连接了套接字，然后向服务端发送快照请求。为了避免消息风暴，它只会请求两次。</p>
</li>
<li><p>客户端等待快照应答，如果获得了则保存它；如果没有获得，则向第二个服务器发送请求。</p>
</li>
<li><p>客户端收到快照，便开始等待更新事件。如果在一定时间内没有收到服务端响应，则会连接第二个服务端。</p>
</li>
</ul>
<p>客户端会一直循环下去，可能在程序刚启动时，部分客户端会试图连接主机，部分连接备机，相信双子星模式会很好地处理这一情况的。</p>
<p>我们可以将客户端状态图绘制出来：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_6.png" alt="6"></p>
<p>故障恢复的步骤如下：</p>
<ul>
<li>客户端检测到主机不再发送心跳，因此转而连接备机，并请求一份新的快照；</li>
<li>备机开始接收快照请求，并检测到主机死亡，于是开始作为主机运行；</li>
<li>备机将待处理列表中的更新事件写入自身状态中，然后开始处理快照请求。</li>
</ul>
<p>当主机恢复连接时：</p>
<ul>
<li>启动为slave状态，并作为克隆模式客户端连接备机；</li>
<li>同时，使用SUB套接字从客户端接收更新事件。</li>
</ul>
<p>我们做两点假设：</p>
<ul>
<li>至少有一台主机会继续运行。如果两台主机都崩溃了，那我们将丢失所有的服务端数据，无法恢复。</li>
<li>不同的客户端不会同时更新同一个键值对。客户端的更新事件会先后到达两个服务器，因此更新的顺序可能会不一致。单个客户端的更新事件到达两台服务器的顺序是相同的，所以不用担心。</li>
</ul>
<p>下面是整体架构图：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_7.png" alt="7"></p>
<p>开始编程之前，我们需要将客户端重构成一个可复用的类。在ZMQ中写异步类有时是为了练习如何写出优雅的代码，但这里我们确实是希望克隆模式可以成为一种易于使用的程序。上述架构的伸缩性来源于客户端的正确行为，因此有必要将其封装成一份API。要在客户端中进行故障恢复还是比较复杂的，试想一下自由者模式和克隆模式结合起来会是什么样的吧。</p>
<p>按照我的习惯，我会先写出一份API的列表，然后加以实现。让我们假想一个名为clone的API，在其基础之上编写克隆模式客户端API。将代码封装为API显然会提升代码的稳定性，就以模型5为例，客户端需要打开三个套接字，端点名称直接写在了代码里。我们可以创建这样一组API：</p>
<pre><code class="c">    //  为每个套接字指定端点
    clone_subscribe (clone, &quot;tcp://localhost:5556&quot;);
    clone_snapshot  (clone, &quot;tcp://localhost:5557&quot;);
    clone_updates   (clone, &quot;tcp://localhost:5558&quot;);

    //  由于有两个服务端，因此再执行一次
    clone_subscribe (clone, &quot;tcp://localhost:5566&quot;);
    clone_snapshot  (clone, &quot;tcp://localhost:5567&quot;);
    clone_updates   (clone, &quot;tcp://localhost:5568&quot;);
</code></pre>
<p>但这种写法还是比较啰嗦的，因为没有必要将API内部的一些设计暴露给编程人员。现在我们会使用三个套接字，而将来可能就会使用两个，或者四个。我们不可能让所有的应用程序都相应地修改吧？让我们把这些信息包装到API中：</p>
<pre><code class="c">    //  指定主备服务器端点
    clone_connect (clone, &quot;tcp://localhost:5551&quot;);
    clone_connect (clone, &quot;tcp://localhost:5561&quot;);
</code></pre>
<p>这样一来代码就变得非常简洁，不过也会对现有代码的内部就够造成影响。我们需要从一个端点中推算出三个端点。一种方法是假设客户端和服务端使用三个连续的端点通信，并将这个规则写入协议；另一个方法是向服务器索取缺少的端点信息。我们使用第一种较为简单的方法：</p>
<ul>
<li>服务器状态ROUTER在端点P；</li>
<li>服务器更新事件PUB在端点P + 1；</li>
<li>服务器更新事件SUB在端点P + 2。</li>
</ul>
<p>clone类和第四章的flcliapi类很类似，由两部分组成：</p>
<ul>
<li>一个在后台运行的异步克隆模式代理。该代理处理所有的I/O操作，实时地和服务器进行通信；</li>
<li>一个在前台应用程序中同步运行的clone类。当你创建了一个clone对象后，它会自动创建后台的clone线程；当你销毁clone对象，该后台线程也会被销毁。</li>
</ul>
<p>前台的clone类会使用inproc管道和后台的代理进行通信。C语言中，czmq线程会自动为我们创建这个管道。这也是ZMQ多线程编程的常规方式。</p>
<p>如果没有ZMQ，这种异步的设计将很难处理高压工作，而ZMQ会让其变得简单。编写出来额代码会相对比较复杂。我们可以用反应堆的模式来编写，但这会进一步增加复杂度，且影响应用程序的使用。因此，我们的设计的API将更像是一个能够和服务器进行通信的键值表：</p>
<pre><code class="c">clone_t *clone_new (void);
void clone_destroy (clone_t **self_p);
void clone_connect (clone_t *self, char *address, char *service);
void clone_set (clone_t *self, char *key, char *value);
char *clone_get (clone_t *self, char *key);
</code></pre>
<p>下面就是克隆模式客户端模型6的代码，因为调用了API，所以非常简短：<br><strong>clonecli6: Clone client, Model Six in C</strong></p>
<pre><code>//
//  克隆模式 - 客户端 - 模型6
//

//  直接编译，不建类库
#include &quot;clone.c&quot;

#define SUBTREE &quot;/client/&quot;

int main (void)
{
    //  创建分布式哈希表
    clone_t *clone = clone_new ();

    //  配置
    clone_subtree (clone, SUBTREE);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5556&quot;);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5566&quot;);

    //  插入随机键值
    while (!zctx_interrupted) {
        //  生成随机值
        char key [255];
        char value [10];
        sprintf (key, &quot;%s%d&quot;, SUBTREE, randof (10000));
        sprintf (value, &quot;%d&quot;, randof (1000000));
        clone_set (clone, key, value, randof (30));
        sleep (1);
    }
    clone_destroy (&amp;clone);
    return 0;
}
</code></pre><p>以下是clone类的实现：<br><strong>clone: Clone class in C</strong></p>
<pre><code class="c">/*  =====================================================================
    clone - client-side Clone Pattern class

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;clone.h&quot;

//  请求超时时间
#define GLOBAL_TIMEOUT  4000    //  msecs
//  判定服务器死亡的时间
#define SERVER_TTL      5000    //  msecs
//  服务器数量
#define SERVER_MAX      2


//  =====================================================================
//  同步部分，在应用程序线程中工作

//  ---------------------------------------------------------------------
//  类结构

struct _clone_t {
    zctx_t *ctx;                //  上下文
    void *pipe;                 //  和后台代理间的通信套接字
};

//  该线程用于处理真正的clone类
static void clone_agent (void *args, zctx_t *ctx, void *pipe);


//  ---------------------------------------------------------------------
//  构造函数

clone_t *
clone_new (void)
{
    clone_t
        *self;

    self = (clone_t *) zmalloc (sizeof (clone_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, clone_agent, NULL);
    return self;
}

//  ---------------------------------------------------------------------
//  析构函数

void
clone_destroy (clone_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        clone_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  在链接之前指定快照和更新事件的子树
//  发送给后台代理的消息内容为[SUBTREE][subtree]

void clone_subtree (clone_t *self, char *subtree)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;SUBTREE&quot;);
    zmsg_addstr (msg, subtree);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  连接至新的服务器端点
//  消息内容：[CONNECT][endpoint][service]

void
clone_connect (clone_t *self, char *address, char *service)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;CONNECT&quot;);
    zmsg_addstr (msg, address);
    zmsg_addstr (msg, service);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  设置新值
//  消息内容：[SET][key][value][ttl]

void
clone_set (clone_t *self, char *key, char *value, int ttl)
{
    char ttlstr [10];
    sprintf (ttlstr, &quot;%d&quot;, ttl);

    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;SET&quot;);
    zmsg_addstr (msg, key);
    zmsg_addstr (msg, value);
    zmsg_addstr (msg, ttlstr);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  取值
//  消息内容：[GET][key]
//  如果没有clone可用，会返回NULL

char *
clone_get (clone_t *self, char *key)
{
    assert (self);
    assert (key);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;GET&quot;);
    zmsg_addstr (msg, key);
    zmsg_send (&amp;msg, self-&gt;pipe);

    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    if (reply) {
        char *value = zmsg_popstr (reply);
        zmsg_destroy (&amp;reply);
        return value;
    }
    return NULL;
}


//  =====================================================================
//  异步部分，在后台运行

//  ---------------------------------------------------------------------
//  单个服务端信息

typedef struct {
    char *address;              //  服务端地址
    int port;                   //  端口
    void *snapshot;             //  快照套接字
    void *subscriber;           //  接收更新事件的套接字
    uint64_t expiry;            //  服务器过期时间
    uint requests;              //  收到的快照请求数
} server_t;

static server_t *
server_new (zctx_t *ctx, char *address, int port, char *subtree)
{
    server_t *self = (server_t *) zmalloc (sizeof (server_t));

    zclock_log (&quot;I: adding server %s:%d...&quot;, address, port);
    self-&gt;address = strdup (address);
    self-&gt;port = port;

    self-&gt;snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (self-&gt;snapshot, &quot;%s:%d&quot;, address, port);
    self-&gt;subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, &quot;%s:%d&quot;, address, port + 1);
    zsockopt_set_subscribe (self-&gt;subscriber, subtree);
    return self;
}

static void
server_destroy (server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;address);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  后台代理类

//  状态
#define STATE_INITIAL       0   //  连接之前
#define STATE_SYNCING       1   //  正在同步
#define STATE_ACTIVE        2   //  正在更新

typedef struct {
    zctx_t *ctx;                //  上下文
    void *pipe;                 //  与主线程通信的套接字
    zhash_t *kvmap;             //  键值表
    char *subtree;              //  子树
    server_t *server [SERVER_MAX];
    uint nbr_servers;           //  范围：0 - SERVER_MAX
    uint state;                 //  当前状态
    uint cur_server;            //  当前master，0/1
    int64_t sequence;           //  键值对编号
    void *publisher;            //  发布更新事件的套接字
} agent_t;

static agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;kvmap = zhash_new ();
    self-&gt;subtree = strdup (&quot;&quot;);
    self-&gt;state = STATE_INITIAL;
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    return self;
}

static void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        int server_nbr;
        for (server_nbr = 0; server_nbr &lt; self-&gt;nbr_servers; server_nbr++)
            server_destroy (&amp;self-&gt;server [server_nbr]);
        zhash_destroy (&amp;self-&gt;kvmap);
        free (self-&gt;subtree);
        free (self);
        *self_p = NULL;
    }
}

//  若线程被中断则返回-1
static int
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    char *command = zmsg_popstr (msg);
    if (command == NULL)
        return -1;

    if (streq (command, &quot;SUBTREE&quot;)) {
        free (self-&gt;subtree);
        self-&gt;subtree = zmsg_popstr (msg);
    }
    else
    if (streq (command, &quot;CONNECT&quot;)) {
        char *address = zmsg_popstr (msg);
        char *service = zmsg_popstr (msg);
        if (self-&gt;nbr_servers &lt; SERVER_MAX) {
            self-&gt;server [self-&gt;nbr_servers++] = server_new (
                self-&gt;ctx, address, atoi (service), self-&gt;subtree);
            //  广播更新事件
            zsocket_connect (self-&gt;publisher, &quot;%s:%d&quot;,
                address, atoi (service) + 2);
        }
        else
            zclock_log (&quot;E: too many servers (max. %d)&quot;, SERVER_MAX);
        free (address);
        free (service);
    }
    else
    if (streq (command, &quot;SET&quot;)) {
        char *key = zmsg_popstr (msg);
        char *value = zmsg_popstr (msg);
        char *ttl = zmsg_popstr (msg);
        zhash_update (self-&gt;kvmap, key, (byte *) value);
        zhash_freefn (self-&gt;kvmap, key, free);

        //  向服务端发送键值对
        kvmsg_t *kvmsg = kvmsg_new (0);
        kvmsg_set_key  (kvmsg, key);
        kvmsg_set_uuid (kvmsg);
        kvmsg_fmt_body (kvmsg, &quot;%s&quot;, value);
        kvmsg_set_prop (kvmsg, &quot;ttl&quot;, ttl);
        kvmsg_send     (kvmsg, self-&gt;publisher);
        kvmsg_destroy (&amp;kvmsg);
puts (key);
        free (ttl);
        free (key);             //  键值对实际由哈希表对象控制
    }
    else
    if (streq (command, &quot;GET&quot;)) {
        char *key = zmsg_popstr (msg);
        char *value = zhash_lookup (self-&gt;kvmap, key);
        if (value)
            zstr_send (self-&gt;pipe, value);
        else
            zstr_send (self-&gt;pipe, &quot;&quot;);
        free (key);
        free (value);
    }
    free (command);
    zmsg_destroy (&amp;msg);
    return 0;
}


//  ---------------------------------------------------------------------
//  异步的后台代理会维护一个服务端池，并处理来自应用程序的请求或应答。

static void
clone_agent (void *args, zctx_t *ctx, void *pipe)
{
    agent_t *self = agent_new (ctx, pipe);

    while (TRUE) {
        zmq_pollitem_t poll_set [] = {
            { pipe, 0, ZMQ_POLLIN, 0 },
            { 0,    0, ZMQ_POLLIN, 0 }
        };
        int poll_timer = -1;
        int poll_size = 2;
        server_t *server = self-&gt;server [self-&gt;cur_server];
        switch (self-&gt;state) {
            case STATE_INITIAL:
                //  该状态下，如果有可用服务，会发送快照请求
                if (self-&gt;nbr_servers &gt; 0) {
                    zclock_log (&quot;I: 正在等待服务器 %s:%d...&quot;,
                        server-&gt;address, server-&gt;port);
                    if (server-&gt;requests &lt; 2) {
                        zstr_sendm (server-&gt;snapshot, &quot;ICANHAZ?&quot;);
                        zstr_send  (server-&gt;snapshot, self-&gt;subtree);
                        server-&gt;requests++;
                    }
                    server-&gt;expiry = zclock_time () + SERVER_TTL;
                    self-&gt;state = STATE_SYNCING;
                    poll_set [1].socket = server-&gt;snapshot;
                }
                else
                    poll_size = 1;
                break;
            case STATE_SYNCING:
                //  该状态下我们从服务器端接收快照内容，若失败则尝试其他服务器
                poll_set [1].socket = server-&gt;snapshot;
                break;
            case STATE_ACTIVE:
                //  该状态下我们从服务器获取更新事件，失败则尝试其他服务器
                poll_set [1].socket = server-&gt;subscriber;
                break;
        }
        if (server) {
            poll_timer = (server-&gt;expiry - zclock_time ())
                       * ZMQ_POLL_MSEC;
            if (poll_timer &lt; 0)
                poll_timer = 0;
        }
        //  ------------------------------------------------------------
        //  poll循环
        int rc = zmq_poll (poll_set, poll_size, poll_timer);
        if (rc == -1)
            break;              //  上下文已被关闭

        if (poll_set [0].revents &amp; ZMQ_POLLIN) {
            if (agent_control_message (self))
                break;          //  中断
        }
        else
        if (poll_set [1].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (poll_set [1].socket);
            if (!kvmsg)
                break;          //  中断

            //  任何服务端的消息将重置它的过期时间
            server-&gt;expiry = zclock_time () + SERVER_TTL;
            if (self-&gt;state == STATE_SYNCING) {
                //  保存快照内容
                server-&gt;requests = 0;
                if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    self-&gt;state = STATE_ACTIVE;
                    zclock_log (&quot;I: received from %s:%d snapshot=%d&quot;,
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                    kvmsg_destroy (&amp;kvmsg);
                }
                else
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            }
            else
            if (self-&gt;state == STATE_ACTIVE) {
                //  丢弃过期的更新事件
                if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
                    zclock_log (&quot;I: received from %s:%d update=%d&quot;,
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                }
                else
                    kvmsg_destroy (&amp;kvmsg);
            }
        }
        else {
            //  服务端已死，尝试其他服务器
            zclock_log (&quot;I: 服务器 %s:%d 无响应&quot;,
                    server-&gt;address, server-&gt;port);
            self-&gt;cur_server = (self-&gt;cur_server + 1) % self-&gt;nbr_servers;
            self-&gt;state = STATE_INITIAL;
        }
    }
    agent_destroy (&amp;self);
}
</code></pre>
<p>最后是克隆服务器的模型6代码：</p>
<p><strong>clonesrv6: Clone server, Model Six in C</strong></p>
<pre><code class="c">//
// 克隆模式 - 服务端 - 模型6
//

//  直接编译，不建类库
#include &quot;bstar.c&quot;
#include &quot;kvmsg.c&quot;

//  bstar反应堆API
static int s_snapshots  (zloop_t *loop, void *socket, void *args);
static int s_collector  (zloop_t *loop, void *socket, void *args);
static int s_flush_ttl  (zloop_t *loop, void *socket, void *args);
static int s_send_hugz  (zloop_t *loop, void *socket, void *args);
static int s_new_master (zloop_t *loop, void *unused, void *args);
static int s_new_slave  (zloop_t *loop, void *unused, void *args);
static int s_subscriber (zloop_t *loop, void *socket, void *args);

//  服务端属性
typedef struct {
    zctx_t *ctx;                //  上下文
    zhash_t *kvmap;             //  存放键值对
    bstar_t *bstar;             //  bstar反应堆核心
    int64_t sequence;           //  更新事件编号
    int port;                   //  主端口
    int peer;                   //  同伴端口
    void *publisher;            //  发布更新事件的端口
    void *collector;            //  接收客户端更新事件的端口
    void *subscriber;           //  接受同伴更新事件的端口
    zlist_t *pending;           //  延迟的更新事件
    Bool primary;               //  是否为主机
    Bool master;                //  是否为master
    Bool slave;                 //  是否为slave
} clonesrv_t;


int main (int argc, char *argv [])
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) {
        zclock_log (&quot;I: 作为主机master运行，正在等待备机slave连接。&quot;);
        self-&gt;bstar = bstar_new (BSTAR_PRIMARY, &quot;tcp://*:5003&quot;,
                                 &quot;tcp://localhost:5004&quot;);
        bstar_voter (self-&gt;bstar, &quot;tcp://*:5556&quot;, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = 5556;
        self-&gt;peer = 5566;
        self-&gt;primary = TRUE;
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) {
        zclock_log (&quot;I: 作为备机slave运行，正在等待主机master连接。&quot;);
        self-&gt;bstar = bstar_new (BSTAR_BACKUP, &quot;tcp://*:5004&quot;,
                                 &quot;tcp://localhost:5003&quot;);
        bstar_voter (self-&gt;bstar, &quot;tcp://*:5566&quot;, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = 5566;
        self-&gt;peer = 5556;
        self-&gt;primary = FALSE;
    }
    else {
        printf (&quot;Usage: clonesrv4 { -p | -b }\n&quot;);
        free (self);
        exit (0);
    }
    //  主机将成为master
    if (self-&gt;primary)
        self-&gt;kvmap = zhash_new ();

    self-&gt;ctx = zctx_new ();
    self-&gt;pending = zlist_new ();
    bstar_set_verbose (self-&gt;bstar, TRUE);

    //  设置克隆服务端套接字
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_bind (self-&gt;publisher, &quot;tcp://*:%d&quot;, self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, &quot;tcp://*:%d&quot;, self-&gt;port + 2);

    //  作为克隆客户端连接同伴
    self-&gt;subscriber = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, &quot;tcp://localhost:%d&quot;, self-&gt;peer + 1);

    //  注册状态事件处理器
    bstar_new_master (self-&gt;bstar, s_new_master, self);
    bstar_new_slave (self-&gt;bstar, s_new_slave, self);

    //  注册bstar反应堆其他事件处理器
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;collector, s_collector, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_flush_ttl, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_send_hugz, self);

    //  开启bstar反应堆
    bstar_start (self-&gt;bstar);

    //  中断，终止。
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_destroy (&amp;kvmsg);
    }
    zlist_destroy (&amp;self-&gt;pending);
    bstar_destroy (&amp;self-&gt;bstar);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);

    return 0;
}


//  ---------------------------------------------------------------------
//  发送快照内容

static int s_send_single (char *key, void *data, void *args);

//  请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求放标识
    char *subtree;          //  子树
} kvroute_t;

static int
s_snapshots (zloop_t *loop, void *snapshot, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zframe_t *identity = zframe_recv (snapshot);
    if (identity) {
        //  请求在消息的第二帧中
        char *request = zstr_recv (snapshot);
        char *subtree = NULL;
        if (streq (request, &quot;ICANHAZ?&quot;)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        else
            printf (&quot;E: 错误的请求，正在退出……\n&quot;);

        if (subtree) {
            //  发送状态快照
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);

            //  发送终止消息，以及消息编号
            zclock_log (&quot;I: 正在发送快照，版本号：%d&quot;, (int) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    return 0;
}


//  每次发送一个快照键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方的地址
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  从客户端收集更新事件
//  如果我们是master，则将该事件写入kvmap对象；
//  如果我们是slave，则将其写入延迟队列

static int s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg);

static int
s_collector (zloop_t *loop, void *collector, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (collector);
    kvmsg_dump (kvmsg);
    if (kvmsg) {
        if (self-&gt;master) {
            kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
            kvmsg_send (kvmsg, self-&gt;publisher);
            int ttl = atoi (kvmsg_get_prop (kvmsg, &quot;ttl&quot;));
            if (ttl)
                kvmsg_set_prop (kvmsg, &quot;ttl&quot;,
                    &quot;%&quot; PRId64, zclock_time () + ttl * 1000);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (&quot;I: 正在发布更新事件：%d&quot;, (int) self-&gt;sequence);
        }
        else {
            //  如果我们已经从master中获得了该事件，则丢弃该消息
            if (s_was_pending (self, kvmsg))
                kvmsg_destroy (&amp;kvmsg);
            else
                zlist_append (self-&gt;pending, kvmsg);
        }
    }
    return 0;
}

//  如果消息已在延迟队列中，则删除它并返回TRUE

static int
s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg)
{
    kvmsg_t *held = (kvmsg_t *) zlist_first (self-&gt;pending);
    while (held) {
        if (memcmp (kvmsg_uuid (kvmsg),
                    kvmsg_uuid (held), sizeof (uuid_t)) == 0) {
            zlist_remove (self-&gt;pending, held);
            return TRUE;
        }
        held = (kvmsg_t *) zlist_next (self-&gt;pending);
    }
    return FALSE;
}


//  ---------------------------------------------------------------------
//  删除带有过期时间的瞬间值

static int s_flush_single (char *key, void *data, void *args);

static int
s_flush_ttl (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    return 0;
}

//  如果键值对过期，则进行删除操作，并广播该事件
static int
s_flush_single (char *key, void *data, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = (kvmsg_t *) data;
    int64_t ttl;
    sscanf (kvmsg_get_prop (kvmsg, &quot;ttl&quot;), &quot;%&quot; PRId64, &amp;ttl);
    if (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布删除事件：%d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  发送心跳

static int
s_send_hugz (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
    kvmsg_set_key  (kvmsg, &quot;HUGZ&quot;);
    kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
    kvmsg_send     (kvmsg, self-&gt;publisher);
    kvmsg_destroy (&amp;kvmsg);

    return 0;
}


//  ---------------------------------------------------------------------
//  状态改变事件处理函数
//  我们将转变为master
//
//  备机先将延迟列表中的事件更新到自己的快照中，
//  并开始接收客户端发来的快照请求。

static int
s_new_master (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    self-&gt;master = TRUE;
    self-&gt;slave = FALSE;
    zloop_cancel (bstar_zloop (self-&gt;bstar), self-&gt;subscriber);

    //  应用延迟列表中的事件
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布延迟列表中的更新事件：%d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}

//  ---------------------------------------------------------------------
//  正在切换为slave

static int
s_new_slave (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zhash_destroy (&amp;self-&gt;kvmap);
    self-&gt;master = FALSE;
    self-&gt;slave = TRUE;
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;subscriber,
                  s_subscriber, self);

    return 0;
}

//  ---------------------------------------------------------------------
//  从同伴主机（master）接收更新事件；
//  接收该类更新事件时，我们一定是slave。

static int
s_subscriber (zloop_t *loop, void *subscriber, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    //  获取快照，如果需要的话。
    if (self-&gt;kvmap == NULL) {
        self-&gt;kvmap = zhash_new ();
        void *snapshot = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
        zsocket_connect (snapshot, &quot;tcp://localhost:%d&quot;, self-&gt;peer);
        zclock_log (&quot;I: 正在请求快照：tcp://localhost:%d&quot;,
                    self-&gt;peer);
        zstr_send (snapshot, &quot;ICANHAZ?&quot;);
        while (TRUE) {
            kvmsg_t *kvmsg = kvmsg_recv (snapshot);
            if (!kvmsg)
                break;          //  中断
            if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
                self-&gt;sequence = kvmsg_sequence (kvmsg);
                kvmsg_destroy (&amp;kvmsg);
                break;          //  完成
            }
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        }
        zclock_log (&quot;I: 收到快照，版本号：%d&quot;, (int) self-&gt;sequence);
        zsocket_destroy (self-&gt;ctx, snapshot);
    }
    //  查找并删除
    kvmsg_t *kvmsg = kvmsg_recv (subscriber);
    if (!kvmsg)
        return 0;

    if (strneq (kvmsg_key (kvmsg), &quot;HUGZ&quot;)) {
        if (!s_was_pending (self, kvmsg)) {
            //  如果master的更新事件比客户端的事件早到，则将master的事件存入延迟列表，
            //  当收到客户端更新事件时会将其从列表中清除。
            zlist_append (self-&gt;pending, kvmsg_dup (kvmsg));
        }
        //  如果更新事件比kvmap版本高，则应用它
        if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
            self-&gt;sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (&quot;I: 收到更新事件：%d&quot;, (int) self-&gt;sequence);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    else
        kvmsg_destroy (&amp;kvmsg);

    return 0;
}
</code></pre>
<p>这段程序只有几百行，但还是花了一些时间来进行调通的。这个模型中包含了故障恢复，瞬间值，子树等等。虽然我们前期设计得很完备，但要在多个套接字之间进行调试还是很困难的。以下是我的工作方式：</p>
<ul>
<li><p>由于使用了反应堆（bstar，建立在zloop之上），我们节省了大量的代码，让程序变得简洁明了。整个服务以一个线程运行，因此不会出现跨线程的问题。只需将结构指针（self）传递给所有的处理器即可。此外，使用发应堆后可以让代码更为模块化，易于重用。</p>
</li>
<li><p>我们逐个模块进行调试，只有某个模块能够正常运行时才会进入下一步。由于使用了四五个套接字，因此调试的工作量是很大的。我直接将调试信息输出到了屏幕上，因为实在没有必要专门开一个调试器来工作。</p>
</li>
<li><p>因为一直在使用valgrind工具进行测试，因此我能确定程序没有内存泄漏的问题。在C语言中，内存泄漏是我们非常关心的问题，因为没有什么垃圾回收机制可以帮你完成。正确地使用像kvmsg、czmq之类的抽象层可以很好地避免内存泄漏。</p>
</li>
</ul>
<p>这段程序肯定还会存在一些BUG，部分读者可能会帮助我调试和修复，我在此表示感谢。</p>
<p>测试模型6时，先开启主机和备机，再打开一组客户端，顺序随意。随机地中止某个服务进程，如果程序设计得是正确的，那客户端获得的数据应该都是一致的。</p>
<h4 id="克隆模式协议"><a href="#克隆模式协议" class="headerlink" title="克隆模式协议"></a>克隆模式协议</h4><p>花费了那么多精力来开发一套可靠的发布-订阅模式机制，我们当然希望将来能够方便地在其基础之上进行扩展。较好的方法是将其编写为一个协议，这样就能让各种语言来实现它了。</p>
<p>我们将其称为“集群化哈希表协议”，这是一个能够跨集群地进行键值哈希表管理，提供了多客户端的通信机制；客户端可以只操作一个子树的数据，包括更新和定义瞬间值。</p>
<ul>
<li><a href="http://rfc.zeromq.org/spec:12" target="_blank" rel="external">http://rfc.zeromq.org/spec:12</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/weixinpay.jpg" alt="Dear Amaze WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="Dear Amaze Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/zmq-网络编程/" rel="tag"># zmq,网络编程</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/24/zmq_chapter4/" rel="next" title="zmq学习第四章">
                <i class="fa fa-chevron-left"></i> zmq学习第四章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/26/zmq_chapter2/" rel="prev" title="zmq学习第二章">
                zmq学习第二章 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar2.jpg"
               alt="Dear Amaze" />
          <p class="site-author-name" itemprop="name">Dear Amaze</p>
           
              <p class="site-description motion-element" itemprop="description">最穷不过要饭丶不死总会出头</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">44</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fdl66" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/qq_27803491" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-desktop"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/ao-jie-88/answers" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-vimeo"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://hello-fh.com/" title="浩哥" target="_blank">浩哥</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://githubecho.github.io/" title="阿谦" target="_blank">阿谦</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-高级发布-订阅模式"><span class="nav-number">1.</span> <span class="nav-text">第五章 高级发布-订阅模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测慢订阅者（自杀的蜗牛模式）"><span class="nav-number">1.1.</span> <span class="nav-text">检测慢订阅者（自杀的蜗牛模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高速订阅者（黑箱模式）"><span class="nav-number">1.2.</span> <span class="nav-text">高速订阅者（黑箱模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享键值缓存（克隆模式）"><span class="nav-number">1.3.</span> <span class="nav-text">共享键值缓存（克隆模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分发键值更新事件"><span class="nav-number">1.3.1.</span> <span class="nav-text">分发键值更新事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建快照"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重发键值更新事件"><span class="nav-number">1.3.3.</span> <span class="nav-text">重发键值更新事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子树克隆"><span class="nav-number">1.3.4.</span> <span class="nav-text">子树克隆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#瞬间值"><span class="nav-number">1.3.5.</span> <span class="nav-text">瞬间值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆服务器的可靠性"><span class="nav-number">1.3.6.</span> <span class="nav-text">克隆服务器的可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆模式协议"><span class="nav-number">1.3.7.</span> <span class="nav-text">克隆模式协议</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dear Amaze</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("fOpTd1WjHbULIjn8MszImyoU-gzGzoHsz", "BD6q7tNiA5K8GhdTkj9uEy0u");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  <script>
      // highlight
      hljs.initHighlightingOnLoad();
  </script>
</body>
</html>
