<!doctype html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Amaze" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="最穷不过要饭丶不死总会出头">
<meta property="og:type" content="website">
<meta property="og:title" content="DearAmaze-桀骜良">
<meta property="og:url" content="https://dearamaze.com/index.html">
<meta property="og:site_name" content="DearAmaze-桀骜良">
<meta property="og:description" content="最穷不过要饭丶不死总会出头">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DearAmaze-桀骜良">
<meta name="twitter:description" content="最穷不过要饭丶不死总会出头">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://dearamaze.com/"/>





  <title> DearAmaze-桀骜良 </title>
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?05e47eef3e87bfa03fe6dfcdad14b688";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  
  <!--<script type="text/javascript" color="0,191,255" opacity="0.7" zindex="-2" count="150" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>-->
  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DearAmaze-桀骜良</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">test_subtitle</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/12/13/各大公司git地址/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/13/各大公司git地址/" itemprop="url">
                  各大公司git地址
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T00:00:00+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目/" itemprop="url" rel="index">
                    <span itemprop="name">项目</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/13/各大公司git地址/" class="leancloud_visitors" data-flag-title="各大公司git地址">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>github,一个神奇的网址<br>gitbook，另一个神奇的网址，.com,.net,.cn都可以逛一下</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/12/13/各大公司git地址/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/12/08/pthread常用接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/08/pthread常用接口/" itemprop="url">
                  pthread常用接口
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T00:00:00+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/08/pthread常用接口/" class="leancloud_visitors" data-flag-title="pthread常用接口">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h2><p>判断两个线程ID是否相等<br><code>int pthread_equal(pthread_t tid1,pthread tid2);</code></p>
<ul>
<li>参数：<ul>
<li>tid1：第一个线程ID</li>
<li>tid2：第二个线程ID</li>
</ul>
</li>
<li>返回值：<br>  -相等：返回非0数值<ul>
<li>不等：返回 0</li>
</ul>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/12/08/pthread常用接口/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/12/04/标准IO库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/04/标准IO库/" itemprop="url">
                  标准IO库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T00:00:00+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/apue/" itemprop="url" rel="index">
                    <span itemprop="name">apue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/04/标准IO库/" class="leancloud_visitors" data-flag-title="标准IO库">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="流和-FILE对象"><a href="#流和-FILE对象" class="headerlink" title="流和 FILE对象"></a>流和 FILE对象</h2><ol>
<li><p>标准IO库与文件IO区别：</p>
<ul>
<li>标准IO库处理很多细节，如缓冲区分片、以优化的块长度执行IO等。</li>
<li>文件IO函数都是围绕文件描述符进行。首先打开一个文件，返回一个文件描述符；后续的文件IO操作都使用该文件描述符</li>
<li>标准IO库是围绕流进行的。当用标准IO库打开或者创建一个文件时，就有一个内建的流与之相关联<blockquote>
<p>标准IO库的函数很多都是以 <code>f</code>开头，如<code>fopen</code>、<code>fclose</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>对于ASCII字符集，一个字符用一个字节表示；对于国际字符集，一个字符可以用多个字节表示。</p>
<ul>
<li>标准IO文件流可用于单字节或者多字节字符集。流的定向决定了所处理的字符是单字节还是多字节的。</li>
<li>当一个流最初被创建时，它并没有定向。<ul>
<li>若在未定向的流上使用一个多字节IO函数，则将该流的定向设置为宽定向的（即处理多字节）</li>
<li>若在未定向的流上使用一个单字节IO函数，则将该流的定向设置为字节定向的（即处理单字节）</li>
</ul>
</li>
<li>只有两个函数可以改变流的定向<ul>
<li><code>freopen</code>函数清除一个流的定向</li>
<li><code>fwide</code>函数设置流的定向</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fwide</code>函数：设置流的定向</p>
<pre><code> #include&lt;stdio.h&gt;
 #include&lt;wchar.h&gt;
 int fwide(FILE *fp,int mode);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：<code>FILE</code>文件对象的指针</li>
<li><code>mode</code>：流的定向模式。<ul>
<li>如果<code>mode</code>是负数，则函数试图使指定的流为字节定向（并不保证修改成功，因为<code>fwide</code>并不改变已定向流的定向）</li>
<li>如果<code>mode</code>是正数，则函数试图使指定的流为宽定向的（并不保证修改成功，因为<code>fwide</code>并不改变已定向流的定向）</li>
<li>如果<code>mode</code>为0，则函数不试图设置流的定向，而直接返回该流定向的值</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>若流是宽定向的，返回正值</li>
<li>若流是字节定向的，返回负值</li>
<li>若流是未定向的，返回0<blockquote>
<p>这里并没有函数失败的情况</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
</li>
<li><code>fwide</code>并不改变已定向流的定向。</li>
<li>如果<code>fp</code>是无效流，由于<code>fwide</code>从返回值无法得知函数执行成功还是失败。那么我们必须采用这个方法：首先在调用<code>fwide</code>之前清除<code>errno</code>。然后在<code>fwide</code>之后检查<code>errno</code>的值。通过<code>errno</code>来检测<code>fwide</code>执行成功还是失败。</li>
</ul>
</li>
<li><p><code>FILE</code>指针：当使用<code>fopen</code>函数打开一个流时，它返回一个执行<code>FILE</code>对象的指针。该对象通常是一个结构，包含了标准IO库为管理该流所需要的所有信息，包括：</p>
<ul>
<li>用于实际IO的文件描述符</li>
<li>指向用于该流缓冲区的指针</li>
<li>该流缓冲区的长度</li>
<li>当前在缓冲区中的字符数</li>
<li><p>出错标志</p>
<p>应用程序没必要检验<code>FILE</code>对象，只需要将<code>FILE</code>指针作为参数传递给每个标准IO函数。</p>
<p><img src="../imgs/std_IO/FILE_IO.JPG" alt="FILE"> </p>
</li>
</ul>
</li>
<li><p>操作系统对每个进程与定义了3个流，并且这3个流可以自动地被进程使用，他们都是定义在<code>&lt;stdio.h&gt;</code>中：</p>
<ul>
<li>标准输入：预定义的文件指针为<code>stdin</code>，它内部的文件描述符就是<code>STDIN_FILENO</code></li>
<li>标准输出：预定义的文件指针为<code>stdout</code>，它内部的文件描述符就是<code>STDOUT_FILENO</code></li>
<li>标准错误：预定义的文件指针为<code>stderr</code>，它内部的文件描述符就是<code>STDERR_FILENO</code></li>
</ul>
</li>
<li><p>标准IO库提供缓冲的目的是：尽量减少使用<code>read</code>和<code>write</code>调用的次数。标准IO库对每个IO流自动地进行缓冲管理，从而避免了程序员需要手动管理这一点带来的麻烦。</p>
<p> 标准IO库提供了三种类型的缓冲：</p>
<ul>
<li>全缓冲：此时在标准IO缓冲区被填满后，标准IO库才进行实际的IO操作。</li>
<li>行缓冲：此时当输入和输出中遇到换行符时，标准IO库执行实际的IO操作。但是注意：<ul>
<li>只要填满了缓冲区，即使还没有写一个换行符，也立即进行IO操作</li>
<li>任何时候只要通过标准IO库，从一个不带缓冲的流或者一个行缓冲的流得到输入数据，则会冲洗所有行缓冲输出流。(<font color="red">即要缓冲输入，先冲洗输出缓冲</font>)</li>
</ul>
</li>
<li><p>不带缓冲：标准IO库不对字符进行缓冲存储。此时任何IO都立即执行实际的IO操作。</p>
<p>另外：</p>
</li>
<li>在一个流上执行第一次IO操作时，相关标准的IO函数通常调用 <code>malloc</code>获取使用的缓冲区</li>
<li>缓冲区可以由标准的IO操作自动地冲洗（如，当填满一个缓冲区时），也可以手动调用<code>fflush</code>函数冲洗一个流。</li>
</ul>
</li>
<li><p>ISO C 要求下来缓冲特征：</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，他们才是全缓冲的</li>
<li><p>标准错误绝不会是全缓冲的。</p>
<p>很多操作系统默认使用下列类型的缓冲：</p>
</li>
<li>标准错误<code>stderr</code>时不带缓冲的</li>
<li>标准输入<code>stdin</code>和输出<code>stdout</code>：若是指向终端设备的流，则是行缓冲的；否则是全缓冲的</li>
</ul>
</li>
<li><p><code>setbuf/setvbuf</code>函数：设置流的缓冲类型</p>
<pre><code> #include&lt;stdio.h&gt;
 void setbuf(FILE *restrict fp,char *restrict buf);
 int setvbuf(FILE *restrict fp,char* restrict buf,int mode,size_t size);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：被打开的文件对象的指针</li>
<li><p><code>buf</code>：一个缓冲区的指针。缓冲区长度必须为<code>BUFSIZ</code>常量（该常量定义在<code>&lt;stdio.h&gt;</code>中）。</p>
<ul>
<li>如果<code>buf</code>为<code>NULL</code>，则是关闭缓冲</li>
<li>如果<code>buf</code>非<code>NULL</code>，则通常设定该流为全缓冲的。但若该流与一个设备终端相关，则设为行缓冲的</li>
</ul>
<p>对于<code>setvbuf</code>函数：</p>
</li>
<li><code>buf</code>：一个缓冲区的指针。缓冲区长度为<code>size</code>。<ul>
<li>若<code>buf</code>为<code>NULL</code>，且<code>mode</code>为<code>_IONBF</code>：则该流为不带缓冲的。因为此时忽略<code>buf</code>和<code>size</code>参数</li>
<li>若<code>buf</code>为<code>NULL</code>，且<code>mode</code>不是<code>_IONBF</code>：则标准IO库将自动为该流分片合适长度的缓冲区（即<code>BUFSIZE</code>长度），然后设定该流为指定的<code>mode</code></li>
</ul>
</li>
<li><code>mode</code>：指定缓冲类型。可以为：<ul>
<li><code>_IOFBF</code>：全缓冲。</li>
<li><code>_IOLBF</code>：行缓冲</li>
<li><code>_IONBF</code>：不带缓冲。此时忽略<code>buf</code>和<code>size</code>参数</li>
</ul>
</li>
<li><code>size</code>：缓冲的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回非0(<font color="red">并不是-1</font>)</li>
</ul>
<p>注意：</p>
</li>
<li>如果在一个函数内分配一个自动变量类型的标准IO缓冲区，则从该函数返回之前，必须关闭流。因此自动变量是栈上分配，函数返回之后自动变量被销毁</li>
<li>某些操作系统将缓冲区的一部分存放它自己的管理操作信息，因此可以存放在缓冲区中的实际数据字节数将少于<code>size</code></li>
<li>通常推荐利用操作系统自动选择缓冲区长度并自动分配缓冲区。在这种情况下若关闭此流，则标准IO库会自动释放缓冲区</li>
</ul>
</li>
<li><p><code>fflush</code>函数：手动冲洗一个流</p>
<pre><code> #include&lt;stdio.h&gt;
 int fflush(FILE *fp);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：被打开的文件对象的指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>失败：返回<code>EOF</code> (<font color="red">并不是-1</font>)</li>
</ul>
<p>该函数会使得该流所有未写的数据都被传送至内核。当<code>fp</code>为<code>NULL</code>时，此函数将导致所有输出流被冲洗。</p>
<blockquote>
<ul>
<li>冲洗是双向的：输出流 —&gt; 内核 —&gt; 磁盘或者终端； 输入流—&gt; 用户缓冲区</li>
<li>冲洗并不是立即写到磁盘文件中。冲洗只是负责数据传到内核</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="打开关闭流"><a href="#打开关闭流" class="headerlink" title="打开关闭流"></a>打开关闭流</h2><ol>
<li><p><code>fopen/freopen/fdopen</code>函数：打开标准IO流</p>
<pre><code> #include&lt;stdio.h&gt;
 FILE *fopen(const char*restrict pathname,const char*restrict type);
 FILE *freopen(const char*restrict pathname,const char*restrict type,\
     FILE *restrict fp);
 FILE *fdopen(int fd,const char*type);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>type</code>：指定对该IO流的读写方式：</p>
<ul>
<li><code>&quot;r&quot;</code>或者<code>&quot;rb&quot;</code>：为读打开</li>
<li><code>&quot;w&quot;</code>或者<code>&quot;wb&quot;</code>：写打开。若文件存在则把文件截断为0长；若文件不存在则创建然后写</li>
<li><code>&quot;a&quot;</code>或者<code>&quot;ab&quot;</code>：追加写打开；若文件存在每次都定位到文件末尾；若文件不存在则创建然后写</li>
<li><code>&quot;r+&quot;</code>或者<code>&quot;r+b&quot;</code>或者<code>&quot;rb+&quot;</code>：为读和写打开</li>
<li><code>&quot;w+&quot;</code>或者<code>&quot;w+b&quot;</code>或者<code>&quot;wb+&quot;</code>：若文件存在则文件截断为0然后读写；若文件不存在则创建然后读写</li>
<li><code>&quot;a+&quot;</code>或者<code>&quot;a+b&quot;</code>或者<code>&quot;ab+&quot;</code>：若文件存在则每次都定位到文件末尾然后读写；若文件不存在则创建然后读写<blockquote>
<ul>
<li>其中<code>b</code>用于区分二进制文件和文本文件。但是由于<code>UNIX</code>内核并不区分这两种文件，所以在UNIX环境中指定<code>b</code>并没有什么卵用</li>
<li>创建文件时，无法指定文件访问权限位。POSIX默认要求为：<code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH</code></li>
</ul>
</blockquote>
</li>
</ul>
<p>对于 <code>fopen</code>函数：</p>
</li>
<li><code>pathname</code>：待打开文件的路径名<br>对于 <code>freopen</code>函数：</li>
<li><code>pathname</code>：待打开文件的路径名</li>
<li><p><code>fp</code>：在指定的流上打开文件。若<code>fp</code>已经打开，则先关闭该流；若<code>fp</code>已经定向，则清除该定向。</p>
<p>对于 <code>fdopen</code>函数：</p>
</li>
<li><code>fd</code>：打开文件的文件描述符</li>
<li>对于<code>fopen</code>，<code>type</code>意义稍微有点区别。因为该描述符已经被打开，所以<code>fdopen</code>为写而打开并不截断该文件。另外该文件既然被打开并返回一个文件描述符，则它一定存在。因此标准 IO追加写方式也不能创建文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回文件指针</li>
<li>失败： 返回<code>NULL</code></li>
</ul>
<p>这几个函数的常见用途：</p>
</li>
<li><code>fopen</code>常用于打开一个指定的文件，返回一个文件指针</li>
<li><code>freopen</code>常用于将一个指定的文件打开为一个预定义的流（标准输入、标准输出或者标准错误）</li>
<li><p><code>fdopen</code>常用于将文件描述符包装成一个标准IO流。因为某些特殊类型的文件（如管道、<code>socket</code>文件）不能用<code>fopen</code>打开，必须先获取文件描述符，然后对文件描述符调用<code>fdopen</code>。</p>
<p>注意：当以读和写类型打开一个文件时(<code>type</code>中带<code>+</code>号的类型)，有下列限制：</p>
</li>
<li>如果写操作后面没有<code>fflush,fseek,fsetpos,rewind</code>操作之一，则写操作后面不能紧跟读操作</li>
<li><p>如果读操作后面没有<code>fseek,fsetpos,rewind</code>操作之一，也没有到达文件末尾，则在读操作之后不能紧跟写操作</p>
<p>注意：按照系统默认，流被打开时是全缓冲的。但是如果流引用的是终端设备，则安装系统默认，流被打开时是行缓冲的。</p>
</li>
</ul>
</li>
<li><p><code>fclose</code>：关闭一个打开的流</p>
<pre><code> #include&lt;stdio.h&gt;
 int fclose(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：待关闭的文件指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>在该文件被关闭之前：</p>
</li>
<li><code>fclose</code>会自动冲洗缓冲中的输出数据</li>
<li>缓冲区中的输入数据被丢弃</li>
<li><p>若该缓冲区是标准IO库自动分配的，则释放此缓冲区</p>
<p>当一个进程正常终止时（直接调用<code>exit</code>函数，或者从<code>main</code>函数返回）：</p>
</li>
<li>所有带未写缓存数据的标准IO流都被冲洗</li>
<li>所有打开的标准IO流都被关闭</li>
</ul>
</li>
<li><p>示例:在 <code>main</code>函数中调用 <code>test_fopen_fwide_setvbuf</code>函数：</p>
<pre><code>void test_fopen_fwide_setvbuf()
{
 M_TRACE(&quot;---------  Begin test_fopen_fwide_setvbuf()  ---------\n&quot;);
 assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0);

 My_fwide(stdin,0); //打印 stdin 的流向
 My_fwide(stdout,0); //打印 stdout 的流向
 My_fwide(stderr,0); //打印 stderr 的流向
 print_FILE(stdin); //打印 stdin 结构
 print_FILE(stdout); //打印 stdout 结构
 print_FILE(stderr); //打印 stderr 结构

 FILE *fp=My_fopen(&quot;test&quot;,&quot;r+&quot;);
 if(NULL!=fp)
 {
     My_fwide(fp,0); //打印 fp 的流向
     My_fwide(fp,-1); //设置 fp 为字节流 然后打印 fp 的流向
     My_fwide(fp,1); //无法修改已定向的流
     print_FILE(fp);
     //**** 设置不同的缓冲 ****//
     set_full_buf(fp);
     print_FILE(fp);
     set_line_buf(fp);
     print_FILE(fp);
     set_no_buf(fp);
     print_FILE(fp);

     fclose(fp); //关闭流
 }
 un_prepare_file(&quot;test&quot;);
 M_TRACE(&quot;---------  End test_fopen_fwide_setvbuf()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/FILE_struct.JPG" alt="FILE_struct"></p>
<p> 可以看到：</p>
<ul>
<li>三个标准IO流的文件描述符依次为 0、1、2</li>
<li>未被使用的流不会分配缓冲，因此<code>stdin</code>、<code>stderr</code>的缓冲区地址是 <code>NULL</code>。刚被创建的流的缓冲区地址也是<code>NULL</code>。</li>
<li>未被使用的流是为定向的。因此<code>stdin</code>、<code>stderr</code>是未定向的。刚被创建的流的也是未定向的</li>
<li>对已经定向的流设置流向，并不会改变流的方向。但是也不报告失败。</li>
<li>未分配缓冲区的流，与非缓冲流不是一个概念。非缓冲流是分配了缓冲区的，它的缓冲区长度为1。而未分配缓冲区的流，其缓冲区是无效待分配的。</li>
</ul>
</li>
</ol>
<h2 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h2><ol>
<li><p>一旦打开了流，可以在3中不同类型的非格式化IO中选择，对流进行读、写操作：</p>
<ul>
<li>每次一个字符的IO。一次读、写一个字符。若流是带缓冲的，则标准IO函数处理所有缓冲</li>
<li>每次一行的IO。一次读、写一行。每一行都以一个换行符终止</li>
<li>二进制IO。每次IO读、写某种数量的对象。<blockquote>
<p>格式化IO由<code>printf</code>族函数完成</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>getc/fgetc/getchar</code>函数：一次读一个字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 int getc(FILE*fp);
 int fgetc(FILE*fp);
 int getchar(void);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回下一个字符</li>
<li>到达文件尾端：返回<code>EOF</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>getchar()</code>等价于<code>getc(stdin)</code>。它从标准输入中读取一个字符</li>
<li><code>getc</code>和<code>fgetc</code>的区别在于：<code>getc</code>可能通过宏定义来实现，而<code>fgetc</code>不能实现为宏。因此：<ul>
<li><code>getc</code>的参数不应该是具有副作用的表达式，因为它可能被计算多次</li>
<li><code>fgetc</code>可以得到其地址，这就允许将<code>fgetc</code>的地址作为参数传递。而<code>getc</code>不行</li>
<li>调用<code>fgetc</code>所需的时间可能比调用<code>getc</code>长，因为函数调用所需时间通常比调用宏长</li>
</ul>
</li>
<li>这三个函数在返回下一个字符时，将<code>unsigned char</code>类型转换成了<code>int</code>类型。<blockquote>
<p>因为需要通过返回<code>EOF</code>来标记到达末尾或者出错。而<code>EOF</code>通常是常量 -1 。所以需要返回 <code>int</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>ferror/feof</code>函数：查看是读文件出错，还是到达读文件遇到尾端</p>
<pre><code> #include&lt;stdio.h&gt;
 int ferror(FILE *fp);
 int feof(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>若条件为真：则返回非 0</li>
<li>若条件为假： 则返回 0</li>
</ul>
<p>当读流返回<code>EOF</code>时，我们可能不清楚到底是遇到错误，还是读到了文件尾端。此时必须调用<code>ferror</code>或者<code>feof</code>来区别这两种情况。</p>
</li>
</ul>
</li>
<li><p><code>clearerr</code>函数：清除文件出错标志和文件结束标志</p>
<pre><code> #include&lt;stdio.h&gt;
 void clearerr(FILE *fp)
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
<p>在大多数操作系统中，每个流在<code>FILE</code>对象中维护了两个标志：</p>
</li>
<li>出错标志</li>
<li><p>文件结束标志</p>
<p>调用<code>clearerr</code>函数可以清除这两个标志</p>
</li>
</ul>
</li>
<li><p><code>ungetc</code>函数：将字符压回流中</p>
<pre><code> #include&lt;stdio.h&gt;
 int ungetc(int c,FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>c</code>：待压入字符转换成的整数值</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回 <code>c</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li>若根据某个序列向流中压入一串字符，则再从该流中读取的字符序列是逆序的。即最后压入的字符最先读出</li>
<li>可以执行任意次数的压入单个字符，但是不支持一次压入多个字符</li>
<li><p>不能压入 <code>EOF</code>。但是当已经读到文件尾端时，支持压入一个字符，此时<code>ungetc</code>会清除该流的文件结束标志</p>
<p><code>ungetc</code>通常用于这样的情形：正在读取一个输入流，然后需要根据某个字符串（标记字符串）来对输入进行切分。那么我们就需要先看一看下一个字符，来决定如何处理当前字符。此时需要方便的将刚查看的字符回送。</p>
<blockquote>
<p><code>ungetc</code>只是将字符压入流缓冲区中，并没有压入底层的磁盘文件或者操作系统内核中</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>putc/fputc/putchar</code>函数：一次写一个字符</p>
<pre><code> #include&lt;stdio.h&gt;
 int putc(int c,FILE*fp);
 int fputc(int c,FILE*fp);
 int putchar(int c);
</code></pre><ul>
<li>参数：<ul>
<li><code>c</code>：待写字符转换成的整数值</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回 <code>c</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>putchar(c)</code>等价于<code>putc(c,stdout)</code>。它向标准输出中写一个字符</li>
<li><code>putc</code>和<code>fputc</code>的区别在于：<code>putc</code>可能通过宏定义来实现，而<code>fputc</code>不能实现为宏</li>
</ul>
</li>
<li><p><code>fgets/gets</code>函数：一次读一行字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 char *fgets(char *restrict buf,int n, FILE* restrict fp);
 char *gets(char *buf);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>buf</code>：存放读取到的字符的缓冲区地址</p>
<p>对于 <code>fgets</code>函数：</p>
</li>
<li><code>n</code>：缓冲区长度</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回<code>buf</code></li>
<li>到达文件尾端：返回<code>NULL</code></li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p>注意：</p>
</li>
<li>对于<code>fgets</code>函数，必须指定缓冲区的长度<code>n</code>。该函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符。<ul>
<li>无论读到多少个字符，缓冲区一定以<code>null</code>字节结尾</li>
<li>若某一行包括换行符超过 <code>n-1</code>个字节，则<code>fgets</code>只返回一个不完整的行；下次调用<code>fgets</code>会继续读该行</li>
</ul>
</li>
<li>对于<code>gets</code>函数，从标准输入总读取字符。由于无法指定缓冲区的长度，因此很可能造成缓冲区溢出漏洞。故该函数不推荐使用</li>
<li>对于发生错误和读到末尾，都是返回<code>NULL</code>    </li>
</ul>
</li>
</ol>
<ol>
<li><p><code>fputs/puts</code>函数：一次写一行字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 int fputs(const char* restrict str,FILE*restrict fp);
 int puts(const char*str);
</code></pre><ul>
<li>参数：<ul>
<li><code>str</code>：待写的字符串</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回非负值</li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>fputs</code>和<code>puts</code>都是将一个以<code>null</code>字节终止的字符串写到流中，末尾的<code>null</code>字符不写出！。<font color="red">字符串不要求以换行符结尾！</font></li>
<li><code>puts</code>将字符串写到标准输出，末尾的<code>null</code>字符不写出！<font color="red">但是<code>puts</code>随后又将一个换行符写到标准输出中！</font>。而<code>fputs</code>不会自动添加换行符。<blockquote>
<p>虽然<code>puts</code>是安全的，但是我们也是要避免使用它，以免要记住它在最后是否添加了一个换行符。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>fread/fwrite</code>函数：执行二进制读写IO</p>
<pre><code> #include&lt;stdio.h&gt;
 size_t fread(void *restrict ptr,size_t size,size_t nobj,FILE *restrict fp);
 size_t fwrite(const void*restrict ptr,size_t size,size_t nobj,FILE *restrict fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>ptr</code>:存放二进制数据对象的缓冲区地址</li>
<li><code>size</code>：单个二进制数据对象的字节数（比如一个<code>struct</code>的大小）</li>
<li><code>nobj</code>：二进制数据对象的数量</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功或失败： 读/写的对象数<ul>
<li>对于读：如果出错或者到达文件尾端，则此数字可以少于<code>nobj</code>。此时应调用<code>ferror</code>或者<code>feof</code>来判断究竟是那种情况</li>
<li>对于写：如果返回值少于<code>nobj</code>，则出错</li>
</ul>
</li>
</ul>
<p>使用二进制IO的基本问题是：它只能用在读取同一个操作系统上已写的数据。如果跨操作系统读写，则很可能工作异常。因为：</p>
</li>
<li>同一个<code>struct</code>，可能在不同操作系统或者不同编译系统中，成员的偏移量不同</li>
<li>存储多字节整数和浮点数的二进制格式在不同的操作系统中可能不同</li>
</ul>
</li>
</ol>
<ol>
<li><p>有三种方法定位标准IO流</p>
<ul>
<li><p>通过 <code>ftell/fseek</code>函数：</p>
<pre><code>  #include&lt;stdio.h&gt;
  long ftell(FILE *fp);
</code></pre><ul>
<li>参数：<code>fp</code>：打开的文件对象指针</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回当前文件位置指示</li>
<li><p>失败：返回 -1L</p>
<p>若是二进制文件，则文件指示器是从文件开始位置度量的，并以字节为度量单位。<code>ftell</code>就是返回这种字节位置。</p>
</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
int fseek(FILE *fp,long offset,int whence);
</code></pre></li>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>offset</code>：偏移量。其解释依赖于<code>whence</code></li>
<li><code>whence</code>：偏移量的解释方式：<ul>
<li><code>SEEK_SET</code>常量：表示从文件的起始位置开始</li>
<li><code>SEEK_CUR</code>常量：表示从文件的当前位置开始</li>
<li><code>SEEK_END</code>常量：表示从文件的尾端开始</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回 0</li>
<li><p>失败：返回 -1</p>
<blockquote>
<p>原书说，对文本文件和二进制文件，<code>fseek</code>定位有某些限制。但是经过在<code>ubuntu 16.04</code>上测试，可以任意定位。并没有要求说不能定位到文件尾端，以及必须用<code>SEEK_SET</code>等诸多限制。</p>
</blockquote>
</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
void rewind(FILE *fp);
</code></pre></li>
<li><p>参数：</p>
<ul>
<li><p><code>fp</code>：打开的文件对象指针</p>
<p><code>rewind</code>函数将一个流设置到文件的起始位置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过 <code>ftello/fseeko</code>函数：除了偏移量类型为<code>off_t</code>而不是<code>long</code>以外，<code>ftello/fseeko</code>与<code>ftell/fseek</code>相同</p>
<pre><code>  #include&lt;stdio.h&gt;
  off_t ftello(FILE *fp);
</code></pre><ul>
<li>参数：<code>fp</code>：打开的文件对象指针</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回当前文件位置指示</li>
<li>失败：返回 (off_t)-1</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
int fseeko(FILE *fp,off_t offset,int whence);
</code></pre></li>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>offset</code>：偏移量。其解释依赖于<code>whence</code></li>
<li><code>whence</code>：偏移量的解释方式：<ul>
<li><code>SEEK_SET</code>常量：表示从文件的起始位置开始</li>
<li><code>SEEK_CUR</code>常量：表示从文件的当前位置开始</li>
<li><code>SEEK_END</code>常量：表示从文件的尾端开始</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回 -1</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fgetpos/fsetpos</code>函数：由 ISO C 引入</p>
<pre><code>  #include&lt;stdio.h&gt;
  int fgetpos(FILE *restrict fp,fpos_t *restrict pos);
  int fsetpos(FILE * fp,const fpos_t * pos);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>pos</code>：存放偏移量的缓冲区</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功： 返回 0</li>
<li>失败： 返回非 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>示例:在<code>main</code>函数中调用<code>test_get_put_seek</code> 函数：</p>
<pre><code>void test_get_put_seek()
{
M_TRACE(&quot;---------  Begin test_get_put_seek()  ---------\n&quot;);
assert(prepare_file(&quot;test_char&quot;,NULL,0,S_IRWXU)==0);
assert(prepare_file(&quot;test_line&quot;,NULL,0,S_IRWXU)==0);
assert(prepare_file(&quot;test_binary&quot;,NULL,0,S_IRWXU)==0);

FILE *file_char=My_fopen(&quot;test_char&quot;,&quot;r+&quot;);
FILE *file_line=My_fopen(&quot;test_line&quot;,&quot;r+&quot;);
FILE *file_binary=My_fopen(&quot;test_binary&quot;,&quot;rb+&quot;);

if((file_char!=NULL) &amp;&amp; (file_line!=NULL) &amp;&amp; (file_binary!=NULL))
{
    printf(&quot;***** test read write char*****\n&quot;);
    _test_read_write_char(file_char);
    printf(&quot;\n\n***** test read write str*****\n&quot;);
    _test_read_write_line(file_line);
    printf(&quot;\n\n***** test read write binary*****\n&quot;);
    _test_read_write_binary(file_binary);
}

//*** 关闭文件  ***//
if(file_char!=NULL) fclose(file_char);
if(file_line!=NULL) fclose(file_line);
if(file_binary!=NULL) fclose(file_binary);

un_prepare_file(&quot;test_char&quot;);
un_prepare_file(&quot;test_line&quot;);
un_prepare_file(&quot;test_binary&quot;);
M_TRACE(&quot;---------  End test_get_put_seek()  ---------\n\n&quot;);
}
</code></pre><p><img src="../imgs/std_IO/FILE_read_write_seek.JPG" alt="FILE_read_write_seek"></p>
</li>
</ol>
<h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><ol>
<li><p>格式化输出函数：</p>
<pre><code> #include&lt;stdio.h&gt;
 int printf(const char *restrict format,...);
 int fprintf(FILE *restrict fp,const char*restrict format,...);
 int dprintf(int fd,const char *restrict format,...);
 int sprintf(char *restrict buf,const char*restrict format,...);
 int snprintf(char *restrict buf,size_t n,const char *restrict format,...);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>format,...</code>：输出的格式化字符串</p>
<p>对于<code>fprintf</code>：</p>
</li>
<li><p><code>fp</code>：打开的文件对象指针。格式化输出到该文件中</p>
<p>对于<code>dprintf</code>：</p>
</li>
<li><p><code>fd</code>：打开文件的文件描述符。格式化输出到该文件中</p>
<p>对于<code>sprintf</code>:</p>
</li>
<li><p><code>buf</code>：一个缓冲区的指针。格式化输出到该缓冲区中</p>
<p>对于<code>snprintf</code>:</p>
</li>
<li><code>buf</code>：一个缓冲区的指针。格式化输出到该缓冲区中</li>
<li><code>n</code>：缓冲区的长度。格式化输出到该缓冲区中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回输出字符数（不包含<code>null</code>字节）</li>
<li>失败：返回负数</li>
</ul>
<p><code>printf</code>将格式化输出写到标准输出；<code>fprintf</code>写到指定的流；<code>dprintf</code>写到指定的文件描述符；<code>sprintf</code>写到数组<code>buf</code>中；<code>snprintf</code>也是写到数组<code>buf</code>中，但是在该数组的尾端自动添加一个<code>null</code>字节（该字节不包含在返回值中）。    </p>
</li>
<li>通常不推荐使用<code>sprintf</code>，因为它可能引起缓冲区溢出流动</li>
<li>如果格式化输出一共 s 个字节，那么<code>snprintf</code>的数组缓冲区至少为<code>s+1</code>个字节，否则发生截断</li>
</ul>
</li>
<li><p>格式说明：<code>%[flags][fldwidth][precision][lenmodifier]convtype</code></p>
<ul>
<li>标志<code>flags</code>有：<ul>
<li><code>&#39;</code> : 撇号，将整数按照千位分组字符</li>
<li><code>-</code> ： 在字段内左对齐输出</li>
<li><code>+</code>： 总是显示带符号转换的正负号</li>
<li><code> </code>：空格。如果第一个字符不是正负号，则在其前面加一个空格</li>
<li><code>#</code>：指定另一种转换形式（如，对于十六进制格式，加 0x 前缀）</li>
<li><code>0</code>：添加前导0（而非空格） 进行填充</li>
</ul>
</li>
<li><code>fldwidth</code>：说明最小字段宽度。转换后参数字符如果小于宽度，则多余字符位置用空格填充。<ul>
<li>字段宽度是一个非负十进制数，或者是一个星号 <code>*</code></li>
</ul>
</li>
<li><code>precision</code>：说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后最大字节数。<ul>
<li>精度是一个点<code>.</code>后跟随一个可选的非负十进制数或者一个星号<code>*</code><blockquote>
<p>宽度和精度可以为<code>*</code>，此时一个整型参数指定宽度或者精度的值。该整型参数正好位于被转换的参数之前</p>
</blockquote>
</li>
</ul>
</li>
<li><code>lenmodifier</code>：说明参数长度。可以为：<ul>
<li><code>hh</code>：将相应的参数按照<code>signed char</code>或者<code>unsigned char</code>类型输出</li>
<li><code>h</code>：将相应的参数按照<code>signed short</code>或者<code>unsigned short</code>类型输出</li>
<li><code>l</code>：将相应的参数按照<code>signed long</code>或者<code>unsigned long</code>或者宽字符类型输出</li>
<li><code>ll</code>：将相应的参数按照<code>signed longlong</code>或者<code>unsigned longlong</code>类型输出</li>
<li><code>j</code>：<code>intmax_t</code>或者<code>uintmax_t</code></li>
<li><code>z</code>：<code>size_t</code></li>
<li><code>t</code>：<code>ptrdiff_t</code></li>
<li><code>L</code>：<code>long double</code></li>
</ul>
</li>
<li><code>convtype</code>：控制如何解释参数<ul>
<li><code>d</code>或者<code>i</code>：有符号十进制</li>
<li><code>o</code>：无符号八进制</li>
<li><code>u</code>：无符号十进制</li>
<li><code>x</code>或者<code>X</code>：无符号十六进制</li>
<li><code>f</code>或者<code>F</code>：双精度浮点数</li>
<li><code>e</code>或者<code>E</code>：指数格式双精度浮点数</li>
<li><code>g</code>或者<code>G</code>：根据转换后的值解释为<code>f、F、e、E</code></li>
<li><code>a</code>或者<code>A</code>：十六进制指数格式双精度浮点数</li>
<li><code>c</code>：字符（若带上长度修饰符<code>l</code>,则为宽字符）</li>
<li><code>s</code>：字符串（若带上长度修饰符<code>l</code>,则为宽字符）</li>
<li><code>p</code>：指向<code>void</code>的指针</li>
<li><code>n</code>：到目前位置，此<code>printf</code>调用输出的字符的数目将被写入到指针所指向的带符号整型中</li>
<li><code>%</code>：一个<code>%</code>字符</li>
<li><code>C</code>：宽字符，等效于<code>lc</code></li>
<li><code>S</code>：宽字符串，等效于<code>ls</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>printf</code>族的变体：将可变参数<code>(...)</code>替换成了<code>va_list arg</code>:</p>
<pre><code> #include&lt;stdarg.h&gt;
 #include&lt;stdio.h&gt;
 int vprintf(const char *restrict format,va_list arg);
 int vfprintf(FILE *restrict fp,const char*restrict format,va_list arg);
 int vdprintf(int fd,const char *restrict format,va_list arg);
 int vsprintf(char *restrict buf,const char*restrict format,va_list arg);
 int vsnprintf(char *restrict buf,size_t n,const char *restrict format,va_list arg);
</code></pre><p> 其参数与返回值与前面的<code>printf</code>族完全相同</p>
</li>
</ol>
<ol>
<li><p>格式化输入函数：</p>
<pre><code> #include&lt;stdio.h&gt;
 int scanf(const char*restrict format,...);
 int fscanf(FILE *restrict fp,const char *restrict format,...);
 int sscanf(const char *restrict buf,const char *restrict format,...);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>format,...</code>：格式化字符串</p>
<p>对于<code>fscanf</code>：</p>
</li>
<li><p><code>fp</code>：打开的文件对象指针。从流中读取输入</p>
<p>对于<code>sscanf</code>：</p>
</li>
<li><code>buf</code>：一个缓冲区指针。从该缓冲区中读取输入</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回赋值的输入项数</li>
<li>提前到达文件尾端：返回<code>EOF</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p><code>scanf</code>族用于分析输入字符串，将字符序列转换成指定类型的变量。在格式之后的各参数中包含了变量的地址，用转换结果对这些变量赋值。</p>
</li>
<li>除了转换说明和空白字符以外，格式字符串中的其他字符必须与输入匹配。如有一个字符不匹配，则停止后续处理，不再读输入的其余部分。</li>
<li>转换说明的格式为：<code>%[*][fldwidth][m][lenmodifier]convtype</code>：<ul>
<li><code>*</code>：用于抑制转换。按照转换说明的其余部分对输入进行转换，但是转换结果不存放在参数中而是抛弃</li>
<li><code>fldwidth</code>：说明最大宽度，即最大字符数</li>
<li><code>lenmodifier</code>：说明要转换结果赋值的参数大小。见前述说明</li>
<li><code>convtype</code>：类似前述说明。但是稍有区别：输入中的带符号的数值可以赋给无符号类型的变量</li>
<li><code>m</code>：用于强迫内存分配。当<code>%c,%s</code>时，如果指定了<code>m</code>，则会自动分配内存来容纳转换的字符串。同时该内存的地址会赋给指针类型的变量（即要求对应的参数必须是指针的地址）。同时要求程序员负责释放该缓冲区（通过<code>free</code>函数）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>scanf</code>族也有一类变体：将可变参数<code>(...)</code>替换成了<code>va_list arg</code>:</p>
<pre><code> #include&lt;stdarg.h&gt;
 #include&lt;stdio.h&gt;
 int vscanf(const char*restrict format,va_list arg);
 int vfscanf(FILE *restrict fp,const char *restrict format,va_list arg);
 int vsscanf(const char *restrict buf,const char *restrict format,va_list arg);
</code></pre></li>
<li><p>示例： 在 <code>main</code>函数中调用<code>test_printf_scanf</code>函数：</p>
</li>
</ol>
<pre><code>```
</code></pre><p>void test_printf_scanf()<br>{<br>    M_TRACE(“———  Begin test_printf_scanf()  ———\n”);<br>    printf(“<strong><strong> test printf  <em>*</em></strong></strong>\n”);<br>    _test_printf();<br>    printf(“\n\n<strong><strong> test snprintf  <em>*</em></strong></strong>\n”);<br>    _test_snprintf();<br>    printf(“\n\n<strong><strong> test scanf  <em>*</em></strong></strong>\n”);<br>    _test_scanf();<br>    printf(“\n\n<strong><strong> test sscanf  <em>*</em></strong></strong>\n”);<br>    _test_sscanf();<br>    M_TRACE(“———  End test_printf_scanf()  ———\n\n”);<br>}</p>
<pre><code>```    
![print_scan](../imgs/std_IO/print_scan.JPG) 
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p><code>fileno</code>函数：获取文件对象的文件描述符</p>
<pre><code> #include&lt;stdio.h&gt;
 int fileno(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象的指针</li>
</ul>
</li>
<li>返回值： 返回与该流相关联的文件描述符</li>
</ul>
</li>
<li><p><code>tmpnam/tmpfile</code>函数：创建临时文件    </p>
<pre><code> #include&lt;stdio.h&gt;
 char *tmpnam(char *ptr);
 FILE *tmpfile(void);
</code></pre><ul>
<li><code>tmpnam</code>参数：<ul>
<li><code>ptr</code>：指向存放临时文件名的缓冲区的指针<ul>
<li>若为<code>NULL</code>，则产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回<blockquote>
<p>下次再调用<code>tmpnam</code>时，会重写该静态区</p>
</blockquote>
</li>
<li>如果为非<code>NULL</code>，则认为它指向长度至少为<code>L_tmpnam</code>个字符的数组，产生的路径名存放在该缓冲区中，返回<code>ptr</code>。<code>L_tmpnam</code>常量定义在<code>&lt;stdio.h&gt;</code>头文件中</li>
</ul>
</li>
</ul>
</li>
<li><code>tmpnam</code>返回值：返回指向唯一路径名的指针</li>
<li><p><code>tmpfile</code>返回值：</p>
<ul>
<li>成功：返回文件指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p><code>tmpnam</code>函数产生一个与现有文件名不同的有效路径名字符串。每次调用它时，都产生一个不同路径名。最多调用次数是<code>TMP_MAX</code>次（定义在<code>&lt;stdio.h&gt;</code>中）</p>
<blockquote>
<p>它只创建独一无二的文件名，但是并不创建临时文件</p>
</blockquote>
<p><code>tmpfile</code>是创建一个临时二进制文件（类型<code>wb+</code>），在关闭该文件或者程序结束时将自动删除这种文件</p>
<blockquote>
<p><code>UNIX</code>对二进制文件、文本文件并不进行特殊区分</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>mkdtemp/mkstemp</code>函数：创建临时文件（由SUS 标准给出）</p>
<pre><code> #include&lt;stdlib.h&gt;
 char *mkdtemp(char *template);
 int mkstemp(char *template);
</code></pre><ul>
<li>参数：<ul>
<li><code>template</code>：一个字符串。这个字符是最末6个字符设置为<code>XXXXXX</code>的路径名。函数将这些占位符替代成不同的字符来构建一个唯一的路径名。若成功的话，这两个函数将修改<code>template</code>字符串来反映临时文件的名字<blockquote>
<p>因为函数会修改<code>template</code>,因此一定不能用常量字符串来赋值！</p>
</blockquote>
</li>
</ul>
</li>
<li><code>mkdtemp</code>返回值：<ul>
<li>成功：返回指向目录名的指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
</li>
<li><p><code>mkstemp</code>返回值：</p>
<ul>
<li>成功： 返回文件描述符</li>
<li>失败： 返回 -1</li>
</ul>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有一个唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。名字是通过<code>template</code>字符串进程构建的。</p>
</li>
<li><code>mkdtemp</code>函数创建的目录具有权限位集： <code>S_IRUSR|S_IWUSR|S_IXUSR</code>。调用进程的文件模式创建屏蔽字可以进一步限制这些权限</li>
<li><code>mkstemp</code>函数返回的文件描述符以读写方式打开。它创建的文件用访问权限位：<code>S_IRUSR|S_IWUSR</code></li>
<li><code>mkstemp</code>创建的临时文件并不会自动删除</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_tmpnam_mkdtemp</code>函数：</p>
<pre><code>void test_tmpnam_mkdtemp()
{
 M_TRACE(&quot;---------  Begin test_printf_scanf()  ---------\n&quot;);
 printf(&quot;******** test tmpnam ********\n&quot;);
 _test_tmpnam();
 printf(&quot;\n\n******** test mkdtemp ********\n&quot;);
 _test_mkdtemp();
 M_TRACE(&quot;---------  End test_printf_scanf()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/make_temp_file.JPG" alt="make_temp_file"> </p>
</li>
<li><p>内存流：一种标准IO流，虽然它通过 <code>FILE</code>指针来访问，但是并没有底层的文件 。所有的IO都是通过在缓冲区和主存之间来回传送字节来完成。</p>
<blockquote>
<p>虽然它看起来像是文件流，但是更适用于字符串操作</p>
</blockquote>
<ul>
<li><p>创建内存流：</p>
<pre><code>  #include&lt;stdio.h&gt;
  FILE *fmemopen(void *restrict buf,size_t size,const char *restrict type);
</code></pre><ul>
<li>参数：<ul>
<li><code>buf</code>：内存流缓冲区的起始地址</li>
<li><code>size</code>：内存流缓冲区的大小（字节数）<ul>
<li>若<code>buf</code>为<code>NULL</code>时，则函数负责分配<code>size</code>字节的缓冲区，并在流关闭时自动释放分配的缓冲区</li>
</ul>
</li>
<li><code>type</code>:控制如何使用流（即打开内存流的方式）：<ul>
<li><code>r</code>或者<code>rb</code>：读打开</li>
<li><code>w</code>或者<code>wb</code>：写打开</li>
<li><code>a</code>或者<code>ab</code>：追加打开；为在第一个<code>null</code>字节处写打开</li>
<li><code>r+</code>或者<code>r+b</code>或<code>rb+</code>：读写打开</li>
<li><code>w+</code>或者<code>w+b</code>或<code>wb+</code>：把文件截断为0，然后读写打开</li>
<li><code>a+</code>或者<code>a+b</code>或<code>ab+</code>：追加；为在第一个<code>null</code>字节处读写打开</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回流指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p>注意：</p>
</li>
<li>无论何时以追<code>a</code>方式打开内存流时，当前文件位置设为缓冲区中第一个<code>null</code>字节处。<ul>
<li>若缓冲区中不存在<code>null</code>字节，则当前位置设为缓冲结尾的后一个字节</li>
</ul>
</li>
<li>当内存流不是<code>a</code>方式打开时，当前位置设置为缓冲区的开始位置</li>
<li>如果<code>buf</code>是<code>null</code>，则打开流进行读或者写都没有任何意义。因为此时缓冲区是通过<code>fmemopen</code>分配的，没办法找到缓冲区的地址。</li>
<li>任何时候需要增加流缓冲区中数据流以及调用<code>fclose、fflush、fseek、fseeko、fsetpos</code>时都会在当前位置写入一个<code>null</code>字节</li>
</ul>
</li>
<li><p>创建内存流的其他两个函数：</p>
<pre><code>  #include&lt;stdio.h&gt;
  FILE *open_memstream(char **bufp,size_t *sizep);
  #include &lt;wchar.h&gt;
  FILE *open_wmemstream(wchar_t **bufp,size_t *sizep);
</code></pre><ul>
<li>参数：<ul>
<li><code>bufp</code>：指向缓冲区地址的指针（用于返回缓冲区地址）</li>
<li><code>sizep</code>:指向缓冲区大小的指针（用于返回缓冲区大小）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回流指针</li>
<li>失败：返回 <code>NULL</code></li>
</ul>
<p>这两个函数创建的流：</p>
</li>
<li>只能写打开</li>
<li>缓冲区由函数自动创建</li>
<li>关闭流后需要程序员释放缓冲区</li>
<li><p>对流添加字节会增加缓冲区大小</p>
<p>在缓冲区地址和大小使用上要遵守规则：</p>
</li>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或者<code>fflush</code>后才有效</li>
<li>这些值只有在下一次写入或者调用<code>fclose</code>之前才有效。因为缓冲区可能增长，也可能需要重新分配</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_memstream</code>函数：</p>
<pre><code>void test_memstream()
{
 M_TRACE(&quot;---------  Begin test_memstream()  ---------\n&quot;);
 char mem_buffer[16];
 FILE *fp=My_fmemopen(mem_buffer,16,&quot;r+&quot;);
 if(NULL!=fp)
 {

     char read_write_buffer[8];
     My_ftello(fp);   // 查看当前位置
     //**** 写入 ****//
     My_fputs(&quot;abcdefg\n&quot;,fp); // 每次7个字符加一个换行符
     My_fputs(&quot;0123456789&quot;,fp); // 没有换行符
     My_ftello(fp);   // 查看当前位置
     fflush(fp);
     print_char_buffer(mem_buffer,16);
     //**** 读取 ****//
     My_fseeko(fp,0,SEEK_SET); //重定位到文件头
     My_ftello(fp); // 查看当前位置
     My_fgets(read_write_buffer,8,fp); // 读取 abcdefg
     My_fgets(read_write_buffer,8,fp); // 读取 \n
     My_fgets(read_write_buffer,8,fp);// 读取 0123456，文件指针指向 null 字节
     My_fgets(read_write_buffer,8,fp);// 遇到 EOF，即 null 字节 （最后一个字节为 null 字节，因此有效字节只有15个字节）
     My_ftello(fp); // 查看当前位置，文件指针指向最后一个字节的下一个字节
     My_fgets(read_write_buffer,8,fp);// 遇到 EOF，此时读取返回 EOF，并且是 ferror 返回真，且 feof 返回真
     printf(&quot;feof=%d,ferror=%d\n&quot;,feof(fp),ferror(fp)); //ferror 返回真，且 feof 返回真

     print_char_buffer(mem_buffer,16); // 读取并不会删除 mem_buffer 中的内容
     fclose(fp);
 }
 M_TRACE(&quot;---------  End test_memstream()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/mem_FILE_stream.JPG" alt="mem_FILE_stream"> </p>
</li>
<li><p>标准IO库的缺点：效率不高。这与它需要复制的数据量有关。当使用每次一行的函数<code>fgets/fputs</code>时，通常需要复制两次数据：</p>
<ul>
<li>内核和标准IO缓冲区之间（当调用<code>read/write</code>时）</li>
<li>标准IO缓冲区和用户程序的缓冲区之间%  </li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/12/04/文件和目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/04/文件和目录/" itemprop="url">
                  文件和目录
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-04T00:00:00+08:00">
                2017-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/apue/" itemprop="url" rel="index">
                    <span itemprop="name">apue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/04/文件和目录/" class="leancloud_visitors" data-flag-title="文件和目录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="一、-stat-结构和权限相关"><a href="#一、-stat-结构和权限相关" class="headerlink" title="一、 stat 结构和权限相关"></a>一、 stat 结构和权限相关</h2><ol>
<li><p>四个<code>stat</code>函数：返回文件或者目录的信息结构：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int stat(const char * restrict pathname, struct stat*restrict buf);
 int fstat(int fd, struct stat* buf);
 int lstat(const char* restrict pathname,struct stat *restrict buf);
 int fstatat(int fd,const char*restrict pathname,struct stat*restrict buf,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件或者目录的名字</li>
<li><code>buf</code>：存放信息结构的缓冲区</li>
<li><code>fd</code>：打开的文件描述符<ul>
<li>对于<code>fstat</code>，该文件就是待查看信息的文件</li>
<li>对于<code>fstatat</code>，该文件是并不是待查看信息的文件。待查看信息的文件时已该<code>fd</code>对于的目录相对路径定位的</li>
</ul>
</li>
<li><p><code>flag</code>：控制着<code>fstatat</code>函数是否跟随一个符号链接。</p>
<p>对于<code>fstatat</code>函数：</p>
</li>
<li><p>待查看的文件名是由<code>fd</code>和<code>pathname</code>共同决定的。</p>
<ul>
<li>如果<code>pathname</code>是个绝对路径，则忽略<code>fd</code>参数</li>
<li>如果<code>pathname</code>是个相对路径路径，且 <code>fd=AT_FDCWD</code>，则在当前工作目录的路径下查找<code>pathname</code></li>
<li>如果<code>pathname</code>是个相对路径路径，且 <code>fd!=AT_FDCWD</code>，则在<code>fd</code>对应的打开目录下查找<code>pathname</code></li>
</ul>
</li>
<li><code>flag</code>：控制着<code>fstatat</code>函数是否跟随一个符号链接。当<code>!AT_SYMLINK_FOLLOW</code>标志被设置时，查看的是<code>pathname</code>（如果它是个符号链接）本身的信息；否则默认查看的是<code>pathname</code>（如果它是个符号链接）链接引用的文件的信息。    </li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>注意：</p>
</li>
<li><code>lstat</code>类似于<code>stat</code>，但是当<code>pathname</code>是个符号链接时，<code>lstat</code>查看的是该符号链接的有关信息；而<code>stat</code>是查看该符号链接引用的文件的信息。</li>
<li>在 <code>ubuntu 16.04</code>上，虽然有 <code>AT_SYMLINK_NOFOLLOW</code>这个常量，但是不支持。必须用 <code>!AT_SYMLINK_FOLLOW</code>。其常量定义为：<ul>
<li><code>AT_SYMLINK_FOLLOW</code>： 1024 (有效）</li>
<li><code>!AT_SYMLINK_FOLLOW</code>： 0(有效）</li>
<li><code>AT_SYMLINK_NOFOLLOW</code>： 256(无效）</li>
<li><code>AT_SYMLINK_FOLLOW</code>： -1025(无效）</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><code>stat</code>数据结构：其定义可能与具体操作系统相关，但是基本形式为：</p>
<pre><code> struct stat{
 mode_t             st_mode;     //文件权限和类型信息
 ino_t             st_ino;        //i-node 号
 dev_t             st_dev;        // 设备号
 dev_t             st_rdev;    // 特殊文件的设备号
 nlink_t         st_nlink;    // 硬链接数量
 uid_t             st_uid;        // owner 的用户ID
 gid_t             st_gid;        // owner 的组ID
 off_t             st_size;    //对普通文件，它是文件字节大小
 struct timespec st_atime;    // 上次访问时间
 struct timespec st_mtile;    // 上次修改时间
 struct timespec st_ctime;    // 上次文件状态改变的时间
 blksize_t         st_blksize;    // 最佳的 I/O block 大小
 blkcnt_t         st_blocks;    //分配的磁盘块数量
 }
</code></pre><p> 其中<code>timespec</code>结构与具体操作系统相关，但是至少包括下面两个字段：</p>
</li>
</ol>
<pre><code>    struct timespec{
    time_t tv_sec;    // 秒
    long tv_nsec;     //纳秒
        }
</code></pre><ol>
<li><p>UNIX 文件类型：</p>
<ul>
<li>普通文件：最常见的文件类型，这种文件包含了某种形式的数据。至于这种数据是二进制还是文本，对内核无区别。普通文件的内容解释由具体的应用程序进行。</li>
<li>目录文件：这种文件包含了其他文件的名字，以及指向这些文件有关信息的指针。<ul>
<li>只有内核可以直接写目录文件（通常用户写目录文件都要通过内核）</li>
<li>对某个目录文件具有读权限的任何一个进程都可以读取该目录的内容</li>
</ul>
</li>
<li>块特殊文件：这种类型的文件提供对设备（如磁盘）带缓冲的访问。每次访问以固定长度为单位进行。</li>
<li>字符特殊文件：这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。<blockquote>
<p>系统的所有设备，要么是字符特殊文件，要么是块特殊文件</p>
</blockquote>
</li>
<li><code>FIFO</code>：这种类型的文件用于进程间通信，有时也称为命名管道</li>
<li>套接字：这种类型的文件用于进程间的网络通信（也可用于单机上进程的非网络通信）</li>
<li><p>符号链接：这种类型的文件指向另一个文件</p>
<p>文件类型信息存放在<code>stat.st_mode</code>成员中，可以用下列的宏测试文件类型：</p>
</li>
<li><code>S_ISREG()</code>：测试是否普通文件</li>
<li><code>S_ISDIR()</code>：测试是否目录文件</li>
<li><code>S_ISCHR()</code>：测试是否字符特殊文件</li>
<li><code>S_ISBLK()</code>：测试是否块特殊文件</li>
<li><code>S_ISFIFO()</code>：测试是否<code>FIFO</code></li>
<li><code>S_ISLNK()</code>：测试是否符号链接文件</li>
<li><p><code>S_ISSOCK()</code>：测试是否套接字</p>
<p>另外 <code>POSIX.1</code> 允许将进程间通信对象说明为文件。但是下面的宏测试的不是<code>stat.st_mode</code>，而是<code>stat*</code>（<code>stat</code>指针）：</p>
</li>
<li><code>S_TYPEISMQ()</code>：测试是否消息队列</li>
<li><code>S_TYPEISSEM()</code>：测试是否信号量</li>
<li><code>S_TYPEISSHM()</code>：测试是否共享存储对象</li>
</ul>
</li>
<li><p>与一个进程有关的ID有很多:</p>
<ul>
<li>实际用户 ID 和实际组 ID： 标志我们究竟是谁。当我们登录进操作系统时，这两个值就确定了！</li>
<li>有效用户 ID、有效组ID、附属组 ID： 用于文件访问权限检查。</li>
<li><p>保存的设置用户ID、保存的设置组ID：由 <code>exec</code>函数保存</p>
<p>每个文件都有一个所有者和组所有者，分别有 <code>stat.st_uid</code>和<code>stat.st_gid</code>指定。当一个文件时可执行文件时，如果执行这个文件，那么进程的有效用户ID就是实际用户ID，有效组ID就是实际组ID，除了下面的情况：</p>
</li>
<li>当在<code>stat.st_mode</code>中设置了一个特殊标志：设置用户ID位时，则将进程的有效用户ID设置为文件所有者的用户ID</li>
<li><p>当在<code>stat.st_mode</code>中设置了一个特殊标志：设置组ID位时，则将进程的有效组ID设置为文件所有者的组ID</p>
<blockquote>
<p>任何进程都是由可执行文件被执行而得到。因此位于磁盘上的可执行文件的所属的用户ID和组ID会影响到进程的用户ID和组ID</p>
</blockquote>
<p>如果某个可执行文件所有者是<code>root</code>，且该文件的设置用户ID位已经被设置，那么无论谁执行这个可执行文件时，该可执行文件产生的进程就具有超级用户权限。</p>
<p>设置用户ID位、设置组ID位 都包含在<code>stat.st_mode</code>中，可以通过下列两个宏测试：</p>
</li>
<li><code>S_ISUID()</code>：测试是否设置了设置用户ID位</li>
<li><code>S_ISGID()</code>：测试是否设置了设置组ID位</li>
</ul>
</li>
<li><p>文件访问权限：所有文件类型（包括目录，字符特别文件等）都有访问权限。每个文件都有9个访问权限位：</p>
<ul>
<li><code>S_IRUSR</code>：用户读</li>
<li><code>S_IWUSR</code>：用户写</li>
<li><code>S_IXUSR</code>：用户执行</li>
<li><code>S_IRGRP</code>：组读</li>
<li><code>S_IWGRP</code>：组写</li>
<li><code>S_IXGRP</code>：组执行</li>
<li><code>S_IROTH</code>：其他读</li>
<li><code>S_IWOTH</code>：其他写</li>
<li><p><code>S_IXOTH</code>：其他执行</p>
<p>访问权限规则：</p>
</li>
<li><p>当用名字<code>pathname</code>打开任何一个类型的文件时，对<code>pathname</code>中包含的每一个目录，包括<code>pathname</code>可能隐含的当前工作目录都应该具有执行权限</p>
<blockquote>
<p>因此目录的执行权限位也称之为搜索位</p>
</blockquote>
</li>
<li>对一个文件的读权限决定了我们能否打开现有文件进行读操作</li>
<li>对一个文件的写权限决定了我们能否打开现有文件进行写操作</li>
<li>如果你在<code>open</code>函数中对一个文件指定了<code>O_TRUNC</code>标志，则必须对该文件具有写权限</li>
<li>为了在一个目录中常见一个新文件，必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身没有权限的限制</li>
<li><p>如果用7个<code>exec</code>函数中的任何一个执行某个文件，则必须对该文件具有执行权限，且该文件必须是个普通文件</p>
<p>进程每次打开、创建、删除一个文件时，内核就进行文件访问权限测试。这种测试如下：</p>
</li>
<li><p>若进程的有效用户ID是0（超级用户），则对该文件的任何访问行为都批准</p>
</li>
<li>若进程的有效用户ID等于文件的所有者ID（也就是进程拥有此文件）：<ul>
<li>如果该文件的用户读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的用户写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的用户执行权限开放，则内核允许进程执行该文件</li>
</ul>
</li>
<li>若进程的有效组ID或者进程的附属组ID之一等于文件的组ID：<ul>
<li>如果该文件的组读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的组写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的用户执行权限开放，则内核允许进程执行该文件</li>
</ul>
</li>
<li><p>否则：</p>
<ul>
<li>如果该文件的其他读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的其他写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的其他户执行权限开放，则内核允许进程执行该文件</li>
</ul>
<p>只要有一个权限通过，则不再进行测试。若所有权限都不通过，则不允许访问。</p>
</li>
</ul>
</li>
<li><p>对一个目录的读权限和可执行权限是不同的：</p>
<ul>
<li>目录读权限：允许读目录，从而获得在该目录中所有文件名的列表</li>
<li>目录可执行权限：允许搜索该目录，从而寻找一个特定的文件名</li>
</ul>
</li>
<li><p>当一个进程通过<code>open</code>或者<code>creat</code>创建一个新文件时：</p>
<ul>
<li>新文件的用户ID被设置为进程的有效用户ID</li>
<li>新文件的组ID可以有两个值之一：<ul>
<li>进程的有效组ID</li>
<li>文件所在目录的组ID<blockquote>
<p>具体选择哪个，由具体操作系统决定</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>stat</code>和<code>lstat</code>示例：在<code>main</code>函数中调用<code>test_stat_lstat</code>函数：</p>
</li>
</ol>
<pre><code>void test_stat_lstat()
{
    M_TRACE(&quot;---------  Begin test_stat_lstat()  ---------\n&quot;);
    Stat stat_buf;
    My_stat(&quot;/home/huaxz1986/APUE/main.c&quot;,&amp;stat_buf); // regular file
    My_stat(&quot;/home/huaxz1986/APUE/&quot;,&amp;stat_buf); // dir file
    My_stat(&quot;/dev/loop0&quot;,&amp;stat_buf); // block file
    My_stat(&quot;/dev/mem&quot;,&amp;stat_buf); // char file
    My_lstat(&quot;/dev/cdrom&quot;,&amp;stat_buf); // link file
    My_stat(&quot;/run/systemd/initctl/fifo&quot;,&amp;stat_buf); // fifo file

    int fd=My_open_with_mode(&quot;test_stat&quot;,O_WRONLY|O_CREAT,S_IRUSR); // create a new file
    close(fd);
    My_stat(&quot;test_stat&quot;,&amp;stat_buf); // regular file
    M_TRACE(&quot;---------  End test_stat_lstat()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![stat](../imgs/file_dir/stat.JPG) 
</code></pre><h2 id="二、访问测试和文件模式创建屏蔽字"><a href="#二、访问测试和文件模式创建屏蔽字" class="headerlink" title="二、访问测试和文件模式创建屏蔽字"></a>二、访问测试和文件模式创建屏蔽字</h2><ol>
<li><p>当用<code>open()</code>函数打开一个文件时，内核根据进程的有效用户ID和有效组ID为依据来执行访问权限测试。但是如果你想测试进程的实际用户ID和实际组ID是否能够通过权限测试时，可以用下列两个函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int access(const char *pathname,int mode);
 int faccess(int fd,const char*pathname,int mode,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><p><code>mode</code>：指定要测试的模式。</p>
<ul>
<li>如果要测试文件是否已存在，则<code>mode</code>设为<code>F_OK</code></li>
<li>如果要测试进程的实际用户ID和实际组ID的权限，则可以为下列常量的按位或<ul>
<li><code>R_OK</code>：测试读权限</li>
<li><code>W_OK</code>：测试写权限</li>
<li><code>X_OK</code>：测试执行权限</li>
</ul>
</li>
</ul>
<p>对于 <code>faccess</code>函数：</p>
</li>
<li><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>AT_EACCESS</code>，则访问检查使用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>出错： 返回 -1</li>
</ul>
</li>
</ul>
</li>
<li><p>文件模式创建屏蔽字：当进程创建一个新的目录或者文件时，会使用文件模式创建屏蔽字。在文件模式创建屏蔽字中为1的位，在文件<code>mode</code>中的相应位一定被关闭。设置进程的文件模式创建屏蔽字的函数为：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 mode_t umask(mode_t cmask);
</code></pre><ul>
<li>参数： <ul>
<li><code>cmask</code>：要设置的新的文件模式创建屏蔽字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：旧的文件模式创建屏蔽字</li>
<li>函数未指定失败时返回何值</li>
</ul>
<p>如果你在通过<code>creat</code>或者<code>open</code>函数指定了<code>mode</code>，那么该<code>mode</code>必须通过文件模式创建屏蔽字的屏蔽之后才是最终新创建的文件的权限模式。<code>umask</code>指定了哪个，哪个权限就被屏蔽了！</p>
<blockquote>
<p>shell 有一个<code>umask</code>命令。我们可以通过该命令来设置或者打印当前的文件模式创建屏蔽字</p>
</blockquote>
</li>
</ul>
</li>
<li><p>示例：测试 <code>umask</code>和<code>access</code>函数的用法：在<code>main</code>函数中调用<code>test_access_umask</code> 函数：</p>
</li>
</ol>
<pre><code>void test_access_umask()
{
    My_access(&quot;/no/exist&quot;,F_OK); // no exist
    My_access(&quot;/etc/shadow&quot;,W_OK);// can not write
    My_access(&quot;/home/huaxz1986/APUE&quot;,W_OK); // can write

    print_new_file_mode(&quot;test_umask1&quot;) ;// old umask
    //new umask
    My_umask(S_IRUSR|S_IRGRP|S_IROTH);
    print_new_file_mode(&quot;test_umask2&quot;) ;// new umask
}
</code></pre><p>  <img src="../imgs/file_dir/access_umask.JPG" alt="access_umask"> </p>
<p>可以看到：</p>
<ul>
<li><code>access</code>函数：对于不存在的文件名访问失败；对没有写权限的名字写访问失败</li>
<li>被创建的文件的访问权限是由文件创建屏蔽字、创建文件时指定的权限二者共同作用的</li>
</ul>
<h2 id="三、修改文件访问权限和文件所属用户"><a href="#三、修改文件访问权限和文件所属用户" class="headerlink" title="三、修改文件访问权限和文件所属用户"></a>三、修改文件访问权限和文件所属用户</h2><ol>
<li><p>修改文件的现有的访问权限：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int chmod(const char*pathname,mode_t mode);
 int fchmod(int fd,mode_t mode);
 int fchmodat(int fd,const char*pathname,mode_t mode,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><p><code>mode</code>：文件修改后的权限。</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><p><code>fd</code>：打开的文件描述符</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>!AT_SYMLINK_FOLLOW</code>，则<code>fchmodtat</code>并不跟随符号链接</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>出错： 返回 -1</li>
</ul>
<p>参数<code>mode</code>可以是下面常量的按位或：（来自头文件<code>&lt;sys/stat.h&gt;</code></p>
</li>
<li><code>S_ISUID</code>：执行时设置用户ID</li>
<li><code>S_ISGID</code>：执行时设置组ID</li>
<li><code>S_ISVTX</code>：粘着位</li>
<li><code>S_IRWXU</code>：用户读、写和执行</li>
<li><code>S_IRUSR</code>：用户读</li>
<li><code>S_IWUSR</code>：用户写</li>
<li><code>S_IXUSR</code>：用户执行</li>
<li><code>S_IRWXG</code>：组读、写和执行</li>
<li><code>S_IRGRP</code>：用户读</li>
<li><code>S_IWGRP</code>：用户写</li>
<li><code>S_IXGRP</code>：用户执行</li>
<li><code>S_IRWXO</code>：其他读、写和执行</li>
<li><code>S_IROTH</code>：用户读</li>
<li><code>S_IWOTH</code>：用户写</li>
<li><p><code>S_IXOTH</code>：用户执行</p>
<p><code>chmod</code>函数更新的只是<code>i</code>节点最近一次被修改的时间。</p>
<p><code>chmod</code>函数在下列条件下自动清除两个权限位：</p>
</li>
<li>如果我们试图设置普通文件的粘着位，而且又没有超级用户权限，则<code>mod</code>中的粘着位被自动关闭。这意味着只有超级用户才能设置普通文件的粘着位</li>
<li>新创建文件的组<code>ID</code>可能不是调用进程所属的组<code>ID</code>，它可能是父目录的组<code>ID</code></li>
</ul>
</li>
<li><p>粘着位：如果对一个目录设置了粘着位，则任何对该目录具有写权限的进程都能够在该目录中创建文件。但是：只有满足下列条件之一的用户才能删除或者重命名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户<blockquote>
<p>对于未设置粘着位的目录，则只要用户对该目录有写权限，那么就有修改和重命名该目录下其他文件的能力</p>
</blockquote>
</li>
</ul>
</li>
<li><p>修改用户的ID和组ID：</p>
<pre><code> #include&lt;unistd.h&gt;
 int chown(const char *pathname,uid_t owner,gid_t group);
 int fchown(int fd,uid_t owner,gid_t group);
 int fchownat(int fd,const char *pathname,uid_t owner,gid_t group,int flag);
 int lchown(const char *pathname,uid_t owner,gid_t group);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><code>owner</code>：文件修改后的用户ID</li>
<li><p><code>group</code>：文件修改后的组ID</p>
<p>对于<code>fchown</code>函数：</p>
</li>
<li><p><code>fd</code>：打开的文件描述符，要修改的就是这个文件</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><p><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></p>
</li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>!AT_SYMLINK_FOLLOW</code>，则<code>fchmodtat</code>并不跟随符号链接，修改的是符号链接本身而不是符号链接指向的文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>出错： 返回 -1</li>
</ul>
<p>有两点注意：</p>
</li>
<li><code>lchown</code>函数更改的是符号链接本身，而<code>chown</code>遇到符号链接时更改的是符号链接指向的文件</li>
<li>如果这些函数由非超级用户进程调用，则成功返回时，该文件的设置用户ID和设置组ID位都被清除</li>
</ul>
</li>
<li><p>示例：在 <code>main</code> 函数中调用<code>test_chmod_chown</code> 函数：</p>
</li>
</ol>
<pre><code>void test_chmod_chown()
{
    const char *file_name=&quot;test&quot;;
    Stat buf;

    My_stat(file_name,&amp;buf);
    My_chmod(file_name,S_IRWXU);
    My_chown(file_name,1,1);
}
</code></pre><pre><code>  ![chmod_chown](../imgs/file_dir/chmod_chown.JPG) 

可以看到：
- 修改文件所属的用户和组，需要超级用户权限。普通用户无法修改，即使该用户就是该文件的所有者也不行
</code></pre><h2 id="四、修改文件长度"><a href="#四、修改文件长度" class="headerlink" title="四、修改文件长度"></a>四、修改文件长度</h2><ol>
<li><p>文件长度：<code>stat.st_size</code>字段存放的是以字节为单位的文件的长度。此字段只对普通文件、目录文件、符号链接才有意义：</p>
<ul>
<li>对普通文件：其长度就是文件的大小。长度为0表示该文件为空</li>
<li>对目录文件：其长度通常是个整数（如16或者512）的整数倍</li>
<li><p>对符号链接：其长度是符号链接本身存放的某个文件名的实际字节数（它并不包含字符串的<code>null</code>字节，因为这些字符是存放在文件中，而不是存放在内存中的字符串）</p>
<p>另外<code>stat.st_blksize</code>存放的是对于文件 I/O 较合适的块长度；<code>stat.st_blocks</code>存放的是所分配的块的数量（一个块512字节）。注意：</p>
</li>
<li>对于普通文件，可能包含空洞。空洞是由于设置的文件偏移量超过了文件末尾，然后写入了某些数据造成的。对于空洞文件：<ul>
<li>空洞文件的存储需要的磁盘块数量可能远小于文件大小。文件大小是文件末尾到文件头的字节数</li>
<li>读取空洞文件的空洞时，对于没有写过的字节位置<code>read</code>返回的是字节0</li>
</ul>
</li>
</ul>
</li>
<li><p>截断文件：通常可以用带<code>O_TRUNC</code>选项的<code>open()</code>函数来清空一个文件（截断到0）。但是如果希望截断文件使得文件大小为指定字节数，则可以用下列的函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int truncate(const char*pathname,off_t length);
 int ftruncate(int fd,off_t length);
</code></pre><ul>
<li>参数：<ul>
<li><code>pathname</code>：文件路径名</li>
<li><code>length</code>：文件修改后大小（字节数）</li>
<li><code>fd</code>：打开的文件描述符，要修改的就是这个文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>出错： 返回 -1</li>
</ul>
<p>有两点注意：</p>
</li>
<li>若<code>length</code>小于文件的原大小，则修改文件大小之后，文件新的尾端之后的位置不再可以访问</li>
<li>若<code>length</code>大于文件的原大小，则修改文件大小之后，会形成空洞。即从文件原大小新的尾端形成了空洞</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_truncate_size</code>函数：</p>
</li>
</ol>
<pre><code>void test_truncate_size()
{
    M_TRACE(&quot;---------  Begin test_truncate_size()  ---------\n&quot;);
    char buffer[100];
    int len;
    int fd=My_open_with_mode(&quot;test&quot;,O_CREAT|O_TRUNC|O_RDWR,S_IRWXU);
    My_write(fd,&quot;abcdefg&quot;,8);
    print_file_size(&quot;test&quot;);  // 打印文件大小
    //****  扩张文件 *******//
    My_truncate(&quot;test&quot;,20);  // 扩张文件
    My_lseek(fd,0,SEEK_SET);  // 读取之前先调整文件读取位置
    len=My_read(fd,buffer,20);
    printf(&quot;Read:&quot;);
    for (int i=0;i&lt;len;i++)  // 打印读取内容
        printf(&quot;\t0x%x,&quot;,buffer[i]);
    printf(&quot;\n&quot;);
    //****  截断文件 *******//
    My_truncate(&quot;test&quot;,5);   // 截断文件
    My_lseek(fd,0,SEEK_SET);  // 读取之前先调整文件读取位置
    len=My_read(fd,buffer,5);
    printf(&quot;Read:&quot;);
    for (int i=0;i&lt;len;i++)
        printf(&quot;\t0x%x,&quot;,buffer[i]);
    printf(&quot;\n&quot;);
    close(fd);
    M_TRACE(&quot;---------  End test_truncate_size()  ---------\n&quot;);
}
</code></pre><pre><code>  ![truncate](../imgs/file_dir/truncate.JPG) 

可以看到：
- 对于文件空洞，它不占用任何磁盘空间；空洞部分读出的内容全为0
- 对于非常小的文件，比如这里的 8 字节文字，磁盘分配了 8个块（4kb）。
</code></pre><h2 id="五、UNIX文件系统、硬链接、软链接、删除、重命名"><a href="#五、UNIX文件系统、硬链接、软链接、删除、重命名" class="headerlink" title="五、UNIX文件系统、硬链接、软链接、删除、重命名"></a>五、UNIX文件系统、硬链接、软链接、删除、重命名</h2><ol>
<li><p>UNIX文件系统简介(传统的基于BSD的UNIX文件系统，称作<code>UFS</code>）：</p>
<ul>
<li>一个磁盘可以划分成一个或者多个分区，每个分区可以包含一个文件系统。每个文件系统包含一些柱面组。每个柱面组包括：<ul>
<li>一个 i 节点图：用于指示哪些 i 节点已经被使用，哪些未被使用</li>
<li>一个 块位图：用于指示哪些数据块已经被使用，哪些为被使用</li>
<li>一个 i 节点组。它包含的是许多 i  节点。</li>
<li>一个数据区：存放具体的数据块和目录块</li>
</ul>
</li>
<li>数据区包含两种类型的块：<ul>
<li>目录块：它的内容是 <code>&lt;i 节点编号&gt;|&lt;文件名&gt;</code> 这种格式的记录的列表</li>
<li>数据块：它的内容就是具体文件的数据        </li>
</ul>
</li>
<li>i 节点是固定长度的记录项，它包含有关文件的大部分信息<ul>
<li>每个 i 节点都有一个链接计数，其值是指向 i 节点的目录的项数(这种链接类型称之为硬链接)。只有当该链接计数减少为0时，才可以删除该链接文件（也就是释放该文件占用的数据块）。<ul>
<li>在<code>stat</code>结构中，链接计数包含在<code>st_nlink</code>成员中（POSIX常量：<code>LINK_MAX</code>指定了一个文件链接数的最大值）         </li>
</ul>
</li>
<li>每个 i 节点包含了文件有关的所有信息：文件类型、文件权限访问位、文件长度和指向文件数据块的指针<ul>
<li><code>stat</code>结构中的大多数信息来自于 i  结点。只有两项重要数据存放在目录项中：文件名、i节点编号</li>
</ul>
</li>
<li>目录项中的 i 节点编号只能指向同一个文件系统中的相应的 i 节点。<blockquote>
<p>因此硬链接不能跨文件系统</p>
</blockquote>
</li>
<li>当在不更换文件系统的情况下重命名一个文件时，该文件的实际内容并未移动。只需要构造一个指向现有 i 节点的新目录项，并删除来的目录项。此时该 i节点的链接计数不会改变<blockquote>
<p>这就是 <code>mv</code>命令的操作方式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与硬链接对应的概念是软链接。软链接也称作符号链接，它是一种特殊的文件。该文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字。同时该文件的 i 节点指示了该文件类型是 <code>S_IFLNK</code>，于是系统知道了这个文件是个符号链接。</p>
<ul>
<li>硬链接直接指向文件的<code>i</code>节点</li>
<li><p>软链接是对一个文件的间接指针</p>
<p>引入符号链接的原因是为了避开硬链接的一些限制：</p>
</li>
<li>硬链接通常要求链接和文件位于同一个文件系统中</li>
<li><p>只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）</p>
<p>对于符号链接以及它指向何种类型的文件并没有什么限制。任何用户都可以创建指向目录的符号链接。但是使用符号链接有可能在文件系统中引入循环</p>
<p>对于处理文件和目录的函数，如果传递的是一个符号链接的文件名，则应该注意：函数是否跟随符号链接，即函数是处理符号链接指向的文件，还是处理符号链接本身。</p>
</li>
<li><p>跟随符号链接（即处理符号链接指向的文件）的函数有：<code>access</code>、<code>chdir</code>、<code>chmod</code>、<code>chown</code>、<br><code>creat</code>、<code>exec</code>、<code>link</code>、<code>open</code>、<code>opendir</code>、<code>pathconf</code>、<code>stat</code>、<code>truncate</code></p>
</li>
<li>不跟随符号链接（即处理符号链接文件本身）的函数有：<code>lchown</code>、<code>lstat</code>、<code>readlink</code>、<code>remove</code>、<code>rename</code>、<code>unlink</code><ul>
<li>一个例外的情况：如果用<code>O_CREAT</code>和<code>O_EXCL</code>选项调用<code>open</code>，此时若参数是个符号链接的文件名，则<code>open</code>出错返回（并不考虑符号链接指向的文件是否存在），同时将<code>errno</code>设为<code>EEXIST</code></li>
</ul>
</li>
</ul>
</li>
<li><p>任何一个目录 <code>dirxxx</code> 的硬链接至少为2：</p>
<ul>
<li>该目录的内容中有一条名为的<code>.</code>记录，该记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点</li>
<li>该目录的父目录的内容中有一条记录，记录的名字<code>dirxxx</code>，记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点</li>
<li>若该目录有子目录。<code>dirxxx</code> 的任何子目录的内容有一条名为<code>..</code>的记录，该记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点<blockquote>
<p>因此父目录中的每个子目录都使得父目录的链接计数加 1</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>link/linkat</code>函数：创建一个指向现有文件的硬链接</p>
<pre><code> #include&lt;unistd.h&gt;
 int link(const char *existingpath,const char *newpath);
 int linkat(int efd,const char*existingpath,int nfd,const char *newpath,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>existingpath</code>：现有的文件的文件名（新创建的硬链接指向它）</li>
<li><p><code>newpath</code>：新创建的目录项</p>
<ul>
<li>如果<code>newpath</code>已存在，则返回出错</li>
<li>只创建<code>newpath</code>中的最后一个分量，路径中的其他部分应当已经存在。<blockquote>
<p>假设 <code>newpath</code>为：<code>/home/aaa/b/c.txt</code>，则要求 <code>/home/aaa/b</code>已经存在，只创建<code>c.txt</code></p>
</blockquote>
</li>
</ul>
<p>对于<code>linkat</code>函数：</p>
</li>
<li>现有的文件名是通过<code>efd</code>和<code>existingpath</code>指定。<ul>
<li>若<code>existingpath</code>是绝对路径，则忽略<code>efd</code></li>
<li>若 <code>existingpath</code>是相对路径，则：<ul>
<li>若 <code>efd=AT_FDCWD</code>，则<code>existingpath</code>是相对于当前工作目录来计算</li>
<li>若 <code>efd</code>是一个打开的目录文件的文件描述符，则<code>existingpath</code>是相对于<code>efd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li>新建的文件名是通过<code>nfd</code>和<code>newpath</code>指定。<ul>
<li>若<code>newpath</code>是绝对路径，则忽略<code>nfd</code></li>
<li>若 <code>newpath</code>是相对路径，则：<ul>
<li>若 <code>nfd=AT_FDCWD</code>，则<code>newpath</code>是相对于当前工作目录来计算</li>
<li>若 <code>nfd</code>是一个打开的目录文件的文件描述符，则<code>newpath</code>是相对于<code>nfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：当现有文件是符号链接时的行为：<ul>
<li><code>flag=AT_SYMLINK_FOLLOW</code>：创建符号链接指向的文件的硬链接（跟随行为）</li>
<li><code>flag=!AT_SYMLINK_FOLLOW</code>:创建符号链接本身的硬链接（默认行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>这两个函数创建新目录项并对链接计数加1。创建新目录项和增加链接计数是一个原子操作。</p>
<p>另外，大多数操作系统中，只有超级用户才能创建指向一个目录的硬链接，因为这样做很有可能在文件系统中形成循环。</p>
</li>
</ul>
</li>
<li><p><code>unlink</code>函数：删除一个现有的目录项</p>
<pre><code> #include&lt;unistd.h&gt;
 int unlink(const char*pathname);
 int unlinkat(int fd,const char*pathname,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>pathname</code>：现有的、待删除的目录项的完整路径名。</p>
<p>对于<code>unlinkat</code>函数：</p>
</li>
<li>现有的文件名是通过<code>fd</code>和<code>pathname</code>指定。<ul>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：<ul>
<li><code>flag=AT_REMOVEDIR</code>：可以类似于<code>rmdir</code>一样的删除目录</li>
<li><code>flag=!AT_REMOVEDIR</code>:与<code>unlink</code>执行同样的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果还对该目录设置了粘着位，则对该目录必须具有写权限以及下列三个条件之一：</p>
</li>
<li>拥有该文件</li>
<li>拥有该目录</li>
<li><p>具有超级用户权限</p>
<p>这两个函数删除目录项并对链接计数减1。创建新目录和增加链接计数是一个原子操作。</p>
</li>
<li>如果该文件的硬链接数不为0， 则还可以通过其他链接访问该文件的内容</li>
<li>如果该文件的硬链接数为0，而没有进程打开该文件，则该文件的内容才有被删除</li>
<li>如果该文件的硬链接数为0，但是有进程打开了该文件，则该文件的内容不能被删除。当进程关闭文件时，内核会检查打开该文件的进程个数；当这个数量为0，内核再去检查其链接计数。如果链接计数也是0，则就删除该文件的内容。<blockquote>
<p>这个特性常用于创建临时文件，先<code>open,create</code>一个文件，然后立即调用<code>unlink</code>。这样即使程序崩溃，它所创建的临时文件也不会遗留下来</p>
</blockquote>
</li>
<li><p>如果删除目录项出错，则不对该文件做任何更改</p>
<p>如果<code>pathname</code>是个符号链接，则<code>unlink</code>删除该符号链接，而不会删除由该符号链接所引用的文件。    </p>
<blockquote>
<p>如果仅仅给出符号链接的文件名，没有一个函数可以删除由该符号链接所引用的文件</p>
</blockquote>
<p>如果文件系统支持，超级用户可以调用<code>unlink</code>，其参数<code>pathname</code>指定一个目录</p>
<blockquote>
<p>通常推荐用<code>rmdir</code>函数，其语义更加清晰</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>link/unlink</code>实例：在<code>main</code>函数中调用<code>test_link_unlink</code>函数</p>
<pre><code>void test_link_unlink()
{
 M_TRACE(&quot;---------  Begin test_link_unlink()  ---------\n&quot;);
 assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0);
 un_prepare_file(&quot;test1&quot;);

 print_file_link_num(&quot;test&quot;);
 My_link(&quot;test&quot;,&quot;test1&quot;);
 My_unlink(&quot;test1&quot;);
 print_file_link_num(&quot;test&quot;);
 My_unlink(&quot;test1&quot;);
 My_unlink(&quot;test&quot;);
 print_file_link_num(&quot;test&quot;);

 un_prepare_file(&quot;test&quot;);
 un_prepare_file(&quot;test1&quot;);
 M_TRACE(&quot;---------  End test_link_unlink()  ---------\n\n&quot;);
}
</code></pre><p>   <img src="../imgs/file_dir/link_unlink.JPG" alt="link_unlink"> </p>
<p> 可以看到：</p>
<ul>
<li><code>test</code>和<code>new_test</code>这两个文件共享一个 i 结点。因此该节点的 硬链接数为2</li>
<li>一旦删除 <code>new_test</code>，则对<code>new_test</code>执行 <code>fstatat</code>失败（因为已经被<code>unlink</code>）。同时<code>test</code>的硬链接数为1</li>
<li>一旦<code>test</code>也被删除，则 <code>i</code>节点被释放。执行<code>unlink</code>失败。</li>
</ul>
</li>
<li><p><code>remove</code>函数：解除对一个目录或者文件的链接。</p>
<pre><code> #include&lt;stdio.h&gt;
 int remove(const char *pathname);
</code></pre><ul>
<li>参数<ul>
<li><code>pathname</code>：文件名或者目录名</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>失败：返回 -1</li>
</ul>
<p>对于文件，<code>remove</code>功能与<code>unlink</code>相同；对于目录，<code>remove</code>功能与<code>rmdir</code>相同</p>
</li>
</ul>
</li>
<li><p><code>rename/renameat</code>函数：重命名文件或目录</p>
<pre><code> #inluce&lt;stdio.h&gt;
 int rename(const char*oldname,const char *newname);
 int renameat(int oldfd,const char*oldname,int newfd,const char* newname);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>oldname</code>：现有的文件名或者目录名</li>
<li><p><code>newname</code>：重命名的名字</p>
<ul>
<li>如果<code>oldname</code>是个文件名，则为该文件或者符号链接重命名。<ul>
<li>此时若<code>newname</code>已存在：若<code>newname</code>是个目录则报错；若<code>newname</code>不是个目录：则先将<code>newname</code>目录项删除，然后将<code>oldname</code>重命名为<code>newname</code></li>
<li>此时若<code>newname</code>不存在：则直接将<code>oldname</code>重命名为<code>newname</code>    </li>
</ul>
</li>
<li>如果<code>oldname</code>是个目录名，则为该目录重命名。<ul>
<li>此时若<code>newname</code>已存在：若<code>newname</code>是个目录且该目录是个空目录，则先将它删除，然后<code>oldname</code>重命名为<code>newname</code>；若<code>newname</code>是个目录且该目录不是个空目录，则报错；若<code>newname</code>不是个目录，则报错</li>
<li>此时若<code>newname</code>不存在：则直接将<code>oldname</code>重命名为<code>newname</code><blockquote>
<p><code>oldname</code> 不能是 <code>newname</code> 的前缀。因为重命名时，需要删除<code>oldname</code></p>
</blockquote>
</li>
</ul>
</li>
<li>如果<code>oldname</code>或者<code>newname</code>引用的是符号链接，则处理的是符号链接本身，而不是它引用的文件</li>
<li>不能对<code>.</code>和<code>..</code>重命名。即<code>.</code>和<code>..</code>不能出现在<code>oldname</code>和<code>newname</code>的最后部分</li>
<li>若<code>newname</code>和<code>oldname</code>引用同一个文件，则函数不作任何更改而成功返回</li>
</ul>
<p>对于<code>renameat</code>函数：</p>
</li>
<li>现有的文件名或目录名是通过<code>oldfd</code>和<code>oldname</code>指定。<ul>
<li>若<code>oldname</code>是绝对路径，则忽略<code>oldfd</code></li>
<li>若 <code>oldname</code>是相对路径，则：<ul>
<li>若 <code>oldfd=AT_FDCWD</code>，则<code>oldname</code>是相对于当前工作目录来计算</li>
<li>若 <code>oldfd</code>是一个打开的目录文件的文件描述符，则<code>oldname</code>是相对于<code>oldfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li>重命名的文件名或目录名是通过<code>newfd</code>和<code>newname</code>指定。<ul>
<li>若<code>newname</code>是绝对路径，则忽略<code>newfd</code></li>
<li>若 <code>newname</code>是相对路径，则：<ul>
<li>若 <code>newfd=AT_FDCWD</code>，则<code>newname</code>是相对于当前工作目录来计算</li>
<li>若 <code>newfd</code>是一个打开的目录文件的文件描述符，则<code>newname</code>是相对于<code>newfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：当现有文件是符号链接时的行为：<ul>
<li><code>flag=AT_SYMLINK_FOLLOW</code>：创建符号链接指向的文件的硬链接（跟随行为）</li>
<li><code>flag=!AT_SYMLINK_FOLLOW</code>:创建符号链接本身的硬链接（默认行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>对于包含<code>oldname</code>以及<code>newname</code>的目录，调用进程必须具有写和执行的权限，因为将同时更改这两个目录。</p>
</li>
</ul>
</li>
<li><p><code>symlink/symlinkat</code>函数：创建一个符号链接</p>
<pre><code> #include&lt;unistd.h&gt;
 int symlink(const char*actualpath,const char *sympath);
 int symlinkat(const char*actualpath,int fd,const char*sympath);
</code></pre><ul>
<li>参数：<ul>
<li><code>actualpath</code>：符号链接要指向的文件或者目录（可能尚不存在）</li>
<li><code>sympath</code>：符号链接的名字<blockquote>
<p>二者不要求位于同一个文件系统中</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>    对于`symlinkat`函数：
    - 符号链接的名字是通过`fd`和`sympath`指定。
        - 若`sympath`是绝对路径，则忽略`fd`
        - 若 `sympath`是相对路径，则：
            - 若 `fd=AT_FDCWD`，则`sympath`是相对于当前工作目录来计算
            - 若 `fd`是一个打开的目录文件的文件描述符，则`sympath`是相对于`fd`对应的目录文件

- 返回值：
    - 成功： 返回 0
    - 失败： 返回 -1
</code></pre><ol>
<li><p><code>readlink/readlinkat</code>函数：打开符号链接本身</p>
<blockquote>
<p><code>open</code>函数是跟随链接的，即打开符号链接指向的文件</p>
</blockquote>
<pre><code>#include&lt;unistd.h&gt;
ssize_t readlink(const char *restrict pathname,char *restrict buf,size_t bufsize);
ssize_t readlinkat(int fd, const char* restrict pathname,char *restrict buf,
    size_t bufsize);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：符号链接的名字</li>
<li><code>buf</code>：存放符号链接内容的缓冲区</li>
<li><p><code>bufsize</code>：期望读入缓冲区的字节数</p>
<p>对于<code>readlinkat</code>函数：</p>
</li>
<li><p>符号链接的名字是通过<code>fd</code>和<code>pathname</code>指定。</p>
<ul>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回实际上读取的字节数</li>
<li>失败： 返回 -1</li>
</ul>
</li>
</ul>
<p><code>readlink</code>和<code>readlinkat</code>函数组合了<code>open、read、close</code>函数的所有操作。</p>
<p>注意：读入<code>buf</code>中的符号链接的内容，并不是以<code>null</code>字节终止。</p>
<blockquote>
<p>以<code>null</code>字节终止的是内存中的字符串这种数据结构。而符号链接文件的内容是简单的字符序列，并不是字符串。</p>
</blockquote>
</li>
<li><p>符号链接示例：在<code>main</code>函数中调用<code>test_symlink_readlink</code>函数：</p>
<p>```<br>void test_symlink_readlink()<br>{<br>M_TRACE(“———  Begin test_symlink_readlink()  ———\n”);<br>assert(prepare_file(“test”,”abcdefg0123456”,14,S_IRWXU)==0); // 准备 test 文件<br>print_file_type(“test”); // 查看 test 文件类型</p>
<p>My_symlink(“test”,”test_symlink”); // 创建软连接 test_symlink 到 test<br>print_file_type(“test_symlink”); // 查看 test_symlink 文件类型<br>print_link_file(“test_symlink”); // 由于open 是链接跟随，所以这里打印 test 的内容</p>
<p>char buffer[128];<br>My_readlink(“test_symlink”,buffer,128);</p>
<p>un_prepare_file(“test”); // 删除 test 文件<br>un_prepare_file(“test_symlink”); // 删除 test_symlink 文件<br>M_TRACE(“———  End test_symlink_readlink()  ———\n\n”);<br>}</p>
</li>
</ol>
<pre><code>```

![symlink](../imgs/file_dir/symlink.JPG)  

可以看到：
- 符号链接文件的内容就是它链接到的那个文件的绝对路径名，其中路径名字符序列不包含 `null`字节
- 在 `ubuntu 16.04`中，经多次测试，符号链接文件和普通文件的 `st_mode`完全相同。
- `open`一个链接文件，然后`read`时发现读文件出错，原因是文件描述符有误（实际上打开文件时返回的文件描述符没问题）
</code></pre><h2 id="六、修改文件的时间"><a href="#六、修改文件的时间" class="headerlink" title="六、修改文件的时间"></a>六、修改文件的时间</h2><ol>
<li><p>文件的时间：在<code>stat</code>结构中存放着文件的三个时间：</p>
<ul>
<li><code>st_atim</code>：文件数据的最后访问时间</li>
<li><code>st_mtim</code>：文件数据的最后修改时间</li>
<li><p><code>st_ctim</code>： i 节点状态的最后更改时间</p>
<p>关于这三个时间：</p>
</li>
<li>有很多操作，比如修改文件权限，修改文件的所有者等操作，他们只修改 i 节点状态（只影响<code>st_ctim</code>），但是并不修改文件数据，也并不访问文件数据</li>
<li>系统并不维护对 <code>i</code> 节点的最后访问时间。因此对于 <code>access</code>函数和 <code>stat</code>函数，他们并不修改这三个时间中的任何一个</li>
<li>创建一个文件不仅影响了文件本身的这三个时间，也会影响该文件目录的这三个时间</li>
</ul>
</li>
<li><p><code>futimens/utimensat/utimes</code>函数：修改文件的访问和修改时间</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int futimens(int fd,const struct timespec times[2]);
 int utimensat(int fd,const char*path,const struct timespec times[2],int flag);
 #include&lt;sys/time.h&gt;
 int utimes(const char*pathname,const struct timeval times[2]);
</code></pre><ul>
<li><p>参数：</p>
<p>  对于  <code>futimens</code>和 <code>utimensat</code>函数：</p>
<ul>
<li><p><code>times</code>：指向待修改文件的指定的文件数据访问和文件数据修改时间的指针。</p>
<blockquote>
<p>对于C语言，参数中的数组自动转换为指向数组的指针</p>
</blockquote>
<ul>
<li>这两个时间是日历时间，是自 1970:01:01–00:00:00 以来经历的秒数。不足秒的部分用纳秒表示</li>
<li>数组的第一个元素指定 <code>st_atim</code>；数组的第二个元素指定 <code>st_ctim</code></li>
<li><code>times</code>可以按照下列四种方式之一指定：<ul>
<li><code>times</code>为空指针： 则将文件的数据访问时间和文件数据修改时间设置为当前时间<blockquote>
<p> 此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程</p>
</blockquote>
</li>
<li><code>times</code>参数是指向<code>timespec</code>数组的指针：<ul>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为 <code>UTIME_NOW</code>，则相应的时间戳就设置为当前时间，忽略相应的<code>tv_sec</code>字段<blockquote>
<p>此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程</p>
</blockquote>
</li>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为 <code>UTIME_OMIT</code>，则相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段<blockquote>
<p>若两个时间戳都忽略，则不需要任何权限限制</p>
</blockquote>
</li>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为不是上面的两种之一，则相应的时间戳就设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段<blockquote>
<p>此时要求进程的有效用户ID等于该文件所有者的ID；或者进程是个超级用户进程（对文件只有写权限是不够的）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于 <code>utimes</code>函数：</p>
</li>
<li><code>pathname</code>：文件的路径名</li>
<li><p><code>times</code>：指向<code>timeval</code>数组的指针。 <code>timeval</code>结构用秒和微秒表示。</p>
<pre><code>  struct timeval{
      time_t tv_sec;//秒
      long tv_usec; //微秒
  };
</code></pre><p>对于 <code>futimens</code>函数：</p>
</li>
<li><p><code>fd</code>：待修改文件的打开的文件描述符</p>
<p>对于 <code>utimensat</code>函数：</p>
</li>
<li>待打开文件的名字是通过<code>fd</code>和<code>path</code>指定。<ul>
<li>若<code>path</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>path</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>path</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>path</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：若待修改的文件是符号链接<ul>
<li>如果为<code>!AT_SYMLINK_FOLLOW</code>，则符号链接本身的时间就会被修改</li>
<li>默认情况下，修改的是符号链接指向的文件的时间（跟随行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>我们不能对<code>st_ctim</code>（i节点最后被修改时间）指定一个值。这个时间是被自动更新的。</p>
</li>
</ul>
</li>
<li><p>示例：在 <code>main</code>函数中调用<code>test_utimes</code>函数： </p>
</li>
</ol>
<pre><code>void test_utimes()
{
    M_TRACE(&quot;---------  Begin test_utimes()  ---------\n&quot;);
    assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0); // 准备 test 文件
    print_file_time(&quot;test&quot;);
    sleep(2);
    My_access(&quot;test&quot;,F_OK); // 访问文件，但不修改文件
    print_file_time(&quot;test&quot;);
    sleep(2);
    My_chmod(&quot;test&quot;,S_IRUSR|S_IWUSR);//  修改文件状态
    print_file_time(&quot;test&quot;);

    struct timeval times[2];
    times[0].tv_usec=10;
    times[1].tv_sec=10;
    times[1].tv_usec=10;
    My_utimes(&quot;test&quot;,times);

    un_prepare_file(&quot;test&quot;); // 删除 test 文件
    M_TRACE(&quot;---------  End test_utimes()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![utimes](../imgs/file_dir/utimes.JPG)     
可以看到：
- `st_ctim`是由系统自动维护的，程序员无法手动指定
</code></pre><h2 id="七、目录操作"><a href="#七、目录操作" class="headerlink" title="七、目录操作"></a>七、目录操作</h2><ol>
<li><p><code>mkdir/mkdirat</code>函数创建一个空目录：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int mkdir(const char*pathname,mode_t mode);
 int mkdirat(int fd,const char *pathname,mode_t mode);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>:被创建目录的名字</li>
<li><p><code>mode</code>:被创建目录的权限</p>
<p>对于 <code>mkdirat</code>，被创建目录的名字是由<code>fd</code>和<code>pathname</code>共同决定的。</p>
</li>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回 -1</li>
</ul>
<p>注意：</p>
</li>
<li>他们创建的目录是空目录。</li>
<li>对于目录，通常至少要设置一个执行权限位，以允许访问该目录中的文件名</li>
</ul>
</li>
<li><p><code>rmdir</code>函数：删除一个空目录</p>
<pre><code> #include&lt;unistd.h&gt;
 int rmdir(const char *pathname);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：待删除的空目录的名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回 -1</li>
</ul>
<p>如果调用此函数使得目录的链接计数为0时：    </p>
</li>
<li>如果此时没有其他进程打开该目录，则释放由此目录占用的空间。</li>
<li>如果此时有一个或者多个进程打开此目录，则在此函数返回时删除最后一个链接以及 <code>.</code>和<code>..</code>项，直到最后一个打开该目录的进程关闭该目录时此目录才真正被释放。<ul>
<li>此时，在此目录中不能再创建新文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>读、写目录：对于某个目录具有访问权限的任何用户都可以读该目录。但是为了防止文件系统产生混乱，只有内核才能写目录。</p>
<blockquote>
<p>一个目录的写权限和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不能写目录本身</p>
</blockquote>
<pre><code> #include&lt;dirent.h&gt;
 DIR *opendir(const char *pathname);
 DIR *fdopendir(int fd);
 struct dirent *readdir(DIR *dp);
 void rewinddir(DIR *dp);
 int closedir(DIR *dp);
 long telldir(DIR *dp);
 void seekdir(DIR *dp,long loc);
</code></pre><p> 各个函数：</p>
<ul>
<li><code>opendir</code>：打开目录。<ul>
<li>参数：<code>pathname</code>：目录的名字</li>
<li>返回值：成功返回目录指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>fdopendir</code>：打开目录。<ul>
<li>参数：<code>fd</code>：目录文件的文件描述符</li>
<li>返回值：成功返回目录指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>readdir</code>：读取目录<ul>
<li>参数： <code>dp</code>：目录指针</li>
<li>返回值： 成功则返回目录项的指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>rewinddir</code>:将目录的文件偏移量清零（这样下次读取就是从头开始）<ul>
<li>参数：<code>dp</code>：目录指针</li>
</ul>
</li>
<li><code>closedir</code>：关闭目录。<ul>
<li>参数：<code>dp</code>：目录指针</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>telldir</code>：返回目录的文件偏移量<ul>
<li>参数：<code>dp</code>：目录指针</li>
<li>返回值：成功返回目录的文件偏移量 ；失败返回 -1</li>
</ul>
</li>
<li><p><code>seekdir</code>：设置目录的当前位置</p>
<ul>
<li>参数：<code>dp</code>：目录指针；<code>loc</code>：要设定的文件偏移量</li>
</ul>
<p>对于 <code>DIR</code>结构，它是一个内部结构。起作用类似于 <code>FILE</code>结构。<br>对于<code>dirent</code>结构，它是定义在<code>&lt;dirent.h&gt;</code>头文件中。其与具体操作系统相关。但是它至少定义了两个成员：</p>
<pre><code>struct dirent{
ino_t d_ino; // i 节点编号
char d_name[];// 以 null 结尾的文件名字符串
}
</code></pre><blockquote>
<p><code>d_name</code>项的大小并没有指定，但必须保证它能包含至少 <code>NAME_MAX</code>个字节（不包含终止<code>null</code>字节）</p>
</blockquote>
<p>目录中各目录项的顺序与操作系统有关。它们通常不按照字母顺序排列</p>
</li>
</ul>
</li>
<li><p>当前工作目录：每个进程都有一个当前工作目录。此目录是搜索所有相对路径名的起点。</p>
<blockquote>
<p>当前工作目录是本进程的一个属性</p>
</blockquote>
<p> 与当前工作目录相关的有三个函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int chdir(const char *pathname);
 int fchdir(int fd);
 char *getcwd(char *buf,size_t size);
</code></pre><p> 各个函数：</p>
<ul>
<li><code>chdir</code>：更改当前工作目录。<ul>
<li>参数：<code>pathname</code>：将该目录作为当前工作目录</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>fchdir</code>：更改当前工作目录。<ul>
<li>参数：<code>fd</code>：将该 <code>fd</code> 文件描述符对应的目录作为当前工作目录</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>getcwd</code>：返回当前工作目录的名字<ul>
<li>参数： <code>buf</code>：缓冲区地址；<code>size</code>：缓冲区长度。这两个参数决定了当前工作目录名字字符串存放的位置。<blockquote>
<p>缓冲区必须足够长以容纳绝对路径名加上一个终止<code>null</code>字节。否则返回出错。</p>
</blockquote>
</li>
<li>返回值： 成功则返回 <code>buf</code>；失败返回 <code>NULL</code></li>
</ul>
</li>
</ul>
</li>
<li><p>示例： 在<code>main</code>函数中调用 <code>test_dir_operations</code> 函数：</p>
</li>
</ol>
<pre><code>void test_dir_operations()
{
    M_TRACE(&quot;---------  Begin test_dir_operations()  ---------\n&quot;);
    //*** 创建目录 ****
    My_mkdir(&quot;test&quot;,S_IRWXU);
    My_mkdir(&quot;test/test1&quot;,S_IRWXU);

    //*** 创建文件
    prepare_file(&quot;test/tfile_1&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/tfile_2&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/tfile_3&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_11&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_22&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_33&quot;,NULL,0,S_IRWXU);

    print_dir(&quot;test&quot;);

    print_cwd();
    My_chdir(&quot;test&quot;);
    print_cwd();
    My_chdir(&quot;../&quot;); // 切换回来，否则后面的删除文件都会失败（因为都是相对路径）
    print_cwd();
    //***** 清理
    My_rmdir(&quot;test&quot;); // 目录非空，删除失败！
    un_prepare_file(&quot;test/tfile_1&quot;);
    un_prepare_file(&quot;test/tfile_2&quot;);
    un_prepare_file(&quot;test/tfile_3&quot;);
    un_prepare_file(&quot;test/test1/tfile_11&quot;);
    un_prepare_file(&quot;test/test1/tfile_22&quot;);
    un_prepare_file(&quot;test/test1/tfile_33&quot;);
    My_rmdir(&quot;test/test1&quot;); // 必须非空才能删除成功
    My_rmdir(&quot;test&quot;); // 必须非空才能删除成功
    M_TRACE(&quot;---------  End test_dir_operations()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![dir_function](../imgs/file_dir/dir_function.JPG) %                                                                    
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/27/C语言指针&内存分配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/27/C语言指针&内存分配/" itemprop="url">
                  C语言指针&内存分配
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-27T00:00:00+08:00">
                2017-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/27/C语言指针&内存分配/" class="leancloud_visitors" data-flag-title="C语言指针&内存分配">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>指针也是一种数据类型。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/27/C语言指针&内存分配/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/19/celery学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/19/celery学习笔记/" itemprop="url">
                  celery学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T00:00:00+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/19/celery学习笔记/" class="leancloud_visitors" data-flag-title="celery学习笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在程序的运行过程中，我们经常会遇到一些耗时耗资源的操作，为了避免他们阻塞主程序的运行，我们经常会采用多线程或异步任务。比如，在web开发中，    对于新用户的注册，我们通常会给他们发送一封激活邮件，而发送邮件是个IO阻塞式任务，如果直接把它放到应用当中去，就需要等邮件发出去之后才能进行下一步操作，此时用户只能等待再等待，更好的方式是在业务逻辑中触发一个发送邮件的异步任务，而主程序可以继续往下执行。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/19/celery学习笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/14/OJ查重设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/14/OJ查重设计/" itemprop="url">
                  OJ查重设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-14T00:00:00+08:00">
                2017-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OJ研发/" itemprop="url" rel="index">
                    <span itemprop="name">OJ研发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/14/OJ查重设计/" class="leancloud_visitors" data-flag-title="OJ查重设计">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>因为OJ有一个查重功能需要完善，所以我今天查阅了百度和google，目前可以用的有standford的moss和<a href="https://dickgrune.com/" target="_blank" rel="external">Dick grune</a>的<a href="https://dickgrune.com/Programs/similarity_tester/" target="_blank" rel="external">sim</a>。<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/14/OJ查重设计/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/12/JS学习笔记2进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/JS学习笔记2进阶/" itemprop="url">
                  JS学习笔记2进阶
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T00:00:00+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/12/JS学习笔记2进阶/" class="leancloud_visitors" data-flag-title="JS学习笔记2进阶">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>JS学习笔记2进阶篇</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/12/JS学习笔记2进阶/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/12/JS学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/JS学习笔记/" itemprop="url">
                  JS学习笔记1入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T00:00:00+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/12/JS学习笔记/" class="leancloud_visitors" data-flag-title="JS学习笔记1入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>JS学习笔记1入门篇<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/12/JS学习笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://dearamaze.com/2017/11/12/32位和64位系统区别及int字节数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dear Amaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DearAmaze-桀骜良">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/12/32位和64位系统区别及int字节数/" itemprop="url">
                  32位和64位系统区别及int字节数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T00:00:00+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/12/32位和64位系统区别及int字节数/" class="leancloud_visitors" data-flag-title="32位和64位系统区别及int字节数">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="64位系统和32位有什么区别？"><a href="#64位系统和32位有什么区别？" class="headerlink" title="64位系统和32位有什么区别？"></a>64位系统和32位有什么区别？</h2><p>1、64bit CPU拥有更大的寻址能力，最大支持到16GB内存，而32bit只支持4G内存</p>
<p>2、64位CPU一次可提取64位数据，比32位提高了一倍，理论上性能会提升1倍。但这是建立在64bit操作系统，64bit软件的基础上的。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/11/12/32位和64位系统区别及int字节数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar2.jpg"
               alt="Dear Amaze" />
          <p class="site-author-name" itemprop="name">Dear Amaze</p>
           
              <p class="site-description motion-element" itemprop="description">最穷不过要饭丶不死总会出头</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fdl66" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/qq_27803491" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-desktop"></i>
                  
                  CSDN
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/ao-jie-88/answers" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-vimeo"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://hello-fh.com/" title="浩哥" target="_blank">浩哥</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://githubecho.github.io/" title="阿谦" target="_blank">阿谦</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dear Amaze</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("fOpTd1WjHbULIjn8MszImyoU-gzGzoHsz", "BD6q7tNiA5K8GhdTkj9uEy0u");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  <script>
      // highlight
      hljs.initHighlightingOnLoad();
  </script>
</body>
</html>
