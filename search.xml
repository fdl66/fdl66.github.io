<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[curl学习]]></title>
      <url>/2017/12/28/curl%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>curl命令是一个功能强大的网络工具，它能够通过http、ftp等方式下载文件，也能够上传文件，同时支持HTTPS等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。其实curl远不止前面所说的那些功能，大家可以通过man curl阅读手册页获取更多的信息。类似的工具还有wget。curl命令使用了libcurl库来实现，libcurl库常用在C程序中用来处理HTTP请求，curlpp是libcurl的一个C++封装，这几个东西可以用在抓取网页、网络监控等方面的开发，而curl命令可以帮助来解决开发过程中遇到的问题。</p>
</blockquote>
<a id="more"></a>
<h2 id="下载单个文件，默认将输出打印到标准输出中-STDOUT-中"><a href="#下载单个文件，默认将输出打印到标准输出中-STDOUT-中" class="headerlink" title="下载单个文件，默认将输出打印到标准输出中(STDOUT)中"></a>下载单个文件，默认将输出打印到标准输出中(STDOUT)中</h2><h2 id="通过-o-O选项保存下载的文件到指定的文件中"><a href="#通过-o-O选项保存下载的文件到指定的文件中" class="headerlink" title="通过-o/-O选项保存下载的文件到指定的文件中"></a>通过-o/-O选项保存下载的文件到指定的文件中</h2><pre><code>-o：将文件保存为命令行中指定的文件名的文件中
-O：使用URL中默认的文件名保存文件到本地
</code></pre><pre><code># 将文件下载到本地并命名为mygettext.html
curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html
# 将文件保存到本地并命名为gettext.html
curl -O http://www.gnu.org/software/gettext/manual/gettext.html
</code></pre><p>同样可以使用转向字符”&gt;”对输出进行转向输出</p>
<h2 id="同时获取多个文件"><a href="#同时获取多个文件" class="headerlink" title="同时获取多个文件"></a>同时获取多个文件</h2><pre><code>curl -O URL1 -O URL2
</code></pre><p>若同时从同一站点下载多个文件时，curl会尝试重用链接(connection)。</p>
<p>通过-L选项进行重定向<br>默认情况下CURL不会发送HTTP Location headers(重定向).当一个被请求页面移动到另一个站点时，会发送一个HTTP Loaction header作为请求，然后将请求重定向到新的地址上。<br>例如：访问google.com时，会自动将地址重定向到google.com.hk上。</p>
<pre><code class="html">curl http://www.google.com
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
    &lt;TITLE&gt;302 Moved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
    &lt;H1&gt;302 Moved&lt;/H1&gt;
    The document has moved
    &lt;A HREF=&quot;http://www.google.com.hk/url?sa=p&amp;amp;hl=zh-CN&amp;amp;pref=hkredirect&amp;amp;pval=yes&amp;amp;q=http://www.google.com.hk/&amp;amp;ust=1379402837567135amp;usg=AFQjCNF3o7umf3jyJpNDPuF7KTibavE4aA&quot;&gt;here&lt;/A&gt;.
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
<p>上述输出说明所请求的档案被转移到了<a href="http://www.google.com.hk。" target="_blank" rel="external">http://www.google.com.hk。</a></p>
<p>这是可以通过使用-L选项进行强制重定向</p>
<pre><code># 让curl使用地址重定向，此时会查询google.com.hk站点
curl -L http://www.google.com
</code></pre><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><p>通过使用-C选项可对大文件使用断点续传功能，如：</p>
<pre><code># 当文件在下载完成之前结束该进程
$ curl -O http://www.gnu.org/software/gettext/manual/gettext.html
##############             20.1%
# 通过添加-C选项继续对该文件进行下载，已经下载过的文件不会被重新下载
curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html
###############            21.1%
</code></pre><h2 id="对CURL使用网络限速"><a href="#对CURL使用网络限速" class="headerlink" title="对CURL使用网络限速"></a>对CURL使用网络限速</h2><p>通过<code>--limit-rate</code>选项对CURL的最大网络使用进行限制</p>
<pre><code># 下载速度最大不会超过1000B/second
curl --limit-rate 1000B -O http://www.gnu.org/software/gettext/manual/gettext.html
</code></pre><h2 id="下载指定时间内修改过的文件"><a href="#下载指定时间内修改过的文件" class="headerlink" title="下载指定时间内修改过的文件"></a>下载指定时间内修改过的文件</h2><p>当下载一个文件时，可对该文件的最后修改日期进行判断，如果该文件在指定日期内修改过，就进行下载，否则不下载。<br>该功能可通过使用-z选项来实现：</p>
<pre><code># 若yy.html文件在2011/12/21之后有过更新才会进行下载
curl -z 21-Dec-11 http://www.example.com/yy.html
</code></pre><h2 id="CURL授权"><a href="#CURL授权" class="headerlink" title="CURL授权"></a>CURL授权</h2><p>在访问需要授权的页面时，可通过-u选项提供用户名和密码进行授权</p>
<pre><code>curl -u username:password URL
# 通常的做法是在命令行只输入用户名，之后会提示输入密码，这样可以保证在查看历史记录时不会将密码泄露
curl -u username URL
</code></pre><h2 id="从FTP服务器下载文件"><a href="#从FTP服务器下载文件" class="headerlink" title="从FTP服务器下载文件"></a>从FTP服务器下载文件</h2><p>CURL同样支持FTP下载，若在url中指定的是某个文件路径而非具体的某个要下载的文件名，CURL则会列出该目录下的所有文件名而并非下载该目录下的所有文件</p>
<pre><code># 列出public_html下的所有文件夹和文件
curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/
# 下载xss.php文件
curl -u ftpuser:ftppass -O ftp://ftp_server/public_html/xss.php
</code></pre><h2 id="上传文件到FTP服务器"><a href="#上传文件到FTP服务器" class="headerlink" title="上传文件到FTP服务器"></a>上传文件到FTP服务器</h2><p>通过 -T 选项可将指定的本地文件上传到FTP服务器上</p>
<pre><code># 将myfile.txt文件上传到服务器
curl -u ftpuser:ftppass -T myfile.txt ftp://ftp.testserver.com
# 同时上传多个文件
curl -u ftpuser:ftppass -T &quot;{file1,file2}&quot; ftp://ftp.testserver.com
# 从标准输入获取内容保存到服务器指定的文件中
curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt
</code></pre><h2 id="获取更多信息"><a href="#获取更多信息" class="headerlink" title="获取更多信息"></a>获取更多信息</h2><p>通过使用 -v 和 -trace获取更多的链接信息</p>
<h2 id="通过字典查询单词"><a href="#通过字典查询单词" class="headerlink" title="通过字典查询单词"></a>通过字典查询单词</h2><pre><code># 查询bash单词的含义
curl dict://dict.org/d:bash
# 列出所有可用词典
curl dict://dict.org/show:db
# 在foldoc词典中查询bash单词的含义
curl dict://dict.org/d:bash:foldoc
</code></pre><h2 id="为CURL设置代理"><a href="#为CURL设置代理" class="headerlink" title="为CURL设置代理"></a>为CURL设置代理</h2><p>-x 选项可以为CURL添加代理功能</p>
<pre><code># 指定代理主机和端口
curl -x proxysever.test.com:3128 http://google.co.in
</code></pre><h2 id="保存与使用网站cookie信息"><a href="#保存与使用网站cookie信息" class="headerlink" title="保存与使用网站cookie信息"></a>保存与使用网站cookie信息</h2><pre><code># 将网站的cookies信息保存到sugarcookies文件中
curl -D sugarcookies http://localhost/sugarcrm/index.php
# 使用上次保存的cookie信息
curl -b sugarcookies http://localhost/sugarcrm/index.php
</code></pre><h2 id="传递请求数据"><a href="#传递请求数据" class="headerlink" title="传递请求数据"></a>传递请求数据</h2><p>默认curl使用GET方式请求数据，这种方式下直接通过URL传递数据<br>可以通过 –data/-d 方式指定使用POST方式传递数据</p>
<pre><code># GET
curl -u username https://api.github.com/user?access_token=XXXXXXXXXX
# POST
curl -u username --data &quot;param1=value1&amp;param2=value&quot; https://api.github.com
# 也可以指定一个文件，将该文件中的内容当作数据传递给服务器端
curl --data @filename https://github.api.com/authorizations
</code></pre><p>注：默认情况下，通过POST方式传递过去的数据中若有特殊字符，首先需要将特殊字符转义在传递给服务器端，如value值中包含有空格，则需要先将空格转换成%20，如：</p>
<pre><code>curl -d &quot;value%201&quot; http://hostname.com
</code></pre><p>在新版本的CURL中，提供了新的选项 –data-urlencode，通过该选项提供的参数会自动转义特殊字符。</p>
<pre><code>curl --data-urlencode &quot;value 1&quot; http://hostname.com
</code></pre><p>除了使用GET和POST协议外，还可以通过 -X 选项指定其它协议，如：</p>
<pre><code>curl -I -X DELETE https://api.github.cim
</code></pre><p>上传文件</p>
<pre><code>curl --form &quot;fileupload=@filename.txt&quot; http://hostname/resource
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>-a/--append                        上传文件时，附加到目标文件
--anyauth                            可以使用“任何”身份验证方法
--basic                                使用HTTP基本验证
-B/--use-ascii                      使用ASCII文本传输
-d/--data &lt;data&gt;                  HTTP POST方式传送数据
--data-ascii &lt;data&gt;            以ascii的方式post数据
--data-binary &lt;data&gt;          以二进制的方式post数据
--negotiate                          使用HTTP身份验证
--digest                        使用数字身份验证
--disable-eprt                  禁止使用EPRT或LPRT
--disable-epsv                  禁止使用EPSV
--egd-file &lt;file&gt;              为随机数据(SSL)设置EGD socket路径
--tcp-nodelay                  使用TCP_NODELAY选项
-E/--cert &lt;cert[:passwd]&gt;      客户端证书文件和密码 (SSL)
--cert-type &lt;type&gt;              证书文件类型 (DER/PEM/ENG) (SSL)
--key &lt;key&gt;                    私钥文件名 (SSL)
--key-type &lt;type&gt;              私钥文件类型 (DER/PEM/ENG) (SSL)
--pass  &lt;pass&gt;                  私钥密码 (SSL)
--engine &lt;eng&gt;                  加密引擎使用 (SSL). &quot;--engine list&quot; for list
--cacert &lt;file&gt;                CA证书 (SSL)
--capath &lt;directory&gt;            CA目   (made using c_rehash) to verify peer against (SSL)
--ciphers &lt;list&gt;                SSL密码
--compressed                    要求返回是压缩的形势 (using deflate or gzip)
--connect-timeout &lt;seconds&gt;    设置最大请求时间
--create-dirs                  建立本地目录的目录层次结构
--crlf                          上传是把LF转变成CRLF
--ftp-create-dirs              如果远程目录不存在，创建远程目录
--ftp-method [multicwd/nocwd/singlecwd]    控制CWD的使用
--ftp-pasv                      使用 PASV/EPSV 代替端口
--ftp-skip-pasv-ip              使用PASV的时候,忽略该IP地址
--ftp-ssl                      尝试用 SSL/TLS 来进行ftp数据传输
--ftp-ssl-reqd                  要求用 SSL/TLS 来进行ftp数据传输
-F/--form &lt;name=content&gt;        模拟http表单提交数据
-form-string &lt;name=string&gt;      模拟http表单提交数据
-g/--globoff                    禁用网址序列和范围使用{}和[]
-G/--get                        以get的方式来发送数据
-h/--help                      帮助
-H/--header &lt;line&gt;              自定义头信息传递给服务器
--ignore-content-length        忽略的HTTP头信息的长度
-i/--include                    输出时包括protocol头信息
-I/--head                      只显示文档信息
-j/--junk-session-cookies      读取文件时忽略session cookie
--interface &lt;interface&gt;        使用指定网络接口/地址
--krb4 &lt;level&gt;                  使用指定安全级别的krb4
-k/--insecure                  允许不使用证书到SSL站点
-K/--config                    指定的配置文件读取
-l/--list-only                  列出ftp目录下的文件名称
--limit-rate &lt;rate&gt;            设置传输速度
--local-port&lt;NUM&gt;              强制使用本地端口号
-m/--max-time &lt;seconds&gt;        设置最大传输时间
--max-redirs &lt;num&gt;              设置最大读取的目录数
--max-filesize &lt;bytes&gt;          设置最大下载的文件总量
-M/--manual                    显示全手动
-n/--netrc                      从netrc文件中读取用户名和密码
--netrc-optional                使用 .netrc 或者 URL来覆盖-n
--ntlm                          使用 HTTP NTLM 身份验证
-N/--no-buffer                  禁用缓冲输出
-p/--proxytunnel                使用HTTP代理
--proxy-anyauth                选择任一代理身份验证方法
--proxy-basic                  在代理上使用基本身份验证
--proxy-digest                  在代理上使用数字身份验证
--proxy-ntlm                    在代理上使用ntlm身份验证
-P/--ftp-port &lt;address&gt;        使用端口地址，而不是使用PASV
-Q/--quote &lt;cmd&gt;                文件传输前，发送命令到服务器
--range-file                    读取（SSL）的随机文件
-R/--remote-time                在本地生成文件时，保留远程文件时间
--retry &lt;num&gt;                  传输出现问题时，重试的次数
--retry-delay &lt;seconds&gt;        传输出现问题时，设置重试间隔时间
--retry-max-time &lt;seconds&gt;      传输出现问题时，设置最大重试时间
-S/--show-error                显示错误
--socks4 &lt;host[:port]&gt;          用socks4代理给定主机和端口
--socks5 &lt;host[:port]&gt;          用socks5代理给定主机和端口
-t/--telnet-option &lt;OPT=val&gt;    Telnet选项设置
--trace &lt;file&gt;                  对指定文件进行debug
--trace-ascii &lt;file&gt;            Like --跟踪但没有hex输出
--trace-time                    跟踪/详细输出时，添加时间戳
--url &lt;URL&gt;                    Spet URL to work with
-U/--proxy-user &lt;user[:password]&gt;  设置代理用户名和密码
-V/--version                    显示版本信息
-X/--request &lt;command&gt;          指定什么命令
-y/--speed-time                放弃限速所要的时间。默认为30
-Y/--speed-limit                停止传输速度的限制，速度时间&#39;秒
-z/--time-cond                  传送时间设置
-0/--http1.0                    使用HTTP 1.0
-1/--tlsv1                      使用TLSv1（SSL）
-2/--sslv2                      使用SSLv2的（SSL）
-3/--sslv3                      使用的SSLv3（SSL）
--3p-quote                      like -Q for the source URL for 3rd party transfer
--3p-url                        使用url，进行第三方传送
--3p-user                      使用用户名和密码，进行第三方传送
-4/--ipv4                      使用IP4
-6/--ipv6                      使用IP6
</code></pre><p><a href="http://curl.haxx.se/docs/httpscripting.html" target="_blank" rel="external">http://curl.haxx.se/docs/httpscripting.html</a><br><a href="http://www.cnblogs.com/gbyukg/p/3326825.html" target="_blank" rel="external">http://www.cnblogs.com/gbyukg/p/3326825.html</a><br><a href="https://www.cnblogs.com/duhuo/p/5695256.html" target="_blank" rel="external">https://www.cnblogs.com/duhuo/p/5695256.html</a></p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令,计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编译链接常识]]></title>
      <url>/2017/12/27/%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%B8%B8%E8%AF%86/</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>库是一种可执行的二进制代码(但不可以独立执行)，可以被操作系统载入内存执行。</p>
</blockquote>
<p>由于 windows 和 linux 的平台不同（主要是编译器、汇编器和连接器 的不同），因此二者库的二进制是不兼容的。<br>本文仅限于介绍 linux 下的库。<br><a id="more"></a></p>
<h3 id="库的种类"><a href="#库的种类" class="headerlink" title="库的种类"></a>库的种类</h3><p>linux 下的库有两种：<code>静态库</code>和<code>共享库</code>（<code>动态库</code>）。</p>
<p>   二者的不同点在于<strong>代码被载入的时刻不同</strong>：</p>
<p><strong>静态库</strong>的代码在编译过程中已经被载入可执行程序，因此生成的可执行程序体积较大。静态用.a为后缀， 例如： libhello.a</p>
<p><strong>共享库</strong>(<strong>动态库</strong>)的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此生成的可执行程序代码体积较小。动态通常用.so为后缀， 例如：libhello.so</p>
<p><strong>共享库(动态库)的好处</strong>是: 不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</p>
<p>为了在同一系统中使用不同版本的库，可以在库文件名后加上版本号为后缀,例如： libhello.so.1.0,由于程序连接默认以.so为文件后缀名。所以为了使用这些库，通常使用建立符号连接的方式。</p>
<pre><code class="shell">ln -s libhello.so.1.0 libhello.so.1 
ln -s libhello.so.1 libhello.so
</code></pre>
<h3 id="静态库，动态库文件在linux下是如何生成的"><a href="#静态库，动态库文件在linux下是如何生成的" class="headerlink" title="静态库，动态库文件在linux下是如何生成的"></a>静态库，动态库文件在linux下是如何生成的</h3><p>以下面的代码为例，生成上面用到的hello库：</p>
<pre><code>/* hello.c */  
#include &quot;hello.h&quot;  
void sayhello()  
{      
    printf(&quot;hello,world &quot;);  
}
</code></pre><p>首先用gcc编绎该文件，在编绎时可以使用任何合法的编绎参数，例如-g加入调试代码等：<br><code>gcc -c hello.c -o hello.o</code></p>
<p>1、生成静态库 生成静态库使用ar工具，其实ar是archive的意思<br><code>ar cqs libhello.a hello.o</code><br>2、生成动态库 用gcc来完成，由于可能存在多个版本，因此通常指定版本号：<br><code>gcc -shared -o libhello.so.1.0 hello.o</code></p>
<h3 id="库文件是如何命名的，有没有什么规范"><a href="#库文件是如何命名的，有没有什么规范" class="headerlink" title="库文件是如何命名的，有没有什么规范"></a>库文件是如何命名的，有没有什么规范</h3><p>在 linux 下，库文件一般放在/usr/lib和/lib下，<br><strong>静态库</strong>的名字一般为<code>libxxxx.a</code>，其中 xxxx 是该lib的名称；<br><strong>动态库</strong>的名字一般为<code>libxxxx.so.major.minor</code>，xxxx 是该lib的名称，major是主版本号，minor是副版本号</p>
<h3 id="可执行程序在执行的时候如何定位共享库-动态库-文件"><a href="#可执行程序在执行的时候如何定位共享库-动态库-文件" class="headerlink" title="可执行程序在执行的时候如何定位共享库(动态库)文件"></a>可执行程序在执行的时候如何定位共享库(动态库)文件</h3><p>当系统加载可执行代码(即库文件)的时候，<strong>能够知道其所依赖的库的名字</strong>，但是<strong>还需要知道绝对路径</strong>，此时就需要<strong>系统动态载入器</strong> (dynamic linker/loader)<br>    对于 elf 格式的可执行程序，是由 <code>ld-linux.so*</code> 来完成的，它先后搜索 elf 文件的 <code>DT_RPATH 段</code> –&gt; 环境变量<code>LD_LIBRARY_PATH</code> —-&gt; <code>/etc/ld.so.cache</code> 文件列表–&gt; <code>/lib/</code>,<code>/usr/lib</code> 目录<strong>找到库文件后将其载入内存</strong><br>    如： <code>export LD_LIBRARY_PATH=’pwd’</code><br>    将当前文件目录添加为共享目录。</p>
<h3 id="使用ldd工具，查看可执行程序依赖那些动态库或着动态库依赖于那些动态库"><a href="#使用ldd工具，查看可执行程序依赖那些动态库或着动态库依赖于那些动态库" class="headerlink" title="使用ldd工具，查看可执行程序依赖那些动态库或着动态库依赖于那些动态库"></a>使用ldd工具，查看可执行程序依赖那些动态库或着动态库依赖于那些动态库</h3><p><strong>ldd 命令</strong>可以查看<strong>一个可执行程序依赖的<em>共享库</em></strong>，<br>例如 # ldd /bin/lnlibc.so.6<br>    =&gt; /lib/libc.so.6 (0×40021000)/lib/ld-linux.so.2<br>    =&gt; /lib/ld- linux.so.2 (0×40000000)<br>可以看到 <code>ln</code> 命令依赖于 <code>libc</code> 库和 <code>ld-linux</code> 库 </p>
<h3 id="使用nm工具，查看静态库和动态库中有那些函数名"><a href="#使用nm工具，查看静态库和动态库中有那些函数名" class="headerlink" title="使用nm工具，查看静态库和动态库中有那些函数名"></a>使用nm工具，查看静态库和动态库中有那些函数名</h3><p>（<strong>T类表示函数是当前库中定义的，U类表示函数是被调用的，在其它库中定义的，W类是当前库中定义，被其它库中的函数覆盖</strong>）。：<br>有时候可能需要查看一个库中到底<strong>有哪些函数</strong>，nm工具可以打印出库中的涉及到的所有符号，这里的库<strong>既可以是静态的也可以是动态的</strong>。<br>nm列出的符号有很多， 常见的有三种::</p>
<p>T类：是在库中定义的函数，用T表示，这是最常见的；</p>
<p>U类：是在库中被调用，但并没有在库中定义(表明需要其他库支持)，用U表示；</p>
<p>W类：是所谓的“弱态”符号，它们虽然在库中被定义，但是可能被其他库中的同名符号覆盖，用W表示。</p>
<p>例如，假设开发者希望知道上文提到的hello库中是否引用了 printf():</p>
<p>nm libhello.so | grep printf<br>发现printf是U类符号，说明printf被引用，但是并没有在库中定义。</p>
<p>由此可以推断，要正常使用hello库，必须有其它库支持，使用ldd工具查看hello依赖于哪些库：</p>
<p>ldd libhello.so</p>
<p>libc.so.6=&gt;/lib/libc.so.6(0x400la000)  </p>
<p>/lib/ld-linux.so.2=&gt;/lib/ld-linux.so.2 (0x40000000)</p>
<p>从上面的结果可以继续查看printf最终在哪里被定义，有兴趣可以go on</p>
<h3 id="使用ar工具，可以生成静态库，同时可以查看静态库中包含那些-o文件，即有那些源文件构成"><a href="#使用ar工具，可以生成静态库，同时可以查看静态库中包含那些-o文件，即有那些源文件构成" class="headerlink" title="使用ar工具，可以生成静态库，同时可以查看静态库中包含那些.o文件，即有那些源文件构成"></a>使用ar工具，可以生成静态库，同时可以查看静态库中包含那些.o文件，即有那些源文件构成</h3><p>可以使用 <code>ar -t libname.a</code> 来<strong>查看一个静态库由那些.o文件构成</strong>。</p>
<p>可以使用 <code>ar q libname.a xxx1.o  xxx2.o xxx3.o ... xxxn.o</code> <strong>生成静态库</strong></p>
<h3 id="如何查看动态库和静态库是32位，还是64位下的库"><a href="#如何查看动态库和静态库是32位，还是64位下的库" class="headerlink" title="如何查看动态库和静态库是32位，还是64位下的库"></a>如何查看动态库和静态库是32位，还是64位下的库</h3><p>如果是<strong>动态库</strong>，可以使用<code>file *.so</code>；<br>如果是<strong>静态库</strong>，可以使用<code>objdump -x *.a</code></p>
<h2 id="Linux下进行程序设计时，关于库的使用"><a href="#Linux下进行程序设计时，关于库的使用" class="headerlink" title="Linux下进行程序设计时，关于库的使用"></a>Linux下进行程序设计时，关于库的使用</h2><h3 id="gcc-g-命令中关于库的参数"><a href="#gcc-g-命令中关于库的参数" class="headerlink" title="gcc/g++命令中关于库的参数"></a>gcc/g++命令中关于库的参数</h3><pre><code>-shared： 该选项指定生成动态连接库；
-fPIC：表示编译为位置独立(地址无关)的代码，不用此选项的话，编译后的代码是位置相关的，所以动态载入时，是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。
-L：指定链接库的路径，-L. 表示要连接的库在当前目录中
-ltest：指定链接库的名称为test，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.so来确定库的名称
-Wl,-rpath: 记录以来so文件的路径信息。
LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。
 当然如果有root权限的话，可以修改/etc/ld.so.conf文件，然后调用 /sbin/ldconfig来达到同样的目的，
 不过如果没有root权限，那么只能采用修改LD_LIBRARY_PATH环境变量的方法了。 
</code></pre><p><strong>调用动态库的时候，有几个问题会经常碰到</strong><br>有时，明明已经将库的头文件所在目录 通过 “-I” include进来了，库所在文件通过 “-L”参数引导，并指定了“-l”的库名，但通过ldd命令察看时，就是死活找不到你指定链接的so文件，这时你要作的就是通过修改 LD_LIBRARY_PATH或者/etc/ld.so.conf文件来指定动态库的目录。通常这样做就可以解决库无法链接的问题了。</p>
<h3 id="静态库链接时搜索路径的顺序"><a href="#静态库链接时搜索路径的顺序" class="headerlink" title="静态库链接时搜索路径的顺序"></a>静态库链接时搜索路径的顺序</h3><pre><code>1. ld会去找gcc/g++命令中的参数-L；
2. 再找gcc的环境变量LIBRARY_PATH,它指定程序静态链接库文件搜索路径；
    1. `export LIBRARY_PATH=$LIBRARY_PATH:data/home/billchen/lib `
3. 再找默认库目录 /lib  /usr/lib  /usr/local/lib，这是当初compile gcc时写在程序内的。 
</code></pre><h3 id="动态链接时、执行时搜索路径顺序"><a href="#动态链接时、执行时搜索路径顺序" class="headerlink" title="动态链接时、执行时搜索路径顺序"></a>动态链接时、执行时搜索路径顺序</h3><pre><code>1. 编译目标代码时指定的动态库搜索路径；
2. 环境变量LD_LIBRARY_PATH指定动态库搜索路径，它指定程序动态链接库文件搜索路径；
  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:data/home/billchen/lib 
3. 配置文件/etc/ld.so.conf中指定的动态库搜索路径；
4. 默认的动态库搜索路径/lib；
5. 默认的动态库搜索路径/usr/lib。 
</code></pre><h3 id="静态库和动态链接库同时存在时，gcc-g-默认链接的是动态库"><a href="#静态库和动态链接库同时存在时，gcc-g-默认链接的是动态库" class="headerlink" title="静态库和动态链接库同时存在时，gcc/g++默认链接的是动态库"></a>静态库和动态链接库同时存在时，gcc/g++默认链接的是动态库</h3><p> 当一个库同时存在静态库和动态库时，比如libmysqlclient.a和libmysqlclient.so同时存在时：<br>在Linux下，动态库和静态库同事存在时，<strong>gcc/g++的链接程序，默认链接的动态库</strong>。</p>
<p>可以使用下面的方法，给连接器ld传递参数，看是否链接动态库还是静态库。</p>
<pre><code>-Wl,-Bstatic -llibname        //指定让gcc/g++链接静态库
使用:
gcc/g++ test.c -o test -Wl,-Bstatic -llibname -Wl,-Bdynamic -lm -lc 

-Wl,-Bdynamic -llibname       //指定让gcc/g++链接动态库
使用:
gcc/g++ test.c -o test -Wl,-Bdynamic -llibname
</code></pre><p><strong>如果要完全静态加载，使用-static参数，即将所有的库以静态的方式链入可执行程序，这样生成的可执行程序，不再依赖任何库，同事出现的问题是，这样编译出来的程序非常大，占用空间。<br>如果不适用-Wl,-Bdynamic -lm -c会有如下错误</strong>：</p>
<pre><code>[chenbaihu@build17 lib]$ ls
libtest.a  libtest.so  t  t.cc  test.cc  test.h  test.o
[chenbaihu@build17 lib]$ g++ -Wall -g t.cc -o t -L./ -Wl,-Bstatic -ltest -Wl,-Bdynamic -lm -lc
[chenbaihu@build17 lib]$ g++ -Wall -g t.cc -o t -L./ -Wl,-Bstatic -ltest 
/usr/bin/ld: cannot find -lm
collect2: ld 返回 1
</code></pre><p>参考：<br>     <a href="http://lists.gnu.org/archive/html/help-gnu-utils/2004-03/msg00009.html" target="_blank" rel="external">http://lists.gnu.org/archive/html/help-gnu-utils/2004-03/msg00009.html</a></p>
<h3 id="有关环境变量"><a href="#有关环境变量" class="headerlink" title="有关环境变量"></a>有关环境变量</h3><p><code>LIBRARY_PATH</code>环境变量：指定程序<strong>静态链接库文件搜索路径</strong><br><code>LD_LIBRARY_PATH</code>环境变量：指定程序<strong>动态链接库文件搜索路径</strong> </p>
<h3 id="库的依赖问题"><a href="#库的依赖问题" class="headerlink" title="库的依赖问题"></a>库的依赖问题</h3><p>比如我们有一个基础库libbase.a,还有一个依赖libbase.a编译的库，叫做libchild.a；在我们编译程序时，一定要先-lchild再-lbase。 如果使用 -lbase -lchild，在编译时将出现一些函数undefined，而这些函数实际上已经在base中已经定义；</p>
<p>为什么会有库的依赖问题？</p>
<pre><code>一、静态库解析符号引用：
  链接器ld是如何使用静态库来解析引用的。在符号解析阶段，链接器从左至右，依次扫描可重定位目标文件（*.o）和静态库（*.a）。
在这个过程中，链接器将维持三个集合：
    集合E：可重定位目标文件(*.o文件)的集合。
    集合U：未解析(未定义)的符号集，即符号表中UNDEF的符号。
    集合D： 已定义的符号集。
初始情况下，E、U、D均为空。

    1、对于每个输入文件f，如果是目标文件(.o)，则将f加入E，并用f中的符号表修改U、D(在文件f中定义实现的符号是D，在f中引用的符号是U)，然后继续下个文件。
    2、如果f是一个静态库(.a)，那么链接器将尝试匹配U中未解析符号与静态库成员(静态库的成员就是.o文件)定义的符号。如果静态库中某个成员m(某个.o文件)定义了一个符号来解析U中引用，那么将m加入E中，
    同时使用m的符号表，来更新U、D。对静态库中所有成员目标文件反复进行该过程，直至U和D不再发生变化。此时，静态库f中任何不包含在E中的成员目标文件都将丢弃，链接器将继续下一个文件。
    3、当所有输入文件完成后，如果U非空，链接器则会报错，否则合并和重定位E中目标文件，构建出可执行文件。

到这里，为什么会有库的依赖问题已经得到解答：
    因为libchild.a依赖于libbase.a，但是libbase.a在libchild.a的左边，导致libbase.a中的目标文件(*.o)根本就没有被加载到E中，所以解决方法就是交换两者的顺序。当然也可以使用-lbase -lchild -lbase的方法。

参考文章：http://pananq.com/index.php/page/3/
</code></pre><h3 id="动态库升级问题"><a href="#动态库升级问题" class="headerlink" title="动态库升级问题"></a>动态库升级问题</h3><p>在动态链接库升级时，<br>   <strong>不能使用</strong><code>cp newlib.so oldlib.so</code>，这样有可能会使程序core掉；<br>   <strong>而应该使用:<br>   <code>rm oldlib.so</code> 然后 <code>cp newlib.so oldlib.so</code><br>   或者<br>    <code>mv oldlib.so oldlib.so_bak</code> 然后 <code>cp newlib.so oldlib.so</code></strong></p>
<p>为什么不能用cp newlib.so oldlib.so ?</p>
<pre><code>在替换so文件时，如果在不停程序的情况下，直接用 cp new.so old.so 的方式替换程序使用的动态库文件会导致正在运行中的程序崩溃。
</code></pre><p>解决方法:</p>
<pre><code>解决的办法是采用“rm＋cp” 或“mv＋cp” 来替代直接“cp” 的操作方法。
linux系统的动态库有两种使用方法：运行时动态链接库，动态加载库并在程序控制之下使用。
</code></pre><p>1、为什么在不停程序的情况下，直接用 cp 命令替换程序使用的 so 文件，会使程序崩溃？<br>很多同学在工作中遇到过这样一个问题，在替换 so 文件时，如果在不停程序的情况下，直接用cp new.so old.so的方式替换程序使用的动态库文件会导致正在运行中的程序崩溃，退出。</p>
<pre><code>这与 cp 命令的实现有关，cp 并不改变目标文件的 inode，cp 的目标文件会继承被覆盖文件的属性而非源文件。实际上它是这样实现的：
strace cp libnew.so libold.so 2&gt;&amp;1 |grep open.*lib.*.so
open(&quot;libnew.so&quot;, O_RDONLY|O_LARGEFILE) = 3
open(&quot;libold.so&quot;, O_WRONLY|O_TRUNC|O_LARGEFILE) = 4
在 cp 使用“O_WRONLY|O_TRUNC” 打开目标文件时，原 so 文件的镜像被意外的破坏了。这样动态链接器 ld.so 不能访问到 so 文件中的函数入口。从而导致 Segmentation fault，程序崩溃。ld.so 加载 so 文件及“再定位”的机制比较复杂。
</code></pre><p>2、怎样在不停止程序的情况下替换so文件，并且保证程序不会崩溃？</p>
<pre><code>答案是采用“rm＋cp” 或“mv＋cp” 来替代直接“cp” 的操作方法。
在用新的so文件 libnew.so 替换旧的so文件 libold.so 时，如果采用如下方法：
rm libold.so       //如果内核正在使用libold.so，那么inode节点不会立刻别删除掉。
cp libnew.so libold.so
采用这种方法，目标文件 libold.so 的 inode 其实已经改变了，原来的 libold.so 文件虽然不能用&quot;ls&quot;查看到，但其inode并没有被真正删除，直到内核释放对它的引用。
</code></pre><p>（即: rm libold.so，此时，如果ld.so正在加在libold.so，内核就在引用libold.so的inode节点，rm libold.so的inode并没有被真正删除，当ld.so对libold.so的引用结束，inode才会真正删除。这样程序就不会崩溃，因为它还在使用旧的libold.so，当下次再使用libold.so时，已经被替换，就会使用新的libold.so）</p>
<pre><code>同理，mv只是改变了文件名，其 inode 不变，新文件使用了新的 inode。这样动态链接器 ld.so 仍然使用原来文件的 inode 访问旧的 so 文件。因而程序依然能正常运行。
</code></pre><p>(即: mv libold.so <em>*</em>后，如果程序使用动态库，还是使用旧的inode节点，当下次再使用libold.so时，就会使用新的libold.so)</p>
<pre><code>到这里，为什么直接使用“cp new_exec_file old_exec_file”这样的命令时，系统会禁止这样的操作，并且给出这样的提示“cp: cannot create regular file `old&#39;: Text file busy”。

这时，我们采用的办法仍然是用“rm+cp”或者“mv+cp”来替代直接“cp”，这跟以上提到的so文件的替换有同样的道理。
</code></pre><p>但是，为什么系统会阻止cp覆盖可执行程序，而不阻止覆盖so文件呢？</p>
<pre><code>这是因为 Linux 有个 Demand Paging 机制，所谓“Demand Paging”，简单的说，就是系统为了节约物理内存开销，并不会程序运行时就将所有页（page）都加载到内存中，而只有在系统有访问需求时才将其加载。“Demand Paging”要求正在运行中的程序镜像（注意，并非文件本身）不被意外修改，因此内核在启动程序后会锁定这个程序镜像的 inode。
</code></pre><p>对于 so 文件，它是靠 ld.so 加载的，而ld.so毕竟也是用户态程序，没有权利去锁定inode，也不应与内核的文件系统底层实现耦合。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>转载自：<a href="http://blog.163.com/xychenbaihu@yeah/blog/static/13222965520101023104745738/" target="_blank" rel="external">http://blog.163.com/xychenbaihu@yeah/blog/static/13222965520101023104745738/</a></p>
]]></content>
      
        <categories>
            
            <category> C语言 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言,编译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zmq学习第二章]]></title>
      <url>/2017/12/26/zmq_chapter2/</url>
      <content type="html"><![CDATA[<h2 id="第二章-ZeroMQ进阶"><a href="#第二章-ZeroMQ进阶" class="headerlink" title="第二章 ZeroMQ进阶"></a>第二章 ZeroMQ进阶</h2><p>第一章我们简单试用了ZMQ的若干通信模式：请求-应答模式、发布-订阅模式、管道模式。这一章我们将学习更多在实际开发中会使用到的东西：</p>
<p>本章涉及的内容有：</p>
<ul>
<li>创建和使用ZMQ套接字</li>
<li>使用套接字发送和接收消息</li>
<li>使用ZMQ提供的异步I/O套接字构建你的应用程序</li>
<li>在单一线程中使用多个套接字</li>
<li>恰当地处理致命和非致命错误</li>
<li>处理诸如Ctrl-C的中断信号</li>
<li>正确地关闭ZMQ应用程序</li>
<li>检查ZMQ应用程序的内存泄露</li>
<li>发送和接收多帧消息</li>
<li>在网络中转发消息</li>
<li>建立简单的消息队列代理</li>
<li>使用ZMQ编写多线程应用程序</li>
<li>使用ZMQ在线程间传递信号</li>
<li>使用ZMQ协调网络中的节点</li>
<li>使用标识创建持久化套接字</li>
<li>在发布-订阅模式中创建和使用消息信封</li>
<li>如何让持久化的订阅者能够从崩溃中恢复</li>
<li>使用阈值（HWM）防止内存溢出</li>
</ul>
<a id="more"></a>
<h3 id="零的哲学"><a href="#零的哲学" class="headerlink" title="零的哲学"></a>零的哲学</h3><p>ØMQ一词中的Ø让我们纠结了很久。一方面，这个特殊字符会降低ZMQ在谷歌和推特中的收录量；另一方面，这会惹恼某些丹麦语种的民族，他们会嚷道Ø并不是一个奇怪的0。</p>
<p>一开始ZMQ代表零中间件、零延迟，同时，它又有了新的含义：零管理、零成本、零浪费。总的来说，零表示最小、最简，这是贯穿于该项目的哲理。我们致力于减少复杂程度，提高易用性。</p>
<h3 id="套接字API"><a href="#套接字API" class="headerlink" title="套接字API"></a>套接字API</h3><p>说实话，ZMQ有些偷梁换柱的嫌疑。不过我们并不会为此道歉，因为这种概念上的切换绝对不会有坏处。ZMQ提供了一套类似于BSD套接字的API，但将很多消息处理机制的细节隐藏了起来，你会逐渐适应这种变化，并乐于用它进行编程。</p>
<p>套接字事实上是用于网络编程的标准接口，ZMQ之所那么吸引人眼球，原因之一就是它是建立在标准套接字API之上。因此，ZMQ的套接字操作非常容易理解，其生命周期主要包含四个部分：</p>
<ul>
<li>创建和销毁套接字：zmq_socket(), zmq_close()</li>
<li>配置和读取套接字选项：zmq_setsockopt(), zmq_getsockopt()</li>
<li>为套接字建立连接：zmq_bind(), zmq_connect()</li>
<li>发送和接收消息：zmq_send(), zmq_recv()</li>
</ul>
<p>如以下C代码：</p>
<pre><code class="c">void *mousetrap;

//  Create socket for catching mice
mousetrap = zmq_socket (context, ZMQ_PULL);

//  Configure the socket
int64_t jawsize = 10000;
zmq_setsockopt (mousetrap, ZMQ_HWM, &amp;jawsize, sizeof jawsize);

//  Plug socket into mouse hole
zmq_connect (mousetrap, &quot;tcp://192.168.55.221:5001&quot;);

//  Wait for juicy mouse to arrive
zmq_msg_t mouse;
zmq_msg_init (&amp;mouse);
zmq_recv (mousetrap, &amp;mouse, 0);
//  Destroy the mouse
zmq_msg_close (&amp;mouse);

//  Destroy the socket
zmq_close (mousetrap);
</code></pre>
<p>请注意，套接字永远是空指针类型的，而消息则是一个数据结构（我们下文会讲述）。所以，在C语言中你通过变量传递套接字，而用引用传递消息。记住一点，在ZMQ中所有的套接字都是由ZMQ管理的，只有消息是由程序员管理的。</p>
<p>创建、销毁、以及配置套接字的工作和处理一个对象差不多，但请记住ZMQ是异步的，伸缩性很强，因此在将其应用到网络结构中时，可能会需要多一些时间来理解。</p>
<h3 id="使用套接字构建拓扑结构"><a href="#使用套接字构建拓扑结构" class="headerlink" title="使用套接字构建拓扑结构"></a>使用套接字构建拓扑结构</h3><p>在连接两个节点时，其中一个需要使用zmq_bind()，另一个则使用zmq_connect()。通常来讲，使用zmq_bind()连接的节点称之为服务端，它有着一个较为固定的网络地址；使用zmq_connect()连接的节点称为客户端，其地址不固定。我们会有这样的说法：绑定套接字至端点；连接套接字至端点。端点指的是某个广为周知网络地址。</p>
<p>ZMQ连接和传统的TCP连接是有区别的，主要有：</p>
<ul>
<li>使用多种协议，inproc（进程内）、ipc（进程间）、tcp、pgm（广播）、epgm；</li>
<li>当客户端使用zmq_connect()时连接就已经建立了，并不要求该端点已有某个服务使用zmq_bind()进行了绑定；</li>
<li>连接是异步的，并由一组消息队列做缓冲；</li>
<li>连接会表现出某种消息模式，这是由创建连接的套接字类型决定的；</li>
<li>一个套接字可以有多个输入和输出连接；</li>
<li>ZMQ没有提供类似zmq_accept()的函数，因为当套接字绑定至端点时它就自动开始接受连接了；</li>
<li>应用程序无法直接和这些连接打交道，因为它们是被封装在ZMQ底层的。</li>
</ul>
<p>在很多架构中都使用了类似于C/S的架构。服务端组件式比较稳定的，而客户端组件则较为动态，来去自如。所以说，服务端地址对客户端而言往往是可见的，反之则不然。这样一来，架构中应该将哪些组件作为服务端（使用zmq_bind()），哪些作为客户端（使用zmq_connect()），就很明显了。同时，这需要和你使用的套接字类型相联系起来，我们下文会详细讲述。</p>
<p>让我们试想一下，如果先打开了客户端，后打开服务端，会发生什么？传统网络连接中，我们打开客户端时一定会收到系统的报错信息，但ZMQ让我们能够自由地启动架构中的组件。当客户端使用zmq_connect()连接至某个端点时，它就已经能够使用该套接字发送消息了。如果这时，服务端启动起来了，并使用zmq_bind()绑定至该端点，ZMQ将自动开始转发消息。</p>
<p>服务端节点可以仅使用一个套接字就能绑定至多个端点。也就是说，它能够使用不同的协议来建立连接：</p>
<pre><code class="c">zmq_bind (socket, &quot;tcp://*:5555&quot;);
zmq_bind (socket, &quot;tcp://*:9999&quot;);
zmq_bind (socket, &quot;ipc://myserver.ipc&quot;);
</code></pre>
<p>当然，你不能多次绑定至同一端点，这样是会报错的。</p>
<p>每当有客户端节点使用zmq_connect()连接至上述某个端点时，服务端就会自动创建连接。ZMQ没有对连接数量进行限制。此外，客户端节点也可以使用一个套接字同时建立多个连接。</p>
<p>大多数情况下，哪个节点充当服务端，哪个作为客户端，是网络架构层面的内容，而非消息流问题。不过也有一些特殊情况（如失去连接后的消息重发），同一种套接字使用绑定和连接是会有一些不同的行为的。</p>
<p>所以说，当我们在设计架构时，应该遵循“服务端是稳定的，客户端是灵活的“原则，这样就不太会出错。</p>
<p>套接字是有类型的，套接字类型定义了套接字的行为，它在发送和接收消息时的规则等。你可以将不同种类的套接字进行连接，如PUB-SUB组合，这种组合称之为发布-订阅模式，其他组合也会有相应的模式名称，我们会在下文详述。</p>
<p>正是因为套接字可以使用不同的方式进行连接，才构成了ZMQ最基本的消息队列系统。我们还可以在此基础之上建立更为复杂的装置、路由机制等，下文会详述。总的来说，ZMQ为你提供了一套组件，供你在网络架构中拼装和使用。</p>
<h3 id="使用套接字传递数据"><a href="#使用套接字传递数据" class="headerlink" title="使用套接字传递数据"></a>使用套接字传递数据</h3><p>发送和接收消息使用的是zmq_send()和zmq_recv()这两个函数。虽然函数名称看起来很直白，但由于ZMQ的I/O模式和传统的TCP协议有很大不同，因此还是需要花点时间去理解的。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_1.png" alt="1"></p>
<p>让我们看一看TCP套接字和ZMQ套接字之间在传输数据方面的区别：</p>
<ul>
<li>ZMQ套接字传输的是消息，而不是字节（TCP）或帧（UDP）。消息指的是一段指定长度的二进制数据块，我们下文会讲到消息，这种设计是为了性能优化而考虑的，所以可能会比较难以理解。</li>
<li>ZMQ套接字在后台进行I/O操作，也就是说无论是接收还是发送消息，它都会先传送到一个本地的缓冲队列，这个内存队列的大小是可以配置的。</li>
<li>ZMQ套接字可以和多个套接字进行连接（如果套接字类型允许的话）。TCP协议只能进行点对点的连接，而ZMQ则可以进行一对多（类似于无线广播）、多对多（类似于邮局）、多对一（类似于信箱），当然也包括一对一的情况。</li>
<li>ZMQ套接字可以发送消息给多个端点（扇出模型），或从多个端点中接收消息（扇入模型）</li>
</ul>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_2.png" alt="2"></p>
<p>所以，向套接字写入一个消息时可能会将消息发送给很多节点，相应的，套接字又会从所有已建立的连接中接收消息。zmq_recv()方法使用了公平队列的算法来决定接收哪个连接的消息。</p>
<p>调用zmq_send()方法时其实并没有真正将消息发送给套接字连接。消息会在一个内存队列中保存下来，并由后台的I/O线程异步地进行发送。如果不出意外情况，这一行为是非阻塞的。所以说，即便zmq_send()有返回值，并不能代表消息已经发送。当你在用zmq_msg_init_data()初始化消息后，你不能重用或是释放这条消息，否则ZMQ的I/O线程会认为它在传输垃圾数据。这对初学者来讲是一个常犯的错误，下文我们会讲述如何正确地处理消息。</p>
<h3 id="单播传输"><a href="#单播传输" class="headerlink" title="单播传输"></a>单播传输</h3><p>ZMQ提供了一组单播传输协议（inporc, ipc, tcp），和两个广播协议（epgm, pgm）。广播协议是比较高级的协议，我们会在以后讲述。如果你不能回答我扇出比例会影响一对多的单播传输时，就先不要去学习广播协议了吧。</p>
<p>一般而言我们会使用<strong>tcp</strong>作为传输协议，这种TCP连接是可以脱机运作的，它灵活、便携、且足够快速。为什么称之为脱机，是因为ZMQ中的TCP连接不需要该端点已经有某个服务进行了绑定，客户端和服务端可以随时进行连接和绑定，这对应用程序而言都是透明的。</p>
<p>进程间协议，即<strong>ipc</strong>，和tcp的行为差不多，但已从网络传输中抽象出来，不需要指定IP地址或者域名。这种协议很多时候会很方便，本指南中的很多示例都会使用这种协议。ZMQ中的ipc协议同样可以是脱机的，但有一个缺点——无法在Windows操作系统上运作，这一点也许会在未来的ZMQ版本中修复。我们一般会在端点名称的末尾附上.ipc的扩展名，在UNIX系统上，使用ipc协议还需要注意权限问题。你还需要保证所有的程序都能够找到这个ipc端点。</p>
<p>进程内协议，即<strong>inproc</strong>，可以在同一个进程的不同线程之间进行消息传输，它比ipc或tcp要快得多。这种协议有一个要求，必须先绑定到端点，才能建立连接，也许未来也会修复。通常的做法是先启动服务端线程，绑定至端点，后启动客户端线程，连接至端点。</p>
<h3 id="ZMQ不只是数据传输"><a href="#ZMQ不只是数据传输" class="headerlink" title="ZMQ不只是数据传输"></a>ZMQ不只是数据传输</h3><p>经常有新人会问，如何使用ZMQ建立一项服务？我能使用ZMQ建立一个HTTP服务器吗？</p>
<p>他们期望得到的回答是，我们用普通的套接字来传输HTTP请求和应答，那用ZMQ套接字也能够完成这个任务，且能运行得更快、更好。</p>
<p>只可惜答案并不是这样的。ZMQ不只是一个数据传输的工具，而是在现有通信协议之上建立起来的新架构。它的数据帧和现有的协议并不兼容，如下面是一个HTTP请求和ZMQ请求的对比，同样使用的是TCP/IPC协议：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_3.png" alt="3"></p>
<p>HTTP请求使用CR-LF（换行符）作为信息帧的间隔，而ZMQ则使用指定长度来定义帧：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_4.png" alt="4"></p>
<p>所以说，你的确是可以用ZMQ来写一个类似于HTTP协议的东西，但是这并不是HTTP。</p>
<p>不过，如果有人问我如何更好地使用ZMQ建立一个新的服务，我会给出一个不错的答案，那就是：你可以自行设计一种通信协议，用ZMQ进行连接，使用不同的语言提供服务和扩展，可以在本地，亦可通过远程传输。赛德•肖的<a href="http://www.mongrel2.org" target="_blank" rel="external">Mongrel2</a>网络服务的架构就是一个很好的示例。</p>
<h3 id="I-O线程"><a href="#I-O线程" class="headerlink" title="I/O线程"></a>I/O线程</h3><p>我们提过ZMQ是通过后台的I/O线程进行消息传输的。一个I/O线程已经足以处理多个套接字的数据传输要求，当然，那些极端的应用程序除外。这也就是我们在创建上下文时传入的1所代表的意思：</p>
<pre><code class="c">void *context = zmq_init (1);
</code></pre>
<p>ZMQ应用程序和传统应用程序的区别之一就是你不需要为每个套接字都创建一个连接。单个ZMQ套接字可以处理所有的发送和接收任务。如，当你需要向一千个订阅者发布消息时，使用一个套接字就可以了；当你需要向二十个服务进程分发任务时，使用一个套接字就可以了；当你需要从一千个网页应用程序中获取数据时，也是使用一个套接字就可以了。</p>
<p>这一特性可能会颠覆网络应用程序的编写步骤，传统应用程序每个进程或线程会有一个远程连接，它又只能处理一个套接字。ZMQ让你打破这种结构，使用一个线程来完成所有工作，更易于扩展。</p>
<h3 id="核心消息模式"><a href="#核心消息模式" class="headerlink" title="核心消息模式"></a>核心消息模式</h3><p>ZMQ的套接字API中提供了多种消息模式。如果你熟悉企业级消息应用，那这些模式会看起来很熟悉。不过对于新手来说，ZMQ的套接字还是会让人大吃一惊的。</p>
<p>让我们回顾一下ZMQ会为你做些什么：它会将消息快速高效地发送给其他节点，这里的节点可以是线程、进程、或是其他计算机；ZMQ为应用程序提供了一套简单的套接字API，不用考虑实际使用的协议类型（进程内、进程间、TPC、或广播）；当节点调动时，ZMQ会自动进行连接或重连；无论是发送消息还是接收消息，ZMQ都会先将消息放入队列中，并保证进程不会因为内存溢出而崩溃，适时地将消息写入磁盘；ZMQ会处理套接字异常；所有的I/O操作都在后台进行；ZMQ不会产生死锁。</p>
<p>但是，以上种种的前提是用户能够正确地使用消息模式，这种模式往往也体现出了ZMQ的智慧。消息模式将我们从实践中获取的经验进行抽象和重组，用于解决之后遇到的所有问题。ZMQ的消息模式目前是编译在类库中的，不过未来的ZMQ版本可能会允许用户自行制定消息模式。</p>
<p>ZMQ的消息模式是指不同类型套接字的组合。换句话说，要理解ZMQ的消息模式，你需要理解ZMQ的套接字类型，它们是如何一起工作的。这一部分是需要死记硬背的。</p>
<p>ZMQ的核心消息模式有：</p>
<ul>
<li><p><strong>请求-应答模式</strong> 将一组服务端和一组客户端相连，用于远程过程调用或任务分发。</p>
</li>
<li><p><strong>发布-订阅模式</strong> 将一组发布者和一组订阅者相连，用于数据分发。</p>
</li>
<li><p><strong>管道模式</strong> 使用扇入或扇出的形式组装多个节点，可以产生多个步骤或循环，用于构建并行处理架构。</p>
</li>
</ul>
<p>我们在第一章中已经讲述了这些模式，不过还有一种模式是为那些仍然认为ZMQ是类似TCP那样点对点连接的人们准备的：</p>
<ul>
<li><strong>排他对接模式</strong> 将两个套接字一对一地连接起来，这种模式应用场景很少，我们会在本章最末尾看到一个示例。</li>
</ul>
<p>zmq_socket()函数的说明页中有对所有消息模式的说明，比较清楚，因此值得研读几次。我们会介绍每种消息模式的内容和应用场景。</p>
<p>以下是合法的套接字连接-绑定对（一端绑定、一端连接即可）：</p>
<ul>
<li>PUB - SUB</li>
<li>REQ - REP</li>
<li>REQ - ROUTER</li>
<li>DEALER - REP</li>
<li>DEALER - ROUTER</li>
<li>DEALER - DEALER</li>
<li>ROUTER - ROUTER</li>
<li>PUSH - PULL</li>
<li>PAIR - PAIR</li>
</ul>
<p>其他的组合模式会产生不可预知的结果，在将来的ZMQ版本中可能会直接返回错误。你也可以通过代码去了解这些套接字类型的行为。</p>
<h3 id="上层消息模式"><a href="#上层消息模式" class="headerlink" title="上层消息模式"></a>上层消息模式</h3><p>上文中的四种核心消息模式是内建在ZMQ中的，他们是API的一部分，在ZMQ的C++核心类库中实现，能够保证正确地运行。如果有朝一日Linux内核将ZMQ采纳了进来，那这些核心模式也肯定会包含其中。</p>
<p>在这些消息模式之上，我们会建立更为<em>上层的消息模式</em>。这种模式可以用任何语言编写，他们不属于核心类型的一部分，不随ZMQ发行，只在你自己的应用程序中出现，或者在ZMQ社区中维护。</p>
<p>本指南的目的之一就是为你提供一些上层的消息模式，有简单的（如何正确处理消息），也有复杂的（可靠的发布-订阅模式）。</p>
<h3 id="消息的使用方法"><a href="#消息的使用方法" class="headerlink" title="消息的使用方法"></a>消息的使用方法</h3><p>ZMQ的传输单位是消息，即一个二进制块。你可以使用任意的序列化工具，如谷歌的Protocal Buffers、XDR、JSON等，将内容转化成ZMQ消息。不过这种转化工具最好是便捷和快速的，这个请自己衡量。</p>
<p>在内存中，ZMQ消息由zmq_msg_t结构表示（每种语言有特定的表示）。在C语言中使用ZMQ消息时需要注意以下几点：</p>
<ul>
<li>你需要创建和传递zmq_msg_t对象，而不是一组数据块；</li>
<li>读取消息时，先用zmq_msg_init()初始化一个空消息，再将其传递给zmq_recv()函数；</li>
<li>写入消息时，先用zmq_msg_init_size()来创建消息（同时也已初始化了一块内存区域），然后用memcpy()函数将信息拷贝到该对象中，最后传给zmq_send()函数；</li>
<li>释放消息（并不是销毁）时，使用zmq_msg_close()函数，它会将对消息对象的引用删除，最终由ZMQ将消息销毁；</li>
<li>获取消息内容时需使用zmq_msg_data()函数；若想知道消息的长度，可以使用zmq_msg_size()函数；</li>
<li>至于zmq_msg_move()、zmq_msg_copy()、zmq_msg_init_data()函数，在充分理解手册中的说明之前，建议不好贸然使用。</li>
</ul>
<p>以下是一段处理消息的典型代码，如果之前的代码你有看的话，那应该会感到熟悉。这段代码其实是从zhelpers.h文件中抽出的：</p>
<pre><code class="c">//  从套接字中获取ZMQ字符串，并转换为C语言字符串
static char *
s_recv (void *socket) {
    zmq_msg_t message;
    zmq_msg_init (&amp;message);
    zmq_recv (socket, &amp;message, 0);
    int size = zmq_msg_size (&amp;message);
    char *string = malloc (size + 1);
    memcpy (string, zmq_msg_data (&amp;message), size);
    zmq_msg_close (&amp;message);
    string [size] = 0;
    return (string);
}

//  将C语言字符串转换为ZMQ字符串，并发送给套接字
static int
s_send (void *socket, char *string) {
    int rc;
    zmq_msg_t message;
    zmq_msg_init_size (&amp;message, strlen (string));
    memcpy (zmq_msg_data (&amp;message), string, strlen (string));
    rc = zmq_send (socket, &amp;message, 0);
    assert (!rc);
    zmq_msg_close (&amp;message);
    return (rc);
}
</code></pre>
<p>你可以对以上代码进行扩展，让其支持发送和接受任一长度的数据。</p>
<p><strong>需要注意的是，当你将一个消息对象传递给zmq_send()函数后，该对象的长度就会被清零，因此你无法发送同一个消息对象两次，也无法获得已发送消息的内容。</strong></p>
<p>如果你想发送同一个消息对象两次，就需要在发送第一次前新建一个对象，使用zmq_msg_copy()函数进行拷贝。这个函数不会拷贝消息内容，只是拷贝引用。然后你就可以再次发送这个消息了（或者任意多次，只要进行了足够的拷贝）。当消息最后一个引用被释放时，消息对象就会被销毁。</p>
<p>ZMQ支持多帧消息，即在一条消息中保存多个消息帧。这在实际应用中被广泛使用，我们会在第三章进行讲解。</p>
<p>关于消息，还有一些需要注意的地方：</p>
<ul>
<li>ZMQ的消息是作为一个整体来收发的，你不会只收到消息的一部分；</li>
<li>ZMQ不会立即发送消息，而是有一定的延迟；</li>
<li>你可以发送0字节长度的消息，作为一种信号；</li>
<li>消息必须能够在内存中保存，如果你想发送文件或超长的消息，就需要将他们切割成小块，在独立的消息中进行发送；</li>
<li>必须使用zmq_msg_close()函数来关闭消息，但在一些会在变量超出作用域时自动释放消息对象的语言中除外。</li>
</ul>
<p>再重复一句，不要贸然使用zmq_msg_init_data()函数。它是用于零拷贝，而且可能会造成麻烦。关于ZMQ还有太多东西需要你去学习，因此现在暂时不用去考虑如何削减几微秒的开销。</p>
<h3 id="处理多个套接字"><a href="#处理多个套接字" class="headerlink" title="处理多个套接字"></a>处理多个套接字</h3><p>在之前的示例中，主程序的循环体内会做以下几件事：</p>
<ol>
<li>等待套接字的消息；</li>
<li>处理消息；</li>
<li>返回第一步。</li>
</ol>
<p>如果我们想要读取多个套接字中的消息呢？最简单的方法是将套接字连接到多个端点上，让ZMQ使用公平队列的机制来接受消息。如果不同端点上的套接字类型是一致的，那可以使用这种方法。但是，如果一个套接字的类型是PULL，另一个是PUB怎么办？如果现在开始混用套接字类型，那将来就没有可靠性可言了。</p>
<p>正确的方法应该是使用zmq_poll()函数。更好的方法是将zmq_poll()包装成一个框架，编写一个事件驱动的反应器，但这个就比较复杂了，我们这里暂不讨论。</p>
<p>我们先不使用zmq_poll()，而用NOBLOCK（非阻塞）的方式来实现从多个套接字读取消息的功能。下面将气象信息服务和并行处理这两个示例结合起来：</p>
<p><strong>msreader: Multiple socket reader in C</strong></p>
<pre><code class="c">//
//  从多个套接字中获取消息
//  本示例简单地再循环中使用recv函数
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    //  准备上下文和套接字
    void *context = zmq_init (1);

    //  连接至任务分发器
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, &quot;tcp://localhost:5557&quot;);

    //  连接至天气服务
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, &quot;tcp://localhost:5556&quot;);
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, &quot;10001 &quot;, 6);

    //  处理从两个套接字中接收到的消息
    //  这里我们会优先处理从任务分发器接收到的消息
    while (1) {
        //  处理等待中的任务
        int rc;
        for (rc = 0; !rc; ) {
            zmq_msg_t task;
            zmq_msg_init (&amp;task);
            if ((rc = zmq_recv (receiver, &amp;task, ZMQ_NOBLOCK)) == 0) {
                //  处理任务
            }
            zmq_msg_close (&amp;task);
        }
        //  处理等待中的气象更新
        for (rc = 0; !rc; ) {
            zmq_msg_t update;
            zmq_msg_init (&amp;update);
            if ((rc = zmq_recv (subscriber, &amp;update, ZMQ_NOBLOCK)) == 0) {
                //  处理气象更新
            }
            zmq_msg_close (&amp;update);
        }
        // 没有消息，等待1毫秒
        s_sleep (1);
    }
    //  程序不会运行到这里，但还是做正确的退出清理工作
    zmq_close (receiver);
    zmq_close (subscriber);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这种方式的缺点之一是，在收到第一条消息之前会有1毫秒的延迟，这在高压力的程序中还是会构成问题的。此外，你还需要翻阅诸如nanosleep()的函数，不会造成循环次数的激增。</p>
<p>示例中将任务分发器的优先级提升了，你可以做一个改进，轮流处理消息，正如ZMQ内部做的公平队列机制一样。</p>
<p>下面，让我们看看如何用zmq_poll()来实现同样的功能：</p>
<p><strong>mspoller: Multiple socket poller in C</strong></p>
<pre><code class="c">//
//  从多个套接字中接收消息
//  本例使用zmq_poll()函数
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  连接任务分发器
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, &quot;tcp://localhost:5557&quot;);

    //  连接气象更新服务
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, &quot;tcp://localhost:5556&quot;);
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, &quot;10001 &quot;, 6);

    //  初始化轮询对象
    zmq_pollitem_t items [] = {
        { receiver, 0, ZMQ_POLLIN, 0 },
        { subscriber, 0, ZMQ_POLLIN, 0 }
    };
    //  处理来自两个套接字的消息
    while (1) {
        zmq_msg_t message;
        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_recv (receiver, &amp;message, 0);
            //  处理任务
            zmq_msg_close (&amp;message);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_recv (subscriber, &amp;message, 0);
            //  处理气象更新
            zmq_msg_close (&amp;message);
        }
    }
    //  程序不会运行到这儿
    zmq_close (receiver);
    zmq_close (subscriber);
    zmq_term (context);
    return 0;
}
</code></pre>
<h3 id="处理错误和ETERM信号"><a href="#处理错误和ETERM信号" class="headerlink" title="处理错误和ETERM信号"></a>处理错误和ETERM信号</h3><p>ZMQ的错误处理机制提倡的是快速崩溃。我们认为，一个进程对于自身内部的错误来说要越脆弱越好，而对外部的攻击和错误要足够健壮。举个例子，活细胞会因检测到自身问题而瓦解，但对外界的攻击却能极力抵抗。在ZMQ编程中，断言用得是非常多的，如同细胞膜一样。如果我们无法确定一个错误是来自于内部还是外部，那这就是一个设计缺陷了，需要修复。</p>
<p>在C语言中，断言失败会让程序立即中止。其他语言中可以使用异常来做到。</p>
<p>当ZMQ检测到来自外部的问题时，它会返回一个错误给调用程序。如果ZMQ不能从错误中恢复，那它是不会安静地将消息丢弃的。某些情况下，ZMQ也会去断言外部错误，这些可以被归结为BUG。</p>
<p>到目前为止，我们很少看到C语言的示例中有对错误进行处理。<strong>现实中的代码应该对每一次的ZMQ函数调用作错误处理</strong>。如果你不是使用C语言进行编程，可能那种语言的ZMQ类库已经做了错误处理。但在C语言中，你需要自己动手。以下是一些常规的错误处理手段，从POSIX规范开始：</p>
<ul>
<li>创建对象的方法如果失败了会返回NULL；</li>
<li>其他方法执行成功时会返回0，失败时会返回其他值（一般是-1）；</li>
<li>错误代码可以从变量errno中获得，或者调用zmq_errno()函数；</li>
<li>错误消息可以调用zmq_strerror()函数获得。</li>
</ul>
<p>有两种情况不应该被认为是错误：</p>
<ul>
<li>当线程使用NOBLOCK方式调用zmq_recv()时，若没有接收到消息，该方法会返回-1，并设置errno为EAGAIN；</li>
<li>当线程调用zmq_term()时，若其他线程正在进行阻塞式的处理，该函数会中止所有的处理，关闭套接字，并使得那些阻塞方法的返回值为-1，errno设置为ETERM。</li>
</ul>
<p>遵循以上规则，你就可以在ZMQ程序中使用断言了：</p>
<pre><code class="c">void *context = zmq_init (1);
assert (context);
void *socket = zmq_socket (context, ZMQ_REP);
assert (socket);
int rc;
rc = zmq_bind (socket, &quot;tcp://*:5555&quot;);
assert (rc == 0);
</code></pre>
<p>第一版的程序中我将函数调用直接放在了assert()函数里面，这样做会有问题，因为一些优化程序会直接将程序中的assert()函数去除。</p>
<p>让我们看看如何正确地关闭一个进程，我们用管道模式举例。当我们在后台开启了一组worker时，我们需要在任务执行完毕后关闭它们。我们可以向这些worker发送自杀的消息，这项工作由结果收集器来完成会比较恰当。</p>
<p>如何将结果收集器和worker相连呢？PUSH-PULL套接字是单向的。ZMQ的原则是：如果需要解决一个新的问题，就该使用新的套接字。这里我们使用发布-订阅模式来发送自杀的消息：</p>
<ul>
<li>结果收集器创建PUB套接字，并连接至一个新的端点；</li>
<li>worker将SUB套接字连接至这个端点；</li>
<li>当结果收集器检测到任务执行完毕时，会通过PUB套接字发送自杀信号；</li>
<li>worker收到自杀信号后便会中止。</li>
</ul>
<p>这一过程不会添加太多的代码：</p>
<pre><code class="c">    void *control = zmq_socket (context, ZMQ_PUB);
    zmq_bind (control, &quot;tcp://*:5559&quot;);
    ...
    //  Send kill signal to workers
    zmq_msg_init_data (&amp;message, &quot;KILL&quot;, 5);
    zmq_send (control, &amp;message, 0);
    zmq_msg_close (&amp;message);
</code></pre>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_5.png" alt="5"></p>
<p>下面是worker进程的代码，它会打开三个套接字：用于接收任务的PULL、用于发送结果的PUSH、以及用于接收自杀信号的SUB，使用zmq_poll()进行轮询：</p>
<p><strong>taskwork2: Parallel task worker with kill signaling in C</strong></p>
<pre><code class="c">//
//  管道模式 - worker 设计2
//  添加发布-订阅消息流，用以接收自杀消息
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  用于接收消息的套接字
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, &quot;tcp://localhost:5557&quot;);

    //  用户发送消息的套接字
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sender, &quot;tcp://localhost:5558&quot;);

    //  用户接收控制消息的套接字
    void *controller = zmq_socket (context, ZMQ_SUB);
    zmq_connect (controller, &quot;tcp://localhost:5559&quot;);
    zmq_setsockopt (controller, ZMQ_SUBSCRIBE, &quot;&quot;, 0);

    //  处理接收到的任务或控制消息
    zmq_pollitem_t items [] = {
        { receiver, 0, ZMQ_POLLIN, 0 },
        { controller, 0, ZMQ_POLLIN, 0 }
    };
    //  处理消息
    while (1) {
        zmq_msg_t message;
        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmq_msg_init (&amp;message);
            zmq_recv (receiver, &amp;message, 0);

            //  工作
            s_sleep (atoi ((char *) zmq_msg_data (&amp;message)));

            //  发送结果
            zmq_msg_init (&amp;message);
            zmq_send (sender, &amp;message, 0);

            //  简单的任务进图指示
            printf (&quot;.&quot;);
            fflush (stdout);

            zmq_msg_close (&amp;message);
        }
        //  任何控制命令都表示自杀
        if (items [1].revents &amp; ZMQ_POLLIN)
            break;                      //  退出循环
    }
    //  结束程序
    zmq_close (receiver);
    zmq_close (sender);
    zmq_close (controller);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>下面是修改后的结果收集器代码，在收集完结果后向所有worker发送自杀消息：</p>
<p><strong>tasksink2: Parallel task sink with kill signaling in C</strong></p>
<pre><code class="c">//
//  管道模式 - 结构收集器 设计2
//  添加发布-订阅消息流，用以向worker发送自杀信号
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  用于接收消息的套接字
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_bind (receiver, &quot;tcp://*:5558&quot;);

    //  用以发送控制信息的套接字
    void *controller = zmq_socket (context, ZMQ_PUB);
    zmq_bind (controller, &quot;tcp://*:5559&quot;);

    //  等待任务开始
    char *string = s_recv (receiver);
    free (string);

    //  开始计时
    int64_t start_time = s_clock ();

    //  确认100个任务处理完毕
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        char *string = s_recv (receiver);
        free (string);
        if ((task_nbr / 10) * 10 == task_nbr)
            printf (&quot;:&quot;);
        else
            printf (&quot;.&quot;);
        fflush (stdout);
    }
    printf (&quot;总执行时间: %d msec\n&quot;, 
        (int) (s_clock () - start_time));

    //  发送自杀消息给worker
    s_send (controller, &quot;KILL&quot;);

    //  结束
    sleep (1);              //  等待发送完毕

    zmq_close (receiver);
    zmq_close (controller);
    zmq_term (context);
    return 0;
}
</code></pre>
<h3 id="处理中断信号"><a href="#处理中断信号" class="headerlink" title="处理中断信号"></a>处理中断信号</h3><p>现实环境中，当应用程序收到Ctrl-C或其他诸如ETERM的信号时需要能够正确地清理和退出。默认情况下，这一信号会杀掉进程，意味着尚未发送的消息就此丢失，文件不能被正确地关闭等。</p>
<p>在C语言中我们是这样处理消息的：</p>
<p><strong>interrupt: Handling Ctrl-C cleanly in C</strong></p>
<pre><code class="c">//
//  Shows how to handle Ctrl-C
//
#include &lt;zmq.h&gt;
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

//  ---------------------------------------------------------------------
//  消息处理
//
//  程序开始运行时调用s_catch_signals()函数；
//  在循环中判断s_interrupted是否为1，是则跳出循环；
//  很适用于zmq_poll()。

static int s_interrupted = 0;
static void s_signal_handler (int signal_value)
{
    s_interrupted = 1;
}

static void s_catch_signals (void)
{
    struct sigaction action;
    action.sa_handler = s_signal_handler;
    action.sa_flags = 0;
    sigemptyset (&amp;action.sa_mask);
    sigaction (SIGINT, &amp;action, NULL);
    sigaction (SIGTERM, &amp;action, NULL);
}

int main (void)
{
    void *context = zmq_init (1);
    void *socket = zmq_socket (context, ZMQ_REP);
    zmq_bind (socket, &quot;tcp://*:5555&quot;);

    s_catch_signals ();
    while (1) {
        //  阻塞式的读取会在收到信号时停止
        zmq_msg_t message;
        zmq_msg_init (&amp;message);
        zmq_recv (socket, &amp;message, 0);

        if (s_interrupted) {
            printf (&quot;W: 收到中断消息，程序中止...\n&quot;);
            break;
        }
    }
    zmq_close (socket);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这段程序使用s_catch_signals()函数来捕捉像Ctrl-C(SIGINT)和SIGTERM这样的信号。收到任一信号后，该函数会将全局变量s_interrupted设置为1。你的程序并不会自动停止，需要显式地做一些清理和退出工作。</p>
<ul>
<li>在程序开始时调用s_catch_signals()函数，用来进行信号捕捉的设置；</li>
<li>如果程序在zmq_recv()、zmq_poll()、zmq_send()等函数中阻塞，当有信号传来时，这些函数会返回EINTR；</li>
<li>像s_recv()这样的函数会将这种中断包装为NULL返回；</li>
<li>所以，你的应用程序可以检查是否有EINTR错误码、或是NULL的返回、或者s_interrupted变量是否为1。</li>
</ul>
<p>如果以下代码就十分典型：</p>
<pre><code class="c">s_catch_signals ();
client = zmq_socket (...);
while (!s_interrupted) {
    char *message = s_recv (client);
    if (!message)
        break;          //  按下了Ctrl-C
}
zmq_close (client);
</code></pre>
<p>如果你在设置s_catch_signals()之后没有进行相应的处理，那么你的程序将对Ctrl-C和ETERM免疫。</p>
<h3 id="检测内存泄露"><a href="#检测内存泄露" class="headerlink" title="检测内存泄露"></a>检测内存泄露</h3><p>任何长时间运行的程序都应该妥善的管理内存，否则最终会发生内存溢出，导致程序崩溃。如果你所使用的编程序言会自动帮你完成内存管理，那就要恭喜你了。但若你使用类似C/C++之类的语言时，就需要自己动手进行内存管理了。下面会介绍一个名为valgrind的工具，可以用它来报告内存泄露的问题。</p>
<ul>
<li><p>在Ubuntu或Debian操作系统上安装valgrind：sudo apt-get install valgrind</p>
</li>
<li><p>缺省情况下，ZMQ会让valgrind不停地报错，想要屏蔽警告的话可以在编译ZMQ时使用ZMQ_MAKE_VALGRIND_HAPPY宏选项：</p>
</li>
</ul>
<pre><code>$ cd zeromq2
$ export CPPFLAGS=-DZMQ_MAKE_VALGRIND_HAPPY
$ ./configure
$ make clean; make
$ sudo make install
</code></pre><ul>
<li><p>应用程序应该正确地处理Ctrl-C，特别是对于长时间运行的程序（如队列装置），如果不这么做，valgrind会报告所有已分配的内存发生了错误。</p>
</li>
<li><p>使用-DDEBUG选项编译程序，这样可以让valgrind告诉你具体是哪段代码发生了内存溢出。</p>
</li>
<li><p>最后，使用如下方法运行valgrind：</p>
</li>
</ul>
<pre><code>valgrind --tool=memcheck --leak-check=full someprog
</code></pre><p>解决完所有的问题后，你会看到以下信息：</p>
<pre><code>==30536== ERROR SUMMARY: 0 errors from 0 contexts...
</code></pre><h3 id="多帧消息"><a href="#多帧消息" class="headerlink" title="多帧消息"></a>多帧消息</h3><p>ZMQ消息可以包含多个帧，这在实际应用中非常常见，特别是那些有关“信封”的应用，我们下文会谈到。我们这一节要讲的是如何正确地收发多帧消息。</p>
<p>多帧消息的每一帧都是一个zmq_msg结构，也就是说，当你在收发含有五个帧的消息时，你需要处理五个zmq_msg结构。你可以将这些帧放入一个数据结构中，或者直接一个个地处理它们。</p>
<p>下面的代码演示如何发送多帧消息：</p>
<pre><code class="c">zmq_send (socket, &amp;message, ZMQ_SNDMORE);
...
zmq_send (socket, &amp;message, ZMQ_SNDMORE);
...
zmq_send (socket, &amp;message, 0);
</code></pre>
<p>然后我们看看如何接收并处理这些消息，这段代码对单帧消息和多帧消息都适用：</p>
<pre><code class="c">while (1) {
    zmq_msg_t message;
    zmq_msg_init (&amp;message);
    zmq_recv (socket, &amp;message, 0);
    // 处理一帧消息
    zmq_msg_close (&amp;message);
    int64_t more;
    size_t more_size = sizeof (more);
    zmq_getsockopt (socket, ZMQ_RCVMORE, &amp;more, &amp;more_size);
    if (!more)
        break; // 已到达最后一帧
}
</code></pre>
<p>关于多帧消息，你需要了解的还有：</p>
<ul>
<li>在发送多帧消息时，只有当最后一帧提交发送了，整个消息才会被发送；</li>
<li>如果使用了zmq_poll()函数，当收到了消息的第一帧时，其它帧其实也已经收到了；</li>
<li>多帧消息是整体传输的，不会只收到一部分；</li>
<li>多帧消息的每一帧都是一个zmq_msg结构；</li>
<li>无论你是否检查套接字的ZMQ_RCVMORE选项，你都会收到所有的消息；</li>
<li>发送时，ZMQ会将开始的消息帧缓存在内存中，直到收到最后一帧才会发送；</li>
<li>我们无法在发送了一部分消息后取消发送，只能关闭该套接字。</li>
</ul>
<h3 id="中间件和装置"><a href="#中间件和装置" class="headerlink" title="中间件和装置"></a>中间件和装置</h3><p>当网络组件的数量较少时，所有节点都知道其它节点的存在。但随着节点数量的增加，这种结构的成本也会上升。因此，我们需要将这些组件拆分成更小的模块，使用一个中间件来连接它们。</p>
<p>这种结构在现实世界中是非常常见的，我们的社会和经济体系中充满了中间件的机制，用以降低复杂度，压缩构建大型网络的成本。中间件也会被称为批发商、分包商、管理者等等。</p>
<p>ZMQ网络也是一样，如果规模不断增长，就一定会需要中间件。ZMQ中，我们称其为“装置”。在构建ZMQ软件的初期，我们会画出几个节点，然后将它们连接起来，不使用中间件：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_6.png" alt="6"></p>
<p>随后，我们对这个结构不断地进行扩充，将装置放到特定的位置，进一步增加节点数量：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_7.png" alt="7"></p>
<p>ZMQ装置没有具体的设计规则，但一般会有一组“前端”端点和一组“后端”端点。装置是无状态的，因此可以被广泛地部署在网络中。你可以在进程中启动一个线程来运行装置，或者直接在一个进程中运行装置。ZMQ内部也提供了基本的装置实现可供使用。</p>
<p>ZMQ装置可以用作路由和寻址、提供服务、队列调度、以及其他你所能想到的事情。不同的消息模式需要用到不同类型的装置来构建网络。如，请求-应答模式中可以使用队列装置、抽象服务；发布-订阅模式中则可使用流装置、主题装置等。</p>
<p>ZMQ装置比起其他中间件的优势在于，你可以将它放在网络中任何一个地方，完成任何你想要的事情。</p>
<h4 id="发布-订阅代理服务"><a href="#发布-订阅代理服务" class="headerlink" title="发布-订阅代理服务"></a>发布-订阅代理服务</h4><p>我们经常会需要将发布-订阅模式扩充到不同类型的网络中。比如说，有一组订阅者是在外网上的，我们想用广播的方式发布消息给内网的订阅者，而用TCP协议发送给外网订阅者。</p>
<p>我们要做的就是写一个简单的代理服务装置，在发布者和外网订阅者之间搭起桥梁。这个装置有两个端点，一端连接内网上的发布者，另一端连接到外网上。它会从发布者处接收订阅的消息，并转发给外网上的订阅者们。</p>
<p><strong>wuproxy: Weather update proxy in C</strong></p>
<pre><code class="c">//
//  气象信息代理服务装置
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    void *context = zmq_init (1);

    //  订阅气象信息
    void *frontend = zmq_socket (context, ZMQ_SUB);
    zmq_connect (frontend, &quot;tcp://192.168.55.210:5556&quot;);

    //  转发气象信息
    void *backend = zmq_socket (context, ZMQ_PUB);
    zmq_bind (backend, &quot;tcp://10.1.1.0:8100&quot;);

    //  订阅所有消息
    zmq_setsockopt (frontend, ZMQ_SUBSCRIBE, &quot;&quot;, 0);

    //  转发消息
    while (1) {
        while (1) {
            zmq_msg_t message;
            int64_t more;

            //  处理所有的消息帧
            zmq_msg_init (&amp;message);
            zmq_recv (frontend, &amp;message, 0);
            size_t more_size = sizeof (more);
            zmq_getsockopt (frontend, ZMQ_RCVMORE, &amp;more, &amp;more_size);
            zmq_send (backend, &amp;message, more? ZMQ_SNDMORE: 0);
            zmq_msg_close (&amp;message);
            if (!more)
                break;      //  到达最后一帧
        }
    }
    //  程序不会运行到这里，但依然要正确地退出
    zmq_close (frontend);
    zmq_close (backend);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>我们称这个装置为代理，因为它既是订阅者，又是发布者。这就意味着，添加该装置时不需要更改其他程序的代码，只需让外网订阅者知道新的网络地址即可。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_8.png" alt="8"></p>
<p>可以注意到，这段程序能够正确处理多帧消息，会将它完整的转发给订阅者。如果我们在发送时不指定ZMQ_SNDMORE选项，那么下游节点收到的消息就可能是破损的。编写装置时应该要保证能够正确地处理多帧消息，否则会造成消息的丢失。</p>
<h4 id="请求-应答代理"><a href="#请求-应答代理" class="headerlink" title="请求-应答代理"></a>请求-应答代理</h4><p>下面让我们在请求-应答模式中编写一个小型的消息队列代理装置。</p>
<p>在Hello World客户/服务模型中，一个客户端和一个服务端进行通信。但在真实环境中，我们会需要让多个客户端和多个服务端进行通信。关键问题在于，服务端应该是无状态的，所有的状态都应该包含在一次请求中，或者存放其它介质中，如数据库。</p>
<p>我们有两种方式来连接多个客户端和多个服务端。第一种是让客户端直接和多个服务端进行连接。客户端套接字可以连接至多个服务端套接字，它所发送的请求会通过负载均衡的方式分发给服务端。比如说，有一个客户端连接了三个服务端，A、B、C，客户端产生了R1、R2、R3、R4四个请求，那么，R1和R4会由服务A处理，R2由B处理，R3由C处理：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_9.png" alt="9"></p>
<p>这种设计的好处在于可以方便地添加客户端，但若要添加服务端，那就得修改每个客户端的配置。如果你有100个客户端，需要添加三个服务端，那么这些客户端都需要重新进行配置，让其知道新服务端的存在。</p>
<p>这种方式肯定不是我们想要的。一个网络结构中如果有太多固化的模块就越不容易扩展。因此，我们需要有一个模块位于客户端和服务端之间，将所有的知识都汇聚到这个网络拓扑结构中。理想状态下，我们可以任意地增减客户端或是服务端，不需要更改任何组件的配置。</p>
<p>下面就让我们编写这样一个组件。这个代理会绑定到两个端点，前端端点供客户端连接，后端端点供服务端连接。它会使用zmq_poll()来轮询这两个套接字，接收消息并进行转发。装置中不会有队列的存在，因为ZMQ已经自动在套接字中完成了。</p>
<p>在使用REQ和REP套接字时，其请求-应答的会话是严格同步。客户端发送请求，服务端接收请求并发送应答，由客户端接收。如果客户端或服务端中的一个发生问题（如连续两次发送请求），程序就会报错。</p>
<p>但是，我们的代理装置必须要是非阻塞式的，虽然可以使用zmq_poll()同时处理两个套接字，但这里显然不能使用REP和REQ套接字。</p>
<p>幸运的是，我们有DEALER和ROUTER套接字可以胜任这项工作，进行非阻塞的消息收发。DEALER过去被称为XREQ，ROUTER被称为XREP，但新的代码中应尽量使用DEALER/ROUTER这种名称。在第三章中你会看到如何用DEALER和ROUTER套接字构建不同类型的请求-应答模式。</p>
<p>下面就让我们看看DEALER和ROUTER套接字是怎样在装置中工作的。</p>
<p>下方的简图描述了一个请求-应答模式，REQ和ROUTER通信，DEALER再和REP通信。ROUTER和DEALER之间我们则需要进行消息转发：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_10.png" alt="10"></p>
<p>请求-应答代理会将两个套接字分别绑定到前端和后端，供客户端和服务端套接字连接。在使用该装置之前，还需要对客户端和服务端的代码进行调整。</p>
<p><strong> rrclient: Request-reply client in C </strong></p>
<pre><code class="c">//
//  Hello world 客户端
//  连接REQ套接字至 tcp://localhost:5559 端点
//  发送Hello给服务端，等待World应答
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  用于和服务端通信的套接字
    void *requester = zmq_socket (context, ZMQ_REQ);
    zmq_connect (requester, &quot;tcp://localhost:5559&quot;);

    int request_nbr;
    for (request_nbr = 0; request_nbr != 10; request_nbr++) {
        s_send (requester, &quot;Hello&quot;);
        char *string = s_recv (requester);
        printf (&quot;收到应答 %d [%s]\n&quot;, request_nbr, string);
        free (string);
    }
    zmq_close (requester);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>下面是服务代码：</p>
<p><strong>rrserver: Request-reply service in C</strong></p>
<pre><code class="c">//
//  Hello World 服务端
//  连接REP套接字至 tcp://*:5560 端点
//  接收Hello请求，返回World应答
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  用于何客户端通信的套接字
    void *responder = zmq_socket (context, ZMQ_REP);
    zmq_connect (responder, &quot;tcp://localhost:5560&quot;);

    while (1) {
        //  等待下一个请求
        char *string = s_recv (responder);
        printf (&quot;Received request: [%s]\n&quot;, string);
        free (string);

        //  做一些“工作”
        sleep (1);

        //  返回应答信息
        s_send (responder, &quot;World&quot;);
    }
    //  程序不会运行到这里，不过还是做好清理工作
    zmq_close (responder);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>最后是代理程序，可以看到它是能够处理多帧消息的：</p>
<p><strong>rrbroker: Request-reply broker in C</strong></p>
<pre><code class="c">//
//  简易请求-应答代理
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    //  准备上下文和套接字
    void *context = zmq_init (1);
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    void *backend  = zmq_socket (context, ZMQ_DEALER);
    zmq_bind (frontend, &quot;tcp://*:5559&quot;);
    zmq_bind (backend,  &quot;tcp://*:5560&quot;);

    //  初始化轮询集合
    zmq_pollitem_t items [] = {
        { frontend, 0, ZMQ_POLLIN, 0 },
        { backend,  0, ZMQ_POLLIN, 0 }
    };
    //  在套接字间转发消息
    while (1) {
        zmq_msg_t message;
        int64_t more;           //  检测多帧消息

        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            while (1) {
                //  处理所有消息帧
                zmq_msg_init (&amp;message);
                zmq_recv (frontend, &amp;message, 0);
                size_t more_size = sizeof (more);
                zmq_getsockopt (frontend, ZMQ_RCVMORE, &amp;more, &amp;more_size);
                zmq_send (backend, &amp;message, more? ZMQ_SNDMORE: 0);
                zmq_msg_close (&amp;message);
                if (!more)
                    break;      //  最后一帧
            }
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            while (1) {
                //  处理所有消息帧
                zmq_msg_init (&amp;message);
                zmq_recv (backend, &amp;message, 0);
                size_t more_size = sizeof (more);
                zmq_getsockopt (backend, ZMQ_RCVMORE, &amp;more, &amp;more_size);
                zmq_send (frontend, &amp;message, more? ZMQ_SNDMORE: 0);
                zmq_msg_close (&amp;message);
                if (!more)
                    break;      //  最后一帧
            }
        }
    }
    //  程序不会运行到这里，不过还是做好清理工作
    zmq_close (frontend);
    zmq_close (backend);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>使用请求-应答代理可以让你的C/S网络结构更易于扩展：客户端不知道服务端的存在，服务端不知道客户端的存在。网络中唯一稳定的组件是中间的代理装置：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_11.png" alt="11"></p>
<h4 id="内置装置"><a href="#内置装置" class="headerlink" title="内置装置"></a>内置装置</h4><p>ZMQ提供了一些内置的装置，不过大多数人需要自己手动编写这些装置。内置装置有：</p>
<ul>
<li>QUEUE，可用作请求-应答代理；</li>
<li>FORWARDER，可用作发布-订阅代理服务；</li>
<li>STREAMER，可用作管道模式代理。</li>
</ul>
<p>可以使用zmq_device()来启动一个装置，需要传递两个套接字给它：</p>
<pre><code class="c">zmq_device (ZMQ_QUEUE, frontend, backend);
</code></pre>
<p>启动了QUEUE队列就如同在网络中加入了一个请求-应答代理，只需为其创建已绑定或连接的套接字即可。下面这段代码是使用内置装置的情形：</p>
<p><strong>msgqueue: Message queue broker in C</strong></p>
<pre><code class="c">//
//  简单消息队列代理
//  功能和请求-应答代理相同，但使用了内置的装置
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  客户端套接字
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (frontend, &quot;tcp://*:5559&quot;);

    //  服务端套接字
    void *backend = zmq_socket (context, ZMQ_DEALER);
    zmq_bind (backend, &quot;tcp://*:5560&quot;);

    //  启动内置装置
    zmq_device (ZMQ_QUEUE, frontend, backend);

    //  程序不会运行到这里
    zmq_close (frontend);
    zmq_close (backend);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>内置装置会恰当地处理错误，而我们手工实现的代理并没有加入错误处理机制。所以说，当你能够在程序中使用内置装置的时候就尽量用吧。</p>
<p>可能你会像某些ZMQ开发者一样提出这样一个问题：如果我将其他类型的套接字传入这些装置中会发生什么？答案是：别这么做。你可以随意传入不同类型的套接字，但是执行结果会非常奇怪。所以，QUEUE装置应使用ROUTER/DEALER套接字、FORWARDER应使用SUB/PUB、STREAMER应使用PULL/PUSH。</p>
<p>当你需要其他的套接字类型进行组合时，那就需要自己编写装置了。</p>
<h3 id="ZMQ多线程编程"><a href="#ZMQ多线程编程" class="headerlink" title="ZMQ多线程编程"></a>ZMQ多线程编程</h3><p>使用ZMQ进行多线程编程（MT编程）将会是一种享受。在多线程中使用ZMQ套接字时，你不需要考虑额外的东西，让它们自如地运作就好。</p>
<p>使用ZMQ进行多线程编程时，<strong>不需要考虑互斥、锁、或其他并发程序中要考虑的因素，你唯一要关心的仅仅是线程之间的消息</strong>。</p>
<p>什么叫“完美”的多线程编程，指的是代码易写易读，可以跨系统、跨语言地使用同一种技术，能够在任意颗核心的计算机上运行，没有状态，没有速度的瓶颈。</p>
<p>如果你有多年的多线程编程经验，知道如何使用锁、信号灯、临界区等机制来使代码运行得正确（尚未考虑快速），那你可能会很沮丧，因为ZMQ将改变这一切。三十多年来，并发式应用程序开发所总结的经验是：不要共享状态。这就好比两个醉汉想要分享一杯啤酒，如果他们不是铁哥们儿，那他们很快就会打起来。当有更多的醉汉加入时，情况就会更糟。多线程编程有时就像醉汉抢夺啤酒那样糟糕。</p>
<p>进行多线程编程往往是痛苦的，当程序因为压力过大而崩溃时，你会不知所然。有人写过一篇《多线程代码中的11个错误易发点》的文章，在大公司中广为流传，列举其中的几项：没有进行同步、错误的粒度、读写分离、无锁排序、锁传递、优先级冲突等。</p>
<p>假设某一天的下午三点，当证券市场正交易得如火如荼的时候，突然之间，应用程序因为锁的问题崩溃了，那将会是何等的场景？所以，作为程序员的我们，为解决那些复杂的多线程问题，只能用上更复杂的编程机制。</p>
<p>有人曾这样比喻，那些多线程程序原本应作为大型公司的核心支柱，但往往又最容易出错；那些想要通过网络不断进行延伸的产品，最后总以失败告终。</p>
<p>如何用ZMQ进行多线程编程，以下是一些规则：</p>
<ul>
<li><p>不要在不同的线程之间访问同一份数据，如果要用到传统编程中的互斥机制，那就有违ZMQ的思想了。唯一的例外是ZMQ上下文对象，它是线程安全的。</p>
</li>
<li><p>必须为进程创建ZMQ上下文，并将其传递给所有你需要使用inproc协议进行通信的线程；</p>
</li>
<li><p>你可以将线程作为单独的任务来对待，使用自己的上下文，但是这些线程之间就不能使用inproc协议进行通信了。这样做的好处是可以在日后方便地将程序拆分为不同的进程来运行。</p>
</li>
<li><p>不要在不同的线程之间传递套接字对象，这些对象不是线程安全的。从技术上来说，你是可以这样做的，但是会用到互斥和锁的机制，这会让你的应用程序变得缓慢和脆弱。唯一合理的情形是，在某些语言的ZMQ类库内部，需要使用垃圾回收机制，这时可能会进行套接字对象的传递。</p>
</li>
</ul>
<p>当你需要在应用程序中使用两个装置时，可能会将套接字对象从一个线程传递给另一个线程，这样做一开始可能会成功，但最后一定会随机地发生错误。所以说，应在同一个线程中打开和关闭套接字。</p>
<p>如果你能遵循上面的规则，就会发现多线程程序可以很容易地拆分成多个进程。程序逻辑可以在线程、进程、或是计算机中运行，根据你的需求进行部署即可。</p>
<p>ZMQ使用的是系统原生的线程机制，而不是某种“绿色线程”。这样做的好处是你不需要学习新的多线程编程API，而且可以和目标操作系统进行很好的结合。你可以使用类似英特尔的ThreadChecker工具来查看线程工作的情况。缺点在于，如果程序创建了太多的线程（如上千个），则可能导致操作系统负载过高。</p>
<p>下面我们举一个实例，让原来的Hello World服务变得更为强大。原来的服务是单线程的，如果请求较少，自然没有问题。ZMQ的线程可以在一个核心上高速地运行，执行大量的工作。但是，如果有一万次请求同时发送过来会怎么样？因此，现实环境中，我们会启动多个worker线程，他们会尽可能地接收客户端请求，处理并返回应答。</p>
<p>当然，我们可以使用启动多个worker进程的方式来实现，但是启动一个进程总比启动多个进程要来的方便且易于管理。而且，作为线程启动的worker，所占用的带宽会比较少，延迟也会较低。<br>以下是多线程版的Hello World服务：</p>
<p><strong>mtserver: Multithreaded service in C</strong></p>
<pre><code class="c">//
//  多线程版Hello World服务
//
#include &quot;zhelpers.h&quot;
#include &lt;pthread.h&gt;

static void *
worker_routine (void *context) {
    //  连接至代理的套接字
    void *receiver = zmq_socket (context, ZMQ_REP);
    zmq_connect (receiver, &quot;inproc://workers&quot;);

    while (1) {
        char *string = s_recv (receiver);
        printf (&quot;Received request: [%s]\n&quot;, string);
        free (string);
        //  工作
        sleep (1);
        //  返回应答
        s_send (receiver, &quot;World&quot;);
    }
    zmq_close (receiver);
    return NULL;
}

int main (void)
{
    void *context = zmq_init (1);

    //  用于和client进行通信的套接字
    void *clients = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (clients, &quot;tcp://*:5555&quot;);

    //  用于和worker进行通信的套接字
    void *workers = zmq_socket (context, ZMQ_DEALER);
    zmq_bind (workers, &quot;inproc://workers&quot;);

    //  启动一个worker池
    int thread_nbr;
    for (thread_nbr = 0; thread_nbr &lt; 5; thread_nbr++) {
        pthread_t worker;
        pthread_create (&amp;worker, NULL, worker_routine, context);
    }
    //  启动队列装置
    zmq_device (ZMQ_QUEUE, clients, workers);

    //  程序不会运行到这里，但仍进行清理工作
    zmq_close (clients);
    zmq_close (workers);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>所有的代码应该都已经很熟悉了：</p>
<ul>
<li>服务端启动一组worker线程，每个worker创建一个REP套接字，并处理收到的请求。worker线程就像是一个单线程的服务，唯一的区别是使用了inproc而非tcp协议，以及绑定-连接的方向调换了。</li>
<li>服务端创建ROUTER套接字用以和client通信，因此提供了一个TCP协议的外部接口。</li>
<li>服务端创建DEALER套接字用以和worker通信，使用了内部接口（inproc）。</li>
<li>服务端启动了QUEUE内部装置，连接两个端点上的套接字。QUEUE装置会将收到的请求分发给连接上的worker，并将应答路由给请求方。</li>
</ul>
<p>需要注意的是，在某些编程语言中，创建线程并不是特别方便，POSIX提供的类库是pthreads，但Windows中就需要使用不同的API了。我们会在第三章中讲述如何包装一个多线程编程的API。</p>
<p>示例中的“工作”仅仅是1秒钟的停留，我们可以在worker中进行任意的操作，包括与其他节点进行通信。消息的流向是这样的：REQ-ROUTER-queue-DEALER-REP。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_12.png" alt="12"></p>
<h3 id="线程间的信号传输"><a href="#线程间的信号传输" class="headerlink" title="线程间的信号传输"></a>线程间的信号传输</h3><p>当你刚开始使用ZMQ进行多线程编程时，你可能会问：要如何协调两个线程的工作呢？可能会想要使用sleep()这样的方法，或者使用诸如信号、互斥等机制。事实上，<strong>你唯一要用的就是ZMQ本身</strong>。回忆一下那个醉汉抢啤酒的例子吧。</p>
<p>下面的示例演示了三个线程之间需要如何进行同步：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_13.png" alt="13"></p>
<p>我们使用PAIR套接字和inproc协议。</p>
<p><strong>mtrelay: Multithreaded relay in C</strong></p>
<pre><code class="c">//
// 多线程同步
//
#include &quot;zhelpers.h&quot;
#include &lt;pthread.h&gt;

static void *
step1 (void *context) {
    //  连接至步骤2，告知我已就绪
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, &quot;inproc://step2&quot;);
    printf (&quot;步骤1就绪，正在通知步骤2……\n&quot;);
    s_send (xmitter, &quot;READY&quot;);
    zmq_close (xmitter);

    return NULL;
}

static void *
step2 (void *context) {
    //  启动步骤1前线绑定至inproc套接字
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, &quot;inproc://step2&quot;);
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step1, context);

    //  等待信号
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    //  连接至步骤3，告知我已就绪
    void *xmitter = zmq_socket (context, ZMQ_PAIR);
    zmq_connect (xmitter, &quot;inproc://step3&quot;);
    printf (&quot;步骤2就绪，正在通知步骤3……\n&quot;);
    s_send (xmitter, &quot;READY&quot;);
    zmq_close (xmitter);

    return NULL;
}

int main (void)
{
    void *context = zmq_init (1);

    //  启动步骤2前线绑定至inproc套接字
    void *receiver = zmq_socket (context, ZMQ_PAIR);
    zmq_bind (receiver, &quot;inproc://step3&quot;);
    pthread_t thread;
    pthread_create (&amp;thread, NULL, step2, context);

    //  等待信号
    char *string = s_recv (receiver);
    free (string);
    zmq_close (receiver);

    printf (&quot;测试成功！\n&quot;);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这是一个ZMQ多线程编程的典型示例：</p>
<ol>
<li>两个线程通过inproc协议进行通信，使用同一个上下文；</li>
<li>父线程创建一个套接字，绑定至inproc://端点，然后再启动子线程，将上下文对象传递给它；</li>
<li>子线程创建第二个套接字，连接至inproc://端点，然后发送已就绪信号给父线程。</li>
</ol>
<p>需要注意的是，这段代码无法扩展到多个进程之间的协调。如果你使用inproc协议，只能建立结构非常紧密的应用程序。在延迟时间必须严格控制的情况下可以使用这种方法。对其他应用程序来说，每个线程使用同一个上下文，协议选用ipc或tcp。然后，你就可以自由地将应用程序拆分为多个进程甚至是多台计算机了。</p>
<p>这是我们第一次使用PAIR套接字。为什么要使用PAIR？其他类型的套接字也可以使用，但都有一些缺点会影响到线程间的通信：</p>
<ul>
<li><p>你可以让信号发送方使用PUSH，接收方使用PULL，这看上去可能可以，但是需要注意的是，PUSH套接字发送消息时会进行负载均衡，如果你不小心开启了两个接收方，就会“丢失”一半的信号。而PAIR套接字建立的是一对一的连接，具有排他性。</p>
</li>
<li><p>可以让发送方使用DEALER，接收方使用ROUTER。但是，ROUTER套接字会在消息的外层包裹一个来源地址，这样一来原本零字节的信号就可能要成为一个多段消息了。如果你不在乎这个问题，并且不会重复读取那个套接字，自然可以使用这种方法。但是，如果你想要使用这个套接字接收真正的数据，你就会发现ROUTER提供的消息是错误的。至于DEALER套接字，它同样有负载均衡的机制，和PUSH套接字有相同的风险。</p>
</li>
<li><p>可以让发送方使用PUB，接收方使用SUB。一来消息可以照原样发送，二来PUB套接字不会进行负载均衡。但是，你需要对SUB套接字设置一个空的订阅信息（用以接收所有消息）；而且，如果SUB套接字没有及时和PUB建立连接，消息很有可能会丢失。</p>
</li>
</ul>
<p>综上，使用PAIR套接字进行线程间的协调是最合适的。</p>
<h3 id="节点协调"><a href="#节点协调" class="headerlink" title="节点协调"></a>节点协调</h3><p>当你想要对节点进行协调时，PAIR套接字就不怎么合适了，这也是线程和节点之间的不同之处。一般来说，节点是来去自由的，而线程则较为稳定。使用PAIR套接字时，若远程节点断开连接后又进行重连，PAIR不会予以理会。</p>
<p>第二个区别在于，线程的数量一般是固定的，而节点数量则会经常变化。让我们以气象信息模型为基础，看看要怎样进行节点的协调，以保证客户端不会丢失最开始的那些消息。</p>
<p>下面是程序运行逻辑：</p>
<ul>
<li>发布者知道预期的订阅者数量，这个数字可以任意指定；</li>
<li>发布者启动后会先等待所有订阅者进行连接，也就是节点协调。每个订阅者会使用另一个套接字来告知发布者自己已就绪；</li>
<li>当所有订阅者准备就绪后，发布者才开始发送消息。</li>
</ul>
<p>这里我们会使用REQ-REP套接字来同步发布者和订阅者。发布者的代码如下：</p>
<p><strong>syncpub: Synchronized publisher in C</strong></p>
<pre><code class="c">//
//  发布者 - 同步版
//
#include &quot;zhelpers.h&quot;

//  等待10个订阅者连接
#define SUBSCRIBERS_EXPECTED  10

int main (void)
{
    void *context = zmq_init (1);

    //  用于和客户端通信的套接字
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, &quot;tcp://*:5561&quot;);

    //  用于接收信号的套接字
    void *syncservice = zmq_socket (context, ZMQ_REP);
    zmq_bind (syncservice, &quot;tcp://*:5562&quot;);

    //  接收订阅者的就绪信号
    printf (&quot;正在等待订阅者就绪\n&quot;);
    int subscribers = 0;
    while (subscribers &lt; SUBSCRIBERS_EXPECTED) {
        //  - 等待就绪信息
        char *string = s_recv (syncservice);
        free (string);
        //  - 发送应答
        s_send (syncservice, &quot;&quot;);
        subscribers++;
    }
    //  开始发送100万条数据
    printf (&quot;正在广播消息\n&quot;);
    int update_nbr;
    for (update_nbr = 0; update_nbr &lt; 1000000; update_nbr++)
        s_send (publisher, &quot;Rhubarb&quot;);

    s_send (publisher, &quot;END&quot;);

    zmq_close (publisher);
    zmq_close (syncservice);
    zmq_term (context);
    return 0;
}
</code></pre>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_14.png" alt="14"></p>
<p>以下是订阅者的代码：</p>
<p><strong>syncsub: Synchronized subscriber in C</strong></p>
<pre><code class="c">//
//  订阅者 - 同步版
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    void *context = zmq_init (1);

    //  一、连接SUB套接字
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, &quot;tcp://localhost:5561&quot;);
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, &quot;&quot;, 0);

    //  ZMQ太快了，我们延迟一会儿……
    sleep (1);

    //  二、与发布者进行同步
    void *syncclient = zmq_socket (context, ZMQ_REQ);
    zmq_connect (syncclient, &quot;tcp://localhost:5562&quot;);

    //  - 发送请求
    s_send (syncclient, &quot;&quot;);

    //  - 等待应答
    char *string = s_recv (syncclient);
    free (string);

    //  三、处理消息
    int update_nbr = 0;
    while (1) {
        char *string = s_recv (subscriber);
        if (strcmp (string, &quot;END&quot;) == 0) {
            free (string);
            break;
        }
        free (string);
        update_nbr++;
    }
    printf (&quot;收到 %d 条消息\n&quot;, update_nbr);

    zmq_close (subscriber);
    zmq_close (syncclient);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>以下这段shell脚本会启动10个订阅者、1个发布者：</p>
<pre><code class="sh">echo &quot;正在启动订阅者...&quot;
for a in 1 2 3 4 5 6 7 8 9 10; do
    syncsub &amp;
done
echo &quot;正在启动发布者...&quot;
syncpub
</code></pre>
<p>结果如下：</p>
<pre><code>正在启动订阅者...
正在启动发布者...
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
收到 1000000 条消息
</code></pre><p>当REQ-REP请求完成时，我们仍无法保证SUB套接字已成功建立连接。除非使用inproc协议，否则对外连接的顺序是不一定的。因此，示例程序中使用了sleep(1)的方式来进行处理，随后再发送同步请求。</p>
<p>更可靠的模型可以是：</p>
<ul>
<li>发布者打开PUB套接字，开始发送Hello消息（非数据）；</li>
<li>订阅者连接SUB套接字，当收到Hello消息后再使用REQ-REP套接字进行同步；</li>
<li>当发布者获得所有订阅者的同步消息后，才开始发送真正的数据。</li>
</ul>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>第一章中我们曾提过零拷贝是很危险的，其实那是吓唬你的。既然你已经读到这里了，说明你已经具备了足够的知识，能够使用零拷贝。但需要记住，条条大路通地狱，过早地对程序进行优化其实是没有必要的。简单的说，如果你用不好零拷贝，那可能会让程序架构变得更糟。</p>
<p>ZMQ提供的API可以让你直接发送和接收消息，不用考虑缓存的问题。正因为消息是由ZMQ在后台收发的，所以使用零拷贝需要一些额外的工作。</p>
<p>做零拷贝时，使用zmq_msg_init_data()函数创建一条消息，其内容指向某个已经分配好的内存区域，然后将该消息传递给zmq_send()函数。创建消息时，你还需要提供一个用于释放消息内容的函数，ZMQ会在消息发送完毕时调用。下面是一个简单的例子，我们假设已经分配好的内存区域为1000个字节：</p>
<pre><code class="c">void my_free (void *data, void *hint) {
    free (data);
}
//  Send message from buffer, which we allocate and 0MQ will free for us
zmq_msg_t message;
zmq_msg_init_data (&amp;message, buffer, 1000, my_free, NULL);
zmq_send (socket, &amp;message, 0);
</code></pre>
<p>在接收消息的时候是无法使用零拷贝的：ZMQ会将收到的消息放入一块内存区域供你读取，但不会将消息写入程序指定的内存区域。</p>
<p>ZMQ的多段消息能够很好地支持零拷贝。在传统消息系统中，你需要将不同缓存中的内容保存到同一个缓存中，然后才能发送。但ZMQ会将来自不同内存区域的内容作为消息的一个帧进行发送。而且在ZMQ内部，一条消息会作为一个整体进行收发，因而非常高效。</p>
<h3 id="瞬时套接字和持久套接字"><a href="#瞬时套接字和持久套接字" class="headerlink" title="瞬时套接字和持久套接字"></a>瞬时套接字和持久套接字</h3><p>在传统网络编程中，套接字是一个API对象，它们的生命周期不会长过程序的生命周期。但仔细打量一下套接字，它会占用一项特定的资源——缓存，这时ZMQ的开发者可能会问：是否有办法在程序崩溃时让这些套接字缓存得以保留，稍后能够恢复？</p>
<p>这种特性应该会非常有用，虽然不能应对所有的危险，但至少可以挽回一部分损失，特别是多发布-订阅模式来说。让我们来讨论一下。</p>
<p>这里有两个套接字正在欢快地传送着气象信息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_15.png" alt="15"></p>
<p>如果接收方（SUB、PULL、REQ）指定了套接字标识，当它们断开网络时，发送方（PUB、PUSH、REP）会为它们缓存信息，直至达到阈值（HWM）。这里发送方不需要有套接字标识。</p>
<p>需要注意，ZMQ的套接字缓存对程序员来说是不可见的，正如TCP缓存一样。</p>
<p>到目前为止，我们使用的套接字都是瞬时套接字。要将瞬时套接字转化为持久套接字，需要为其设定一个套接字标识。所有的ZMQ套接字都会有一个标识，不过是由ZMQ自动生成的UUID。</p>
<p>在ZMQ内部，两个套接字相连时会先交换各自的标识。如果发生对方没有ID，则会自行生成一个用以标识对方：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_16.png" alt="16"></p>
<p>但套接字也可以告知对方自己的标识，那当它们第二次连接时，就能知道对方的身份：</p>
<pre><code>        +-----------+
        |           |
        |  Sender   |
        |           |
        +-----------+
        |  Socket   |
        \-----------/
              ^  &quot;Lucy! Nice to see you again...&quot;
              |
              |
              |  &quot;My name&#39;s Lucy&quot;
        /-----+-----\
        |  Socket   |
        +-----------+
        |           |
        | Receiver  |
        |           |
        +-----------+


        Figure # - Durable socket
</code></pre><p>下面这行代码就可以为套接字设置标识，从而建立了一个持久的套接字：</p>
<pre><code class="c">zmq_setsockopt (socket, ZMQ_IDENTITY, &quot;Lucy&quot;, 4);
</code></pre>
<p>关于套接字标识还有几点说明：</p>
<ul>
<li>如果要为套接字设置标识，必须在连接或绑定至端点之前设置；</li>
<li>接收方会选择使用套接字标识，正如cookie在HTTP网页应用中的性质，是由服务器去选择要使用哪个cookie的；</li>
<li>套接字标识是二进制字符串；以字节0开头的套接字标识为ZMQ保留标识；</li>
<li>不用为多个套接字指定相同的标识，若套接字使用的标识已被占用，它将无法连接至其他套接字；</li>
<li>不要使用随机的套接字标识，这样会生成很多持久化套接字，最终让节点崩溃；</li>
<li>如果你想获取对方套接字的标识，只有ROUTER套接字会帮你自动完成这件事，使用其他套接字类型时，需要将标识作为消息的一帧发送过来；</li>
<li>说了以上这些，使用持久化套接字其实并不明智，因为它会让发送者越来越混乱，让架构变得脆弱。如果我们能重新设计ZMQ，很可能会去掉这种显式声明套接字标识的功能。</li>
</ul>
<p>其他信息可以查看zmq_setsockopt()函数的ZMQ_IDENTITY一节。注意，该方法只能获取程序中套接字的标识，而不能获得对方套接字的标识。</p>
<h3 id="发布-订阅消息信封"><a href="#发布-订阅消息信封" class="headerlink" title="发布-订阅消息信封"></a>发布-订阅消息信封</h3><p>我们简单介绍了多帧消息，下面就来看看它的典型用法——消息信封。信封是指为消息注明来源地址，而不修改消息内容。</p>
<p>在发布-订阅模式中，信封包含了订阅信息，用以过滤掉不需要接收的消息。</p>
<p>如果你想要使用发布-订阅信封，就需要自行生成和设置。这个动作是可选的，我们在之前的示例中也没有使用到。在发布-订阅模式中使用信封可能会比较麻烦，但在现实应用中还是很有必要的，毕竟信封和消息的确是两块不想干的数据。</p>
<p>这是发布-订阅模式中一个带有信封的消息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_17.png" alt="17"></p>
<p>我们回忆一下，发布-订阅模式中，消息的接收是根据订阅信息来的，也就是消息的前缀。将这个前缀放入单独的消息帧，可以让匹配变得非常明显。因为不会有一个应用程序恰好只匹配了一部分数据。</p>
<p>下面是一个最简的发布-订阅消息信封示例。发布者会发送两类消息：A和B，信封中指明了消息类型：</p>
<p><strong>psenvpub: Pub-sub envelope publisher in C</strong></p>
<pre><code class="c">//
//  发布-订阅消息信封 - 发布者
//  s_sendmore()函数也是zhelpers.h提供的
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    //  准备上下文和PUB套接字
    void *context = zmq_init (1);
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, &quot;tcp://*:5563&quot;);

    while (1) {
        //  发布两条消息，A类型和B类型
        s_sendmore (publisher, &quot;A&quot;);
        s_send (publisher, &quot;We don&#39;t want to see this&quot;);
        s_sendmore (publisher, &quot;B&quot;);
        s_send (publisher, &quot;We would like to see this&quot;);
        sleep (1);
    }
    //  正确退出
    zmq_close (publisher);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>假设订阅者只需要B类型的消息：</p>
<p><strong>psenvsub: Pub-sub envelope subscriber in C</strong></p>
<pre><code class="c">//
//  发布-订阅消息信封 - 订阅者
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    void *context = zmq_init (1);
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, &quot;tcp://localhost:5563&quot;);
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, &quot;B&quot;, 1);

    while (1) {
        //  读取消息信封
        char *address = s_recv (subscriber);
        //  读取消息内容
        char *contents = s_recv (subscriber);
        printf (&quot;[%s] %s\n&quot;, address, contents);
        free (address);
        free (contents);
    }
    //  正确退出
    zmq_close (subscriber);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>执行上面的程序时，订阅者会打印如下信息：</p>
<pre><code>[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
[B] We would like to see this
...
</code></pre><p>这个示例说明订阅者会丢弃未订阅的消息，且接收完整的多帧消息——你不会只获得消息的一部分。</p>
<p>如果你订阅了多个套接字，又想知道这些套接字的标识，从而通过另一个套接字来发送消息给它们（这个用例很常见），你可以让发布者创建一条含有三帧的消息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter2_18.png" alt="18"></p>
<h3 id="（半）持久订阅者和阈值（HWM）"><a href="#（半）持久订阅者和阈值（HWM）" class="headerlink" title="（半）持久订阅者和阈值（HWM）"></a>（半）持久订阅者和阈值（HWM）</h3><p>所有的套接字类型都可以使用标识。如果你在使用PUB和SUB套接字，其中SUB套接字为自己声明了标识，那么，当SUB断开连接时，PUB会保留要发送给SUB的消息。</p>
<p>这种机制有好有坏。好的地方在于发布者会暂存这些消息，当订阅者重连后进行发送；不好的地方在于这样很容易让发布者因内存溢出而崩溃。</p>
<p><strong>如果你在使用持久化的SUB套接字（即为SUB设置了套接字标识），那么你必须设法避免消息在发布者队列中堆砌并溢出，应该使用阈值（HWM）来保护发布者套接字</strong>。发布者的阈值会分别影响所有的订阅者。</p>
<p>我们可以运行一个示例来证明这一点，用第一章中的wuclient和wuserver具体，在wuclient中进行套接字连接前加入这一行：</p>
<pre><code class="c">    zmq_setsockopt (subscriber, ZMQ_IDENTITY, &quot;Hello&quot;, 5);
</code></pre>
<p>编译并运行这两段程序，一切看起来都很平常。但是观察一下发布者的内存占用情况，可以看到当订阅者逐个退出后，发布者的内存占用会逐渐上升。若此时你重启订阅者，会发现发布者的内存占用不再增长了，一旦订阅者停止，就又会增长。很快地，它就会耗尽系统资源。</p>
<p>我们先来看看如何设置阈值，然后再看如何设置得正确。下面的发布者和订阅者使用了上文提到的“节点协调”机制。发布者会每隔一秒发送一条消息，这时你可以中断订阅者，重新启动它，看看会发生什么。</p>
<p>以下是发布者的代码：</p>
<p><strong>durapub: Durable publisher in C</strong></p>
<pre><code class="c">//
//  发布者 - 连接持久化的订阅者
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  订阅者会发送已就绪的消息
    void *sync = zmq_socket (context, ZMQ_PULL);
    zmq_bind (sync, &quot;tcp://*:5564&quot;);

    //  使用该套接字发布消息
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, &quot;tcp://*:5565&quot;);

    //  等待同步消息
    char *string = s_recv (sync);
    free (string);

    //  广播10条消息，一秒一条
    int update_nbr;
    for (update_nbr = 0; update_nbr &lt; 10; update_nbr++) {
        char string [20];
        sprintf (string, &quot;Update %d&quot;, update_nbr);
        s_send (publisher, string);
        sleep (1);
    }
    s_send (publisher, &quot;END&quot;);

    zmq_close (sync);
    zmq_close (publisher);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>下面是订阅者的代码：</p>
<p><strong>durasub: Durable subscriber in C</strong></p>
<pre><code class="c">//
//  持久化的订阅者
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    void *context = zmq_init (1);

    //  连接SUB套接字
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_setsockopt (subscriber, ZMQ_IDENTITY, &quot;Hello&quot;, 5);
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, &quot;&quot;, 0);
    zmq_connect (subscriber, &quot;tcp://localhost:5565&quot;);

    //  发送同步消息
    void *sync = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sync, &quot;tcp://localhost:5564&quot;);
    s_send (sync, &quot;&quot;);

    //  获取更新，并按指令退出
    while (1) {
        char *string = s_recv (subscriber);
        printf (&quot;%s\n&quot;, string);
        if (strcmp (string, &quot;END&quot;) == 0) {
            free (string);
            break;
        }
        free (string);
    }
    zmq_close (sync);
    zmq_close (subscriber);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>运行以上代码，在不同的窗口中先后打开发布者和订阅者。当订阅者获取了一至两条消息后按Ctrl-C中止，然后重新启动，看看执行结果：</p>
<pre><code>$ durasub
Update 0
Update 1
Update 2
^C
$ durasub
Update 3
Update 4
Update 5
Update 6
Update 7
^C
$ durasub
Update 8
Update 9
END
</code></pre><p>可以看到订阅者的唯一区别是为套接字设置了标识，发布者就会将消息缓存起来，待重建连接后发送。设置套接字标识可以让瞬时套接字转变为持久套接字。实践中，你需要小心地给套接字起名字，可以从配置文件中获取，或者生成一个UUID并保存起来。</p>
<p>当我们为PUB套接字设置了阈值，发布者就会缓存指定数量的消息，转而丢弃溢出的消息。让我们将阈值设置为2，看看会发生什么：</p>
<pre><code class="c">uint64_t hwm = 2;
zmq_setsockopt (publisher, ZMQ_HWM, &amp;hwm, sizeof (hwm));
</code></pre>
<p>运行程序，中断订阅者后等待一段时间再重启，可以看到结果如下：</p>
<pre><code>$ durasub
Update 0
Update 1
^C
$ durasub
Update 2
Update 3
Update 7
Update 8
Update 9
END
</code></pre><p>看仔细了，发布者只为我们保存了两条消息（2和3）。阈值使得ZMQ丢弃溢出队列的消息。</p>
<p>简而言之，如果你要使用持久化的订阅者，就必须在发布者端设置阈值，否则可能造成服务器因内存溢出而崩溃。但是，还有另一种方法。ZMQ提供了名为交换区（swap）的机制，它是一个磁盘文件，用于存放从队列中溢出的消息。启动它很简单：</p>
<pre><code class="c">// 指定交换区大小，单位：字节。
uint64_t swap = 25000000;
zmq_setsockopt (publisher, ZMQ_SWAP, &amp;swap, sizeof (swap));
</code></pre>
<p>我们可以将上面的方法综合起来，编写一个既能接受持久化套接字，又不至于内存溢出的发布者：</p>
<p><strong>durapub2: Durable but cynical publisher in C</strong></p>
<pre><code class="c">//
//  发布者 - 连接持久化订阅者
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  订阅者会告知我们它已就绪
    void *sync = zmq_socket (context, ZMQ_PULL);
    zmq_bind (sync, &quot;tcp://*:5564&quot;);

    //  使用该套接字发送消息
    void *publisher = zmq_socket (context, ZMQ_PUB);

    //  避免慢持久化订阅者消息溢出的问题
    uint64_t hwm = 1;
    zmq_setsockopt (publisher, ZMQ_HWM, &amp;hwm, sizeof (hwm));

    //  设置交换区大小，供所有订阅者使用
    uint64_t swap = 25000000;
    zmq_setsockopt (publisher, ZMQ_SWAP, &amp;swap, sizeof (swap));
    zmq_bind (publisher, &quot;tcp://*:5565&quot;);

    //  等待同步消息
    char *string = s_recv (sync);
    free (string);

    //  发布10条消息，一秒一条
    int update_nbr;
    for (update_nbr = 0; update_nbr &lt; 10; update_nbr++) {
        char string [20];
        sprintf (string, &quot;Update %d&quot;, update_nbr);
        s_send (publisher, string);
        sleep (1);
    }
    s_send (publisher, &quot;END&quot;);

    zmq_close (sync);
    zmq_close (publisher);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>若在现实环境中将阈值设置为1，致使所有待发送的消息都保存到磁盘上，会大大降低处理速度。这里有一些典型的方法用以处理不同的订阅者：</p>
<ul>
<li><p><strong>必须为PUB套接字设置阈值</strong>，具体数字可以通过最大订阅者数、可供队列使用的最大内存区域、以及消息的平均大小来衡量。举例来说，你预计会有5000个订阅者，有1G的内存可供使用，消息大小在200个字节左右，那么，一个合理的阈值是1,000,000,000 / 200 / 5,000 = 1,000。</p>
</li>
<li><p>如果你不希望慢速或崩溃的订阅者丢失消息，可以设置一个交换区，在高峰期的时候存放这些消息。交换区的大小可以根据订阅者数、高峰消息比率、消息平均大小、暂存时间等来衡量。比如，你预计有5000个订阅者，消息大小为200个字节左右，每秒会有10万条消息。这样，你每秒就需要100MB的磁盘空间来存放消息。加总起来，你会需要6GB的磁盘空间，而且必须足够的快（这超出了本指南的讲解范围）。</p>
</li>
</ul>
<p>关于持久化订阅者：</p>
<ul>
<li><p>数据可能会丢失，这要看消息发布的频率、网络缓存大小、通信协议等。持久化的订阅者比起瞬时套接字要可靠一些，但也并不是完美的。</p>
</li>
<li><p>交换区文件是无法恢复的，所以当发布者或代理消亡时，交换区中的数据仍然会丢失。</p>
</li>
</ul>
<p>关于阈值：</p>
<ul>
<li><p>这个选项会同时影响套接字的发送和接收队列。当然，PUB、PUSH不会有接收队列，SUB、PULL、REQ、REP不会有发送队列。而像DEALER、ROUTER、PAIR套接字时，他们既有发送队列，又有接收队列。</p>
</li>
<li><p>当套接字达到阈值时，ZMQ会发生阻塞，或直接丢弃消息。</p>
</li>
<li><p>使用inproc协议时，发送者和接受者共享同一个队列缓存，所以说，真正的阈值是两个套接字阈值之和。如果一方套接字没有设置阈值，那么它就不会有缓存方面的限制。</p>
</li>
</ul>
<h3 id="这就是你想要的！"><a href="#这就是你想要的！" class="headerlink" title="这就是你想要的！"></a>这就是你想要的！</h3><p>ZMQ就像是一盒积木，只要你有足够的想象力，就可以用它组装出任何造型的网络架构。</p>
<p>这种高可扩、高弹性的架构一定会打开你的眼界。其实这并不是ZMQ原创的，早就有像<a href="http://www.erlang.org/" target="_blank" rel="external">Erlang</a>这样的<a href="http://en.wikipedia.org/wiki/Flow-based_programming" target="_blank" rel="external">基于流的编程语言</a>已经能够做到了，只是ZMQ提供了更为友善和易用的接口。</p>
<p>正如<a href="http://permalink.gmane.org/gmane.network.zeromq.devel/2145" target="_blank" rel="external">Gonzo Diethelm</a>所言：“我想用一句话来总结，‘如果ZMQ不存在，那它就应该被发明出来。’作为一个有着多年相关工作经验的人，ZMQ太能引起我的共鸣了。我只能说，‘这就是我想要的！’”</p>
]]></content>
      
        <categories>
            
            <category> 网络编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zmq,网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zmq学习第五章]]></title>
      <url>/2017/12/26/zmq_chapter5/</url>
      <content type="html"><![CDATA[<h2 id="第五章-高级发布-订阅模式"><a href="#第五章-高级发布-订阅模式" class="headerlink" title="第五章 高级发布-订阅模式"></a>第五章 高级发布-订阅模式</h2><p>第三章和第四章讲述了ZMQ中请求-应答模式的一些高级用法。如果你已经能够彻底理解了，那我要说声恭喜。这一章我们会关注发布-订阅模式，使用上层模式封装，提升ZMQ发布-订阅模式的性能、可靠性、状态同步及安全机制。</p>
<p>本章涉及的内容有：</p>
<ul>
<li>处理慢订阅者（自杀的蜗牛模式）</li>
<li>高速订阅者（黑箱模式）</li>
<li>构建一个共享键值缓存（克隆模式）</li>
</ul>
<a id="more"></a>
<h3 id="检测慢订阅者（自杀的蜗牛模式）"><a href="#检测慢订阅者（自杀的蜗牛模式）" class="headerlink" title="检测慢订阅者（自杀的蜗牛模式）"></a>检测慢订阅者（自杀的蜗牛模式）</h3><p>在使用发布-订阅模式的时候，最常见的问题之一是如何处理响应较慢的订阅者。理想状况下，发布者能以全速发送消息给订阅者，但现实中，订阅者会需要对消息做较长时间的处理，或者写得不够好，无法跟上发布者的脚步。</p>
<p>如何处理慢订阅者？最好的方法当然是让订阅者高效起来，不过这需要额外的工作。以下是一些处理慢订阅者的方法：</p>
<ul>
<li><p><strong>在发布者中贮存消息</strong>。这是Gmail的做法，如果过去的几小时里没有阅读邮件的话，它会把邮件保存起来。但在高吞吐量的应用中，发布者堆积消息往往会导致内存溢出，最终崩溃。特别是当同是有多个订阅者时，或者无法用磁盘来做一个缓冲，情况就会变得更为复杂。</p>
</li>
<li><p><strong>在订阅者中贮存消息</strong>。这种做法要好的多，其实ZMQ默认的行为就是这样的。如果非得有一个人会因为内存溢出而崩溃，那也只会是订阅者，而非发布者，这挺公平的。然而，这种做法只对瞬间消息量很大的应用才合理，订阅者只是一时处理不过来，但最终会赶上进度。但是，这还是没有解决订阅者速度过慢的问题。</p>
</li>
<li><p><strong>暂停发送消息</strong>。这也是Gmail的做法，当我的邮箱容量超过7.554GB时，新的邮件就会被Gmail拒收或丢弃。这种做法对发布者来说很有益，ZMQ中若设置了阈值（HWM），其默认行为也就是这样的。但是，我们仍不能解决慢订阅者的问题，我们只是让消息变得断断续续而已。</p>
</li>
<li><p><strong>断开与满订阅者的连接</strong>。这是hotmail的做法，如果连续两周没有登录，它就会断开，这也是为什么我正在使用第十五个hotmail邮箱。不过这种方案在ZMQ里是行不通的，因为对于发布者而言，订阅者是不可见的，无法做相应处理。</p>
</li>
</ul>
<p>看来没有一种经典的方式可以满足我们的需求，所以我们就要进行创新了。我们可以让订阅者自杀，而不仅仅是断开连接。这就是“自杀的蜗牛”模式。当订阅者发现自身运行得过慢时（对于慢速的定义应该是一个配置项，当达到这个标准时就大声地喊出来吧，让程序员知道），它会哀嚎一声，然后自杀。</p>
<p>订阅者如何检测自身速度过慢呢？一种方式是为消息进行编号，并在发布者端设置阈值。当订阅者发现消息编号不连续时，它就知道事情不对劲了。这里的阈值就是订阅者自杀的值。</p>
<p>这种方案有两个问题：一、如果我们连接的多个发布者，我们要如何为消息进行编号呢？解决方法是为每一个发布者设定一个唯一的编号，作为消息编号的一部分。二、如果订阅者使用ZMQ_SUBSRIBE选项对消息进行了过滤，那么我们精心设计的消息编号机制就毫无用处了。</p>
<p>有些情形不会进行消息的过滤，所以消息编号还是行得通的。不过更为普遍的解决方案是，发布者为消息标注时间戳，当订阅者收到消息时会检测这个时间戳，如果其差别达到某一个值，就发出警报并自杀。</p>
<p>当订阅者有自身的客户端或服务协议，需要保证最大延迟时间时，自杀的蜗牛模式会很合适。撤销一个订阅者也许并不是最周全的方案，但至少不会引发后续的问题。如果订阅者收到了过时的消息，那可能会对数据造成进一步的破坏，而且很难被发现。</p>
<p>以下是自杀的蜗牛模式的最简实现：</p>
<p><strong>suisnail: Suicidal Snail in C</strong></p>
<pre><code class="c">//
//  自杀的蜗牛模式
//
#include &quot;czmq.h&quot;

//  ---------------------------------------------------------------------
//  该订阅者会连接至发布者，接收所有的消息，
//  运行过程中它会暂停一会儿，模拟复杂的运算过程，
//  当发现收到的消息超过1秒的延迟时，就自杀。

#define MAX_ALLOWED_DELAY   1000    //  毫秒

static void
subscriber (void *args, zctx_t *ctx, void *pipe)
{
    //  订阅所有消息
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5556&quot;);

    //  获取并处理消息
    while (1) {
        char *string = zstr_recv (subscriber);
        int64_t clock;
        int terms = sscanf (string, &quot;%&quot; PRId64, &amp;clock);
        assert (terms == 1);
        free (string);

        //  自杀逻辑
        if (zclock_time () - clock &gt; MAX_ALLOWED_DELAY) {
            fprintf (stderr, &quot;E: 订阅者无法跟进, 取消中\n&quot;);
            break;
        }
        //  工作一定时间
        zclock_sleep (1 + randof (2));
    }
    zstr_send (pipe, &quot;订阅者中止&quot;);
}


//  ---------------------------------------------------------------------
//  发布者每毫秒发送一条用时间戳标记的消息

static void
publisher (void *args, zctx_t *ctx, void *pipe)
{
    //  准备发布者
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5556&quot;);

    while (1) {
        //  发送当前时间（毫秒）给订阅者
        char string [20];
        sprintf (string, &quot;%&quot; PRId64, zclock_time ());
        zstr_send (publisher, string);
        char *signal = zstr_recv_nowait (pipe);
        if (signal) {
            free (signal);
            break;
        }
        zclock_sleep (1);            //  等待1毫秒
    }
}


//  下面的代码会启动一个订阅者和一个发布者，当订阅者死亡时停止运行
//
int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *pubpipe = zthread_fork (ctx, publisher, NULL);
    void *subpipe = zthread_fork (ctx, subscriber, NULL);
    free (zstr_recv (subpipe));
    zstr_send (pubpipe, &quot;break&quot;);
    zclock_sleep (100);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>示例程序中的消息包含了系统当前的时间戳（毫秒）。在现实应用中，你应该使用时间戳作为消息头，并提供消息内容。</li>
<li>示例程序中的发布者和订阅者是同一个进程的两个线程。在现实应用中，他们应该是两个不同的进程。示例中这么做只是为了演示的方便</li>
</ul>
<h3 id="高速订阅者（黑箱模式）"><a href="#高速订阅者（黑箱模式）" class="headerlink" title="高速订阅者（黑箱模式）"></a>高速订阅者（黑箱模式）</h3><p>发布-订阅模式的一个典型应用场景是大规模分布式数据处理。如要处理从证券市场上收集到的数据，可以在证券交易系统上设置一个发布者，获取价格信息，并发送给一组订阅者。如果我们有很多订阅者，我们可以使用TCP。如果订阅者到达一定的量，那我们就应该使用可靠的广播协议，如pgm。</p>
<p>假设我们的发布者每秒产生10万条100个字节的消息。在剔除了不需要的市场信息后，这个比率还是比较合理的。现在我们需要记录一天的数据（8小时约有250GB），再将其传入一个模拟网络，即一组订阅者。虽然10万条数据对ZMQ来说很容易处理，但我们需要更高的速度。</p>
<p>假设我们有多台机器，一台做发布者，其他的做订阅者。这些机器都是8核的，发布者那台有12核。</p>
<p>在我们开始发布消息时，有两点需要注意：</p>
<ol>
<li>即便只是处理很少的数据，订阅者仍有可能跟不上发布者的速度；</li>
<li>当处理到6M/s的数据量时，发布者和订阅者都有可能达到极限。</li>
</ol>
<p>首先，我们需要将订阅者设计为一种多线程的处理程序，这样我们就能在一个线程中读取消息，使用其他线程来处理消息。一般来说，我们对每种消息的处理方式都是不同的。这样一来，订阅者可以对收到的消息进行一次过滤，如根据头信息来判别。当消息满足某些条件，订阅者会将消息交给worker处理。用ZMQ的语言来说，订阅者会将消息转发给worker来处理。</p>
<p>这样一来，订阅者看上去就像是一个队列装置，我们可以用各种方式去连接队列装置和worker。如我们建立单向的通信，每个worker都是相同的，可以使用PUSH和PULL套接字，分发的工作就交给ZMQ吧。这是最简单也是最快速的方式：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_1.png" alt="1"></p>
<p>订阅者和发布者之间的通信使用TCP或PGM协议，订阅者和worker的通信由于是在同一个进程中完成的，所以使用inproc协议。</p>
<p>下面我们看看如何突破瓶颈。由于订阅者是单线程的，当它的CPU占用率达到100%时，它无法使用其他的核心。单线程程序总是会遇到瓶颈的，不管是2M、6M还是更多。我们需要将工作量分配到不同的线程中去，并发地执行。</p>
<p>很多高性能产品使用的方案是分片，就是将工作量拆分成独立并行的流。如，一半的专题数据由一个流媒体传输，另一半由另一个流媒体传输。我们可以建立更多的流媒体，但如果CPU核心数不变，那就没有必要了。<br>让我们看看如何将工作量分片为两个流：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_2.png" alt="2"></p>
<p>要让两个流全速工作，需要这样配置ZMQ：</p>
<ul>
<li>使用两个I/O线程，而不是一个；</li>
<li>使用两个独立的网络接口；</li>
<li>每个I/O线程绑定至一个网络接口；</li>
<li>两个订阅者线程，分别绑定至一个核心；</li>
<li>使用两个SUB套接字；</li>
<li>剩余的核心供worker使用；</li>
<li>worker线程同时绑定至两个订阅者线程的PUSH套接字。</li>
</ul>
<p>创建的线程数量应和CPU核心数一致，如果我们建立的线程数量超过核心数，那其处理速度只会减少。另外，开放多个I/O线程也是没有必要的。</p>
<h3 id="共享键值缓存（克隆模式）"><a href="#共享键值缓存（克隆模式）" class="headerlink" title="共享键值缓存（克隆模式）"></a>共享键值缓存（克隆模式）</h3><p>发布-订阅模式和无线电广播有些类似，在你收听之前发送的消息你将无从得知，收到消息的多少又会取决于你的接收能力。让人吃惊的是，对于那些追求完美的工程师来说，这种机器恰恰符合他们的需求，且广为传播，成为现实生活中分发消息的最佳机制。想想非死不可、推特、BBS新闻、体育新闻等应用就知道了。</p>
<p>但是，在很多情形下，可靠的发布-订阅模式同样是有价值的。正如我们讨论请求-应答模式一样，我们会根据“故障”来定义“可靠性”，下面几项便是发布-订阅模式中可能发生的故障：</p>
<ul>
<li>订阅者连接太慢，因此没有收到发布者最初发送的消息；</li>
<li>订阅者速度太慢，同样会丢失消息；</li>
<li>订阅者可能会断开，其间的消息也会丢失。</li>
</ul>
<p>还有一些情况我们碰到的比较少，但不是没有：</p>
<ul>
<li>订阅者崩溃、重启，从而丢失了所有已收到的消息；</li>
<li>订阅者处理消息的速度过慢，导致消息在队列中堆砌并溢出；</li>
<li>因网络过载而丢失消息（特别是PGM协议下的连接）；</li>
<li>网速过慢，消息在发布者处溢出，从而崩溃。</li>
</ul>
<p>其实还会有其他出错的情况，只是以上这些在现实应用中是比较典型的。</p>
<p>我们已经有方法解决上面的某些问题了，比如对于慢速订阅者可以使用自杀的蜗牛模式。但是，对于其他的问题，我们最后能有一个可复用的框架来编写可靠的发布-订阅模式。</p>
<p>难点在于，我们并不知道目标应用程序会怎样处理这些数据。它们会进行过滤、只处理一部分消息吗？它们是否会将消息记录起来供日后使用？它们是否会将消息转发给其下的worker进行处理？需要考虑的情况实在太多了，每种情况都有其所谓的可靠性。</p>
<p>所以，我们将问题抽象出来，供多种应用程序使用。这种抽象应用我们称之为共享的键值缓存，它的功能是通过唯一的键名存储二进制数据块。</p>
<p>不要将这个抽象应用和分布式哈希表混淆起来，它是用来解决节点在分布式网络中相连接的问题的；也不要和分布式键值表混淆，它更像是一个NoSQL数据库。我们要建立的应用是将内存中的状态可靠地传递给一组客户端，它要做到的是：</p>
<ul>
<li>客户端可以随时加入网络，并获得服务端当前的状态；</li>
<li>任何客户端都可以改变键值缓存（插入、更新、删除）；</li>
<li>将这种变化以最短的延迟可靠地传达给所有的客户端；</li>
<li>能够处理大量的客户端，成百上千。</li>
</ul>
<p>克隆模式的要点在于客户端会反过来和服务端进行通信，这在简单的发布-订阅模式中并不常见。所以我这里使用“服务端”、“客户端”而不是“发布者”、“订阅者”这两个词。我们会使用发布-订阅模式作为核心消息模式，不过还需要夹杂其他模式。</p>
<h4 id="分发键值更新事件"><a href="#分发键值更新事件" class="headerlink" title="分发键值更新事件"></a>分发键值更新事件</h4><p>我们会分阶段实施克隆模式。首先，我们看看如何从服务器发送键值更新事件给所有的客户端。我们将第一章中使用的天气服务模型进行改造，以键值对的方式发送信息，并让客户端使用哈希表来保存：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_3.png" alt="3"></p>
<p>以下是服务端代码：</p>
<p><strong>clonesrv1: Clone server, Model One in C</strong></p>
<pre><code class="c">//
//  克隆模式服务端模型1
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和PUB套接字
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5556&quot;);
    zclock_sleep (200);

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    while (!zctx_interrupted) {
        //  使用键值对分发消息
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
        kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_store   (&amp;kvmsg, kvmap);
    }
    printf (&quot; 已中止\n已发送 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli1: Clone client, Model One in C</strong></p>
<pre><code class="c">//
//  克隆模式客户端模型1
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *updates = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (updates, &quot;tcp://localhost:5556&quot;);

    zhash_t *kvmap = zhash_new ();
    int64_t sequence = 0;

    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (updates);
        if (!kvmsg)
            break;          //  中断
        kvmsg_store (&amp;kvmsg, kvmap);
        sequence++;
    }
    printf (&quot; 已中断\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>所有复杂的工作都在kvmsg类中完成了，这个类能够处理键值对类型的消息对象，其实质上是一个ZMQ多帧消息，共有三帧：键（ZMQ字符串）、编号（64位，按字节顺序排列）、二进制体（保存所有附加信息）。</li>
<li>服务端随机生成消息，使用四位数作为键，这样可以模拟大量而不是过量的哈希表（1万个条目）。</li>
<li>服务端绑定套接字后会等待200毫秒，以避免订阅者连接延迟而丢失数据的问题。我们会在后面的模型中解决这一点。</li>
<li>我们使用“发布者”和“订阅者”来命名程序中使用的套接字，这样可以避免和后续模型中的其他套接字发生混淆。</li>
</ul>
<p>以下是kvmsg的代码，已经经过了精简：<br><strong>kvsimple: Key-value message class in C</strong></p>
<pre><code class="c">/*  =====================================================================
    kvsimple - simple key-value message class for example applications

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;kvsimple.h&quot;
#include &quot;zlist.h&quot;

//  键是一个短字符串
#define KVMSG_KEY_MAX   255

//  消息被格式化成三帧
//  frame 0: 键（ZMQ字符串）
//  frame 1: 编号（8个字节，按顺序排列）
//  frame 2: 内容（二进制数据块）
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_BODY      2
#define KVMSG_FRAMES    3

//  类结构
struct _kvmsg {
    //  消息中某帧是否存在
    int present [KVMSG_FRAMES];
    //  对应的ZMQ消息帧
    zmq_msg_t frame [KVMSG_FRAMES];
    //  将键转换为C语言字符串
    char key [KVMSG_KEY_MAX + 1];
};


//  ---------------------------------------------------------------------
//  构造函数，设置编号

kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    kvmsg_set_sequence (self, sequence);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

//  释放消息中的帧，可供zhash_freefn()函数调用
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  销毁消息中的帧
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  释放对象本身
        free (self);
    }
}

void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  从套接字中读取键值消息，返回kvmsg实例

kvmsg_t *
kvmsg_recv (void *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (0);

    //  读取所有帧，出错则销毁对象
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = 1;
        if (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], 0) == -1) {
            kvmsg_destroy (&amp;self);
            break;
        }
        //  验证多帧消息
        int rcvmore = (frame_nbr &lt; KVMSG_FRAMES - 1)? 1: 0;
        if (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            break;
        }
    }
    return self;
}


//  ---------------------------------------------------------------------
//  向套接字发送键值对消息，不检验消息帧的内容

void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        if (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - 1)? ZMQ_SNDMORE: 0);
        zmq_msg_close (&amp;copy);
    }
}


//  ---------------------------------------------------------------------
//  从消息中获取键值，不存在则返回NULL

char *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_KEY]) {
        if (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            if (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = 0;
        }
        return self-&gt;key;
    }
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的编号

int64_t
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == 8);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        int64_t sequence = ((int64_t) (source [0]) &lt;&lt; 56)
                         + ((int64_t) (source [1]) &lt;&lt; 48)
                         + ((int64_t) (source [2]) &lt;&lt; 40)
                         + ((int64_t) (source [3]) &lt;&lt; 32)
                         + ((int64_t) (source [4]) &lt;&lt; 24)
                         + ((int64_t) (source [5]) &lt;&lt; 16)
                         + ((int64_t) (source [6]) &lt;&lt; 8)
                         +  (int64_t) (source [7]);
        return sequence;
    }
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  返回消息内容，不存在则返回NULL

byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息内容的大小

size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  设置消息的键

void
kvmsg_set_key (kvmsg_t *self, char *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    if (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的编号

void
kvmsg_set_sequence (kvmsg_t *self, int64_t sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    if (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, 8);

    byte *source = zmq_msg_data (msg);
    source [0] = (byte) ((sequence &gt;&gt; 56) &amp; 255);
    source [1] = (byte) ((sequence &gt;&gt; 48) &amp; 255);
    source [2] = (byte) ((sequence &gt;&gt; 40) &amp; 255);
    source [3] = (byte) ((sequence &gt;&gt; 32) &amp; 255);
    source [4] = (byte) ((sequence &gt;&gt; 24) &amp; 255);
    source [5] = (byte) ((sequence &gt;&gt; 16) &amp; 255);
    source [6] = (byte) ((sequence &gt;&gt; 8)  &amp; 255);
    source [7] = (byte) ((sequence)       &amp; 255);

    self-&gt;present [FRAME_SEQ] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息内容

void
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    if (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = 1;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息键

void
kvmsg_fmt_key (kvmsg_t *self, char *format, ...)
{
    char value [KVMSG_KEY_MAX + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}


//  ---------------------------------------------------------------------
//  使用springf()格式设置消息内容

void
kvmsg_fmt_body (kvmsg_t *self, char *format, ...)
{
    char value [255 + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}


//  ---------------------------------------------------------------------
//  若kvmsg结构的键值均存在，则存入哈希表；
//  如果kvmsg结构已没有引用，则自动销毁和释放。

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (self-&gt;present [FRAME_KEY]
        &amp;&amp;  self-&gt;present [FRAME_BODY]) {
            zhash_update (hash, kvmsg_key (self), self);
            zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
        }
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  将消息内容打印至标准错误输出，用以调试和跟踪

void
kvmsg_dump (kvmsg_t *self)
{
    if (self) {
        if (!self) {
            fprintf (stderr, &quot;NULL&quot;);
            return;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, &quot;[seq:%&quot; PRId64 &quot;]&quot;, kvmsg_sequence (self));
        fprintf (stderr, &quot;[key:%s]&quot;, kvmsg_key (self));
        fprintf (stderr, &quot;[size:%zd] &quot;, size);
        int char_nbr;
        for (char_nbr = 0; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, &quot;%02X&quot;, body [char_nbr]);
        fprintf (stderr, &quot;\n&quot;);
    }
    else
        fprintf (stderr, &quot;NULL message\n&quot;);
}


//  ---------------------------------------------------------------------
//  测试用例

int
kvmsg_test (int verbose)
{
    kvmsg_t
        *kvmsg;

    printf (&quot; * kvmsg: &quot;);

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *output = zsocket_new (ctx, ZMQ_DEALER);
    int rc = zmq_bind (output, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);
    void *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);

    zhash_t *kvmap = zhash_new ();

    //  测试简单消息的发送和接受
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    kvmsg_store (&amp;kvmsg, kvmap);

    //  关闭并销毁所有对象
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    printf (&quot;OK\n&quot;);
    return 0;
}
</code></pre>
<p>我们会在下文编写一个更为完整的kvmsg类，可以用到现实环境中。</p>
<p>客户端和服务端都会维护一个哈希表，但这个模型需要所有的客户端都比服务端启动得早，而且不能崩溃，这显然不能满足可靠性的要求。</p>
<h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><p>为了让后续连接的（或从故障中恢复的）客户端能够获取服务器上的状态信息，需要让它在连接时获取一份快照。正如我们将“消息”的概念简化为“已编号的键值对”，我们也可以将“状态”简化为“一个哈希表”。为获取服务端状态，客户端会打开一个REQ套接字进行请求：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_4.png" alt="4"></p>
<p>我们需要考虑时间的问题，因为生成快照是需要一定时间的，我们需要知道应从哪个更新事件开始更新快照，服务端是不知道何时有更新事件的。一种方法是先开始订阅消息，收到第一个消息之后向服务端请求“将该条更新之前的所有内容发送给”。这样一来，服务器需要为每一次更新保存一份快照，这显然是不现实的。</p>
<p>所以，我们会在客户端用以下方式进行同步：</p>
<ul>
<li><p>客户端开始订阅服务器的更新事件，然后请求一份快照。这样就能保证这份快照是在上一次更新事件之后产生的。</p>
</li>
<li><p>客户端开始等待服务器的快照，并将更新事件保存在队列中，做法很简单，不要从套接字中读取消息就可以了，ZMQ会自动将这些消息保存起来，这时不应设置阈值（HWM）。</p>
</li>
<li><p>当客户端获取到快照后，它将再次开始读取更新事件，但是需要丢弃那些早于快照生成时间的事件。如快照生成时包含了200次更新，那客户端会从第201次更新开始读取。</p>
</li>
<li><p>随后，客户端就会用更新事件去更新自身的状态了。</p>
</li>
</ul>
<p>这是一个比较简单的模型，因为它用到了ZMQ消息队列的机制。服务端代码如下：</p>
<p><strong>clonesrv2: Clone server, Model Two in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 服务端 - 模型2
//

//  让我们直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);
static void state_manager (void *args, zctx_t *ctx, void *pipe);

int main (void)
{
    //  准备套接字和上下文
    zctx_t *ctx = zctx_new ();
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);

    int64_t sequence = 0;
    srandom ((unsigned) time (NULL));

    //  开启状态管理器，并等待同步信号
    void *updates = zthread_fork (ctx, state_manager, NULL);
    free (zstr_recv (updates));

    while (!zctx_interrupted) {
        //  分发键值消息
        kvmsg_t *kvmsg = kvmsg_new (++sequence);
        kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
        kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
        kvmsg_send     (kvmsg, publisher);
        kvmsg_send     (kvmsg, updates);
        kvmsg_destroy (&amp;kvmsg);
    }
    printf (&quot; 已中断\n已发送 %d 条消息\n&quot;, (int) sequence);
    zctx_destroy (&amp;ctx);
    return 0;
}

//  快照请求方信息
typedef struct {
    void *socket;           //  用于发送快照的ROUTER套接字
    zframe_t *identity;     //  请求方的标识
} kvroute_t;

//  发送快照中单个键值对
//  使用kvmsg对象作为载体
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  先发送接收方标识
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}

//  该线程维护服务端状态，并处理快照请求。
//
static void
state_manager (void *args, zctx_t *ctx, void *pipe)
{
    zhash_t *kvmap = zhash_new ();

    zstr_send (pipe, &quot;READY&quot;);
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);

    zmq_pollitem_t items [] = {
        { pipe, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    int64_t sequence = 0;       //  当前快照版本
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, -1);
        if (rc == -1 &amp;&amp; errno == ETERM)
            break;              //  上下文异常

        //  等待主线程的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (pipe);
            if (!kvmsg)
                break;          //  中断
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        //  执行快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  中断

            //  请求内容在第二帧中
            char *request = zstr_recv (snapshot);
            if (streq (request, &quot;ICANHAZ?&quot;))
                free (request);
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照给客户端
            kvroute_t routing = { snapshot, identity };

            //  逐项发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识，内含快照版本号
            printf (&quot;正在发送快照，版本号 %d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    zhash_destroy (&amp;kvmap);
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli2: Clone client, Model Two in C</strong></p>
<pre><code class="c">//
// 克隆模式 - 客户端 - 模型2
//

//  让我们直接编译，不生成类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);

    zhash_t *kvmap = zhash_new ();

    //  获取快照
    int64_t sequence = 0;
    zstr_send (snapshot, &quot;ICANHAZ?&quot;);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  中断
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;已获取快照，版本号=%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  完成
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    //  应用队列中的更新事件，丢弃过时事件
    while (!zctx_interrupted) {
        kvmsg_t *kvmsg = kvmsg_recv (subscriber);
        if (!kvmsg)
            break;          //  中断
        if (kvmsg_sequence (kvmsg) &gt; sequence) {
            sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, kvmap);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>客户端使用两个线程，一个用来生成随机的更新事件，另一个用来管理状态。两者之间使用PAIR套接字通信。可能你会考虑使用SUB套接字，但是“慢连接”的问题会影响到程序运行。PAIR套接字会让两个线程严格同步的。</p>
</li>
<li><p>我们在updates套接字上设置了阈值（HWM），避免更新服务内存溢出。在inproc协议的连接中，阈值是两端套接字阈值的加和，所以要分别设置。</p>
</li>
<li><p>客户端比较简单，用C语言编写，大约60行代码。大多数工作都在kvmsg类中完成了，不过总的来说，克隆模式实现起来还是比较简单的。</p>
</li>
<li><p>我们没有用特别的方式来序列化状态内容。键值对用kvmsg对象表示，保存在一个哈希表中。在不同的时间请求状态时会得到不同的快照。</p>
</li>
<li><p>我们假设客户端只和一个服务进行通信，而且服务必须是正常运行的。我们暂不考虑如何从服务崩溃的情形中恢复过来。</p>
</li>
</ul>
<p>现在，这两段程序都还没有真正地工作起来，但已经能够正确地同步状态了。这是一个多种消息模式的混合体：进程内的PAIR、发布-订阅、ROUTER-DEALER等。</p>
<h4 id="重发键值更新事件"><a href="#重发键值更新事件" class="headerlink" title="重发键值更新事件"></a>重发键值更新事件</h4><p>第二个模型中，键值更新事件都来自于服务器，构成了一个中心化的模型。但是我们需要的是一个能够在客户端进行更新的缓存，并能同步到其他客户端中。这时，服务端只是一个无状态的中间件，带来的好处有：</p>
<ul>
<li>我们不用太过关心服务端的可靠性，因为即使它崩溃了，我们仍能从客户端中获取完整的数据。</li>
<li>我们可以使用键值缓存在动态节点之间分享数据。</li>
</ul>
<p>客户端的键值更新事件会通过PUSH-PULL套接字传达给服务端：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_5.png" alt="5"></p>
<p>我们为什么不让客户端直接将更新信息发送给其他客户端呢？虽然这样做可以减少延迟，但是就无法为更新事件添加自增的唯一编号了。很多应用程序都需要更新事件以某种方式排序，只有将消息发给服务端，由服务端分发更新消息，才能保证更新事件的顺序。</p>
<p>有了唯一的编号后，客户端还能检测到更多的故障：网络堵塞或队列溢出。如果客户端发现消息输入流有一段空白，它能采取措施。可能你会觉得此时让客户端通知服务端，让它重新发送丢失的信息，可以解决问题。但事实上没有必要这么做。消息流的空挡表示网络状况不好，如果再进行这样的请求，只会让事情变得更糟。所以一般的做法是由客户端发出警告，并停止运行，等到有专人来维护后再继续工作。<br>我们开始创建在客户端进行状态更新的模型。以下是客户端代码：</p>
<p><strong>clonesrv3: Clone server, Model Three in C</strong></p>
<pre><code class="c">//
//  克隆模式 服务端 模型3
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);

//  快照请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
} kvroute_t;


int main (void)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);
    void *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, &quot;tcp://*:5558&quot;);

    int64_t sequence = 0;
    zhash_t *kvmap = zhash_new ();

    zmq_pollitem_t items [] = {
        { collector, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC);

        //  执行来自客户端的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            if (!kvmsg)
                break;          //  中断
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (&quot;I: 发布更新事件 %5d\n&quot;, (int) sequence);
        }
        //  响应快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  中断

            //  请求内容在消息的第二帧中
            char *request = zstr_recv (snapshot);
            if (streq (request, &quot;ICANHAZ?&quot;))
                free (request);
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照
            kvroute_t routing = { snapshot, identity };

            //  逐条发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识和编号
            printf (&quot;I: 正在发送快照，版本号：%d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
        }
    }
    printf (&quot; 已中断\n已处理 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    return 0;
}

//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    //  Send identity of recipient first
    zframe_send (&amp;kvroute-&gt;identity,
        kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    kvmsg_send (kvmsg, kvroute-&gt;socket);
    return 0;
}
</code></pre>
<p>以下是客户端代码：</p>
<p><strong>clonecli3: Clone client, Model Three in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 客户端 - 模型3
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, &quot;tcp://localhost:5558&quot;);

    zhash_t *kvmap = zhash_new ();
    srandom ((unsigned) time (NULL));

    //  获取状态快照
    int64_t sequence = 0;
    zstr_send (snapshot, &quot;ICANHAZ?&quot;);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  中断
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;I: 已收到快照，版本号：%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  完成
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }
    int64_t alarm = zclock_time () + 1000;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, 0, ZMQ_POLLIN, 0 } };
        int tickless = (int) ((alarm - zclock_time ()));
        if (tickless &lt; 0)
            tickless = 0;
        int rc = zmq_poll (items, 1, tickless * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文被关闭

        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            if (!kvmsg)
                break;          //  中断

            //  丢弃过时消息，包括心跳
            if (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (&quot;I: 收到更新事件：%d\n&quot;, (int) sequence);
            }
            else
                kvmsg_destroy (&amp;kvmsg);
        }
        //  创建一个随机的更新事件
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, &quot;%d&quot;, randof (10000));
            kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
    }
    printf (&quot; 已准备\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>服务端整合为一个线程，负责收集来自客户端的更新事件并转发给其他客户端。它使用PULL套接字获取更新事件，ROUTER套接字处理快照请求，以及PUB套接字发布更新事件。</p>
</li>
<li><p>客户端会每隔1秒左右发送随机的更新事件给服务端，现实中这一动作由应用程序触发。</p>
</li>
</ul>
<h4 id="子树克隆"><a href="#子树克隆" class="headerlink" title="子树克隆"></a>子树克隆</h4><p>现实中的键值缓存会越变越多，而客户端可能只会需要部分缓存。我们可以使用子树的方式来实现：客户端在发送快照请求时告诉服务端它需要的子树，在订阅更新事件时也指明子树。</p>
<p>关于子树的语法有很多，一种是“分层路径”结构，另一种是“主题树”：</p>
<ul>
<li>分层路径：/some/list/of/paths<ul>
<li>主题树：some.list.of.topics</li>
</ul>
</li>
</ul>
<p>这里我们会使用分层路径结构，以此扩展服务端和客户端，进行子树操作。维护多个子树其实并不太困难，因此我们不在这里演示。</p>
<p>下面是服务端代码，由模型3衍化而来：</p>
<p><strong>clonesrv4: Clone server, Model Four in C</strong></p>
<pre><code class="c">//
//  克隆模式 服务端 模型4
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

static int s_send_single (char *key, void *data, void *args);

//  快照请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
    char *subtree;          //  指定的子树
} kvroute_t;


int main (void)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (snapshot, &quot;tcp://*:5556&quot;);
    void *publisher = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (publisher, &quot;tcp://*:5557&quot;);
    void *collector = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (collector, &quot;tcp://*:5558&quot;);

    int64_t sequence = 0;
    zhash_t *kvmap = zhash_new ();

    zmq_pollitem_t items [] = {
        { collector, 0, ZMQ_POLLIN, 0 },
        { snapshot, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        int rc = zmq_poll (items, 2, 1000 * ZMQ_POLL_MSEC);

        //  执行来自客户端的更新事件
        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (collector);
            if (!kvmsg)
                break;          //  Interrupted
            kvmsg_set_sequence (kvmsg, ++sequence);
            kvmsg_send (kvmsg, publisher);
            kvmsg_store (&amp;kvmsg, kvmap);
            printf (&quot;I: 发布更新事件 %5d\n&quot;, (int) sequence);
        }
        //  响应快照请求
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zframe_t *identity = zframe_recv (snapshot);
            if (!identity)
                break;          //  Interrupted

            //  请求内容在消息的第二帧中
            char *request = zstr_recv (snapshot);
            char *subtree = NULL;
            if (streq (request, &quot;ICANHAZ?&quot;)) {
                free (request);
                subtree = zstr_recv (snapshot);
            }
            else {
                printf (&quot;E: 错误的请求，程序中止\n&quot;);
                break;
            }
            //  发送快照
            kvroute_t routing = { snapshot, identity, subtree };

            //  逐条发送
            zhash_foreach (kvmap, s_send_single, &amp;routing);

            //  发送结束标识和编号
            printf (&quot;I: 正在发送快照，版本号：%d\n&quot;, (int) sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    printf (&quot; 已中断\n已处理 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    return 0;
}

//  发送一条键值对状态给套接字，使用kvmsg对象保存键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方的标识
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}
</code></pre>
<p>下面是客户端代码：</p>
<p><strong>clonecli4: Clone client, Model Four in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 客户端 - 模型4
//

//  直接编译，不创建类库
#include &quot;kvsimple.c&quot;

#define SUBTREE &quot;/client/&quot;

int main (void)
{
    //  准备上下文和SUB套接字
    zctx_t *ctx = zctx_new ();
    void *snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (snapshot, &quot;tcp://localhost:5556&quot;);
    void *subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (subscriber, &quot;tcp://localhost:5557&quot;);
    zsockopt_set_subscribe (subscriber, SUBTREE);
    void *publisher = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (publisher, &quot;tcp://localhost:5558&quot;);

    zhash_t *kvmap = zhash_new ();
    srandom ((unsigned) time (NULL));

    //  获取状态快照
    int64_t sequence = 0;
    zstr_sendm (snapshot, &quot;ICANHAZ?&quot;);
    zstr_send  (snapshot, SUBTREE);
    while (TRUE) {
        kvmsg_t *kvmsg = kvmsg_recv (snapshot);
        if (!kvmsg)
            break;          //  Interrupted
        if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
            sequence = kvmsg_sequence (kvmsg);
            printf (&quot;I: 已收到快照，版本号：%d\n&quot;, (int) sequence);
            kvmsg_destroy (&amp;kvmsg);
            break;          //  Done
        }
        kvmsg_store (&amp;kvmsg, kvmap);
    }

    int64_t alarm = zclock_time () + 1000;
    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = { { subscriber, 0, ZMQ_POLLIN, 0 } };
        int tickless = (int) ((alarm - zclock_time ()));
        if (tickless &lt; 0)
            tickless = 0;
        int rc = zmq_poll (items, 1, tickless * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文被关闭

        if (items [0].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (subscriber);
            if (!kvmsg)
                break;          //  中断

            //  丢弃过时消息，包括心跳
            if (kvmsg_sequence (kvmsg) &gt; sequence) {
                sequence = kvmsg_sequence (kvmsg);
                kvmsg_store (&amp;kvmsg, kvmap);
                printf (&quot;I: 收到更新事件：%d\n&quot;, (int) sequence);
            }
            else
                kvmsg_destroy (&amp;kvmsg);
        }
        //  创建一个随机的更新事件
        if (zclock_time () &gt;= alarm) {
            kvmsg_t *kvmsg = kvmsg_new (0);
            kvmsg_fmt_key  (kvmsg, &quot;%s%d&quot;, SUBTREE, randof (10000));
            kvmsg_fmt_body (kvmsg, &quot;%d&quot;, randof (1000000));
            kvmsg_send     (kvmsg, publisher);
            kvmsg_destroy (&amp;kvmsg);
            alarm = zclock_time () + 1000;
        }
    }
    printf (&quot; 已准备\n收到 %d 条消息\n&quot;, (int) sequence);
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<h4 id="瞬间值"><a href="#瞬间值" class="headerlink" title="瞬间值"></a>瞬间值</h4><p>瞬间值指的是那些会立刻过期的值。如果你用克隆模式搭建一个类似DNS的服务时，就可以用瞬间值来模拟动态DNS解析了。当节点连接网络，对外发布它的地址，并不断地更新地址。如果节点断开连接，则它的地址也会失效。</p>
<p>瞬间值可以和会话（session）联系起来，当会话结束时，瞬间值也就失效了。克隆模式中，会话是由客户端定义的，并会在客户端断开连接时消亡。</p>
<p>更简单的方法是为每一个瞬间值设定一个过期时间，客户端会不断延长这个时间，当断开连接时这个时间将得不到更新，服务器就会自动将其删除。</p>
<p>我们会用这种简单的方法来实现瞬间值，因为太过复杂的方法可能不值当，它们的差别仅在性能上体现。如果客户端有很多瞬间值，那为每个值设定过期时间是恰当的；如果瞬间值到达一定的量，那最好还是将其和会话相关联，统一进行过期处理。</p>
<p>首先，我们需要设法在键值对消息中加入过期时间。我们可以增加一个消息帧，但这样一来每当我们需要增加消息内容时就需要修改kvmsg类库了，这并不合适。所以，我们一次性增加一个“属性”消息帧，用于添加不同的消息属性。</p>
<p>其次，我们需要设法删除这条数据。目前为止服务端和客户端会盲目地增改哈希表中的数据，我们可以这样定义：当消息的值是空的，则表示删除这个键的数据。</p>
<p>下面是一个更为完整的kvmsg类代码，它实现了“属性”帧，以及一个UUID帧，我们后面会用到。该类还会负责处理值为空的消息，达到删除的目的：</p>
<p><strong>kvmsg: Key-value message class - full in C</strong></p>
<pre><code class="c">/*  =====================================================================
    kvmsg - key-value message class for example applications

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;kvmsg.h&quot;
#include &lt;uuid/uuid.h&gt;
#include &quot;zlist.h&quot;

//  键是短字符串
#define KVMSG_KEY_MAX   255

//  消息包含五帧
//  frame 0: 键(ZMQ字符串)
//  frame 1: 编号(8个字节，按顺序排列)
//  frame 2: UUID(二进制块，16个字节)
//  frame 3: 属性(ZMQ字符串)
//  frame 4: 值(二进制块)
#define FRAME_KEY       0
#define FRAME_SEQ       1
#define FRAME_UUID      2
#define FRAME_PROPS     3
#define FRAME_BODY      4
#define KVMSG_FRAMES    5

//  类结构
struct _kvmsg {
    //  帧是否存在
    int present [KVMSG_FRAMES];
    //  对应消息帧
    zmq_msg_t frame [KVMSG_FRAMES];
    //  键，C语言字符串格式
    char key [KVMSG_KEY_MAX + 1];
    //  属性列表，key=value形式
    zlist_t *props;
    size_t props_size;
};


//  将属性列表序列化为字符串
static void
s_encode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    if (self-&gt;present [FRAME_PROPS])
        zmq_msg_close (msg);

    zmq_msg_init_size (msg, self-&gt;props_size);
    char *prop = zlist_first (self-&gt;props);
    char *dest = (char *) zmq_msg_data (msg);
    while (prop) {
        strcpy (dest, prop);
        dest += strlen (prop);
        *dest++ = &#39;\n&#39;;
        prop = zlist_next (self-&gt;props);
    }
    self-&gt;present [FRAME_PROPS] = 1;
}

//  从字符串中解析属性列表
static void
s_decode_props (kvmsg_t *self)
{
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_PROPS];
    self-&gt;props_size = 0;
    while (zlist_size (self-&gt;props))
        free (zlist_pop (self-&gt;props));

    size_t remainder = zmq_msg_size (msg);
    char *prop = (char *) zmq_msg_data (msg);
    char *eoln = memchr (prop, &#39;\n&#39;, remainder);
    while (eoln) {
        *eoln = 0;
        zlist_append (self-&gt;props, strdup (prop));
        self-&gt;props_size += strlen (prop) + 1;
        remainder -= strlen (prop) + 1;
        prop = eoln + 1;
        eoln = memchr (prop, &#39;\n&#39;, remainder);
    }
}


//  ---------------------------------------------------------------------
//  构造函数，指定消息编号

kvmsg_t *
kvmsg_new (int64_t sequence)
{
    kvmsg_t
        *self;

    self = (kvmsg_t *) zmalloc (sizeof (kvmsg_t));
    self-&gt;props = zlist_new ();
    kvmsg_set_sequence (self, sequence);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

//  释放内存函数，供zhash_free_fn()调用
void
kvmsg_free (void *ptr)
{
    if (ptr) {
        kvmsg_t *self = (kvmsg_t *) ptr;
        //  释放所有消息帧
        int frame_nbr;
        for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++)
            if (self-&gt;present [frame_nbr])
                zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);

        //  释放属性列表
        while (zlist_size (self-&gt;props))
            free (zlist_pop (self-&gt;props));
        zlist_destroy (&amp;self-&gt;props);

        //  释放对象本身
        free (self);
    }
}

void
kvmsg_destroy (kvmsg_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_free (*self_p);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  复制kvmsg对象

kvmsg_t *
kvmsg_dup (kvmsg_t *self)
{
    kvmsg_t *kvmsg = kvmsg_new (0);
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr]) {
            zmq_msg_t *src = &amp;self-&gt;frame [frame_nbr];
            zmq_msg_t *dst = &amp;kvmsg-&gt;frame [frame_nbr];
            zmq_msg_init_size (dst, zmq_msg_size (src));
            memcpy (zmq_msg_data (dst),
                    zmq_msg_data (src), zmq_msg_size (src));
            kvmsg-&gt;present [frame_nbr] = 1;
        }
    }
    kvmsg-&gt;props = zlist_copy (self-&gt;props);
    return kvmsg;
}


//  ---------------------------------------------------------------------
//  从套接字总读取键值对，返回kvmsg实例

kvmsg_t *
kvmsg_recv (void *socket)
{
    assert (socket);
    kvmsg_t *self = kvmsg_new (0);

    //  读取所有帧，若有异常则直接返回空
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        if (self-&gt;present [frame_nbr])
            zmq_msg_close (&amp;self-&gt;frame [frame_nbr]);
        zmq_msg_init (&amp;self-&gt;frame [frame_nbr]);
        self-&gt;present [frame_nbr] = 1;
        if (zmq_recvmsg (socket, &amp;self-&gt;frame [frame_nbr], 0) == -1) {
            kvmsg_destroy (&amp;self);
            break;
        }
        //  验证多帧消息
        int rcvmore = (frame_nbr &lt; KVMSG_FRAMES - 1)? 1: 0;
        if (zsockopt_rcvmore (socket) != rcvmore) {
            kvmsg_destroy (&amp;self);
            break;
        }
    }
    if (self)
        s_decode_props (self);
    return self;
}


//  ---------------------------------------------------------------------
//  向套接字发送键值对消息，空消息也发送

void
kvmsg_send (kvmsg_t *self, void *socket)
{
    assert (self);
    assert (socket);

    s_encode_props (self);
    int frame_nbr;
    for (frame_nbr = 0; frame_nbr &lt; KVMSG_FRAMES; frame_nbr++) {
        zmq_msg_t copy;
        zmq_msg_init (&amp;copy);
        if (self-&gt;present [frame_nbr])
            zmq_msg_copy (&amp;copy, &amp;self-&gt;frame [frame_nbr]);
        zmq_sendmsg (socket, &amp;copy,
            (frame_nbr &lt; KVMSG_FRAMES - 1)? ZMQ_SNDMORE: 0);
        zmq_msg_close (&amp;copy);
    }
}


//  ---------------------------------------------------------------------
//  返回消息的键

char *
kvmsg_key (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_KEY]) {
        if (!*self-&gt;key) {
            size_t size = zmq_msg_size (&amp;self-&gt;frame [FRAME_KEY]);
            if (size &gt; KVMSG_KEY_MAX)
                size = KVMSG_KEY_MAX;
            memcpy (self-&gt;key,
                zmq_msg_data (&amp;self-&gt;frame [FRAME_KEY]), size);
            self-&gt;key [size] = 0;
        }
        return self-&gt;key;
    }
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的编号

int64_t
kvmsg_sequence (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_SEQ]) {
        assert (zmq_msg_size (&amp;self-&gt;frame [FRAME_SEQ]) == 8);
        byte *source = zmq_msg_data (&amp;self-&gt;frame [FRAME_SEQ]);
        int64_t sequence = ((int64_t) (source [0]) &lt;&lt; 56)
                         + ((int64_t) (source [1]) &lt;&lt; 48)
                         + ((int64_t) (source [2]) &lt;&lt; 40)
                         + ((int64_t) (source [3]) &lt;&lt; 32)
                         + ((int64_t) (source [4]) &lt;&lt; 24)
                         + ((int64_t) (source [5]) &lt;&lt; 16)
                         + ((int64_t) (source [6]) &lt;&lt; 8)
                         +  (int64_t) (source [7]);
        return sequence;
    }
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  返回消息的UUID

byte *
kvmsg_uuid (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_UUID]
    &amp;&amp;  zmq_msg_size (&amp;self-&gt;frame [FRAME_UUID]) == sizeof (uuid_t))
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_UUID]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息的内容

byte *
kvmsg_body (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return (byte *) zmq_msg_data (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return NULL;
}


//  ---------------------------------------------------------------------
//  返回消息内容的长度

size_t
kvmsg_size (kvmsg_t *self)
{
    assert (self);
    if (self-&gt;present [FRAME_BODY])
        return zmq_msg_size (&amp;self-&gt;frame [FRAME_BODY]);
    else
        return 0;
}


//  ---------------------------------------------------------------------
//  设置消息的键

void
kvmsg_set_key (kvmsg_t *self, char *key)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_KEY];
    if (self-&gt;present [FRAME_KEY])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, strlen (key));
    memcpy (zmq_msg_data (msg), key, strlen (key));
    self-&gt;present [FRAME_KEY] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的编号

void
kvmsg_set_sequence (kvmsg_t *self, int64_t sequence)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_SEQ];
    if (self-&gt;present [FRAME_SEQ])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, 8);

    byte *source = zmq_msg_data (msg);
    source [0] = (byte) ((sequence &gt;&gt; 56) &amp; 255);
    source [1] = (byte) ((sequence &gt;&gt; 48) &amp; 255);
    source [2] = (byte) ((sequence &gt;&gt; 40) &amp; 255);
    source [3] = (byte) ((sequence &gt;&gt; 32) &amp; 255);
    source [4] = (byte) ((sequence &gt;&gt; 24) &amp; 255);
    source [5] = (byte) ((sequence &gt;&gt; 16) &amp; 255);
    source [6] = (byte) ((sequence &gt;&gt; 8)  &amp; 255);
    source [7] = (byte) ((sequence)       &amp; 255);

    self-&gt;present [FRAME_SEQ] = 1;
}


//  ---------------------------------------------------------------------
//  生成并设置消息的UUID

void
kvmsg_set_uuid (kvmsg_t *self)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_UUID];
    uuid_t uuid;
    uuid_generate (uuid);
    if (self-&gt;present [FRAME_UUID])
        zmq_msg_close (msg);
    zmq_msg_init_size (msg, sizeof (uuid));
    memcpy (zmq_msg_data (msg), uuid, sizeof (uuid));
    self-&gt;present [FRAME_UUID] = 1;
}


//  ---------------------------------------------------------------------
//  设置消息的内容

void
kvmsg_set_body (kvmsg_t *self, byte *body, size_t size)
{
    assert (self);
    zmq_msg_t *msg = &amp;self-&gt;frame [FRAME_BODY];
    if (self-&gt;present [FRAME_BODY])
        zmq_msg_close (msg);
    self-&gt;present [FRAME_BODY] = 1;
    zmq_msg_init_size (msg, size);
    memcpy (zmq_msg_data (msg), body, size);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息的键
void
kvmsg_fmt_key (kvmsg_t *self, char *format, ...)
{
    char value [KVMSG_KEY_MAX + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, KVMSG_KEY_MAX, format, args);
    va_end (args);
    kvmsg_set_key (self, value);
}


//  ---------------------------------------------------------------------
//  使用printf()格式设置消息内容

void
kvmsg_fmt_body (kvmsg_t *self, char *format, ...)
{
    char value [255 + 1];
    va_list args;

    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);
    kvmsg_set_body (self, (byte *) value, strlen (value));
}


//  ---------------------------------------------------------------------
//  获取消息属性，无则返回空字符串

char *
kvmsg_get_prop (kvmsg_t *self, char *name)
{
    assert (strchr (name, &#39;=&#39;) == NULL);
    char *prop = zlist_first (self-&gt;props);
    size_t namelen = strlen (name);
    while (prop) {
        if (strlen (prop) &gt; namelen
        &amp;&amp;  memcmp (prop, name, namelen) == 0
        &amp;&amp;  prop [namelen] == &#39;=&#39;)
            return prop + namelen + 1;
        prop = zlist_next (self-&gt;props);
    }
    return &quot;&quot;;
}


//  ---------------------------------------------------------------------
//  设置消息属性
//  属性名称不能包含=号，值的最大长度是255

void
kvmsg_set_prop (kvmsg_t *self, char *name, char *format, ...)
{
    assert (strchr (name, &#39;=&#39;) == NULL);

    char value [255 + 1];
    va_list args;
    assert (self);
    va_start (args, format);
    vsnprintf (value, 255, format, args);
    va_end (args);

    //  分配空间
    char *prop = malloc (strlen (name) + strlen (value) + 2);

    //  删除已存在的属性
    sprintf (prop, &quot;%s=&quot;, name);
    char *existing = zlist_first (self-&gt;props);
    while (existing) {
        if (memcmp (prop, existing, strlen (prop)) == 0) {
            self-&gt;props_size -= strlen (existing) + 1;
            zlist_remove (self-&gt;props, existing);
            free (existing);
            break;
        }
        existing = zlist_next (self-&gt;props);
    }
    //  添加新属性
    strcat (prop, value);
    zlist_append (self-&gt;props, prop);
    self-&gt;props_size += strlen (prop) + 1;
}


//  ---------------------------------------------------------------------
//  在哈希表中保存kvmsg对象
//  当kvmsg对象不再被使用时进行释放操作；
//  若传入的值为空，则删除该对象。

void
kvmsg_store (kvmsg_t **self_p, zhash_t *hash)
{
    assert (self_p);
    if (*self_p) {
        kvmsg_t *self = *self_p;
        assert (self);
        if (kvmsg_size (self)) {
            if (self-&gt;present [FRAME_KEY]
            &amp;&amp;  self-&gt;present [FRAME_BODY]) {
                zhash_update (hash, kvmsg_key (self), self);
                zhash_freefn (hash, kvmsg_key (self), kvmsg_free);
            }
        }
        else
            zhash_delete (hash, kvmsg_key (self));

        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  将消息内容输出到标准错误输出

void
kvmsg_dump (kvmsg_t *self)
{
    if (self) {
        if (!self) {
            fprintf (stderr, &quot;NULL&quot;);
            return;
        }
        size_t size = kvmsg_size (self);
        byte  *body = kvmsg_body (self);
        fprintf (stderr, &quot;[seq:%&quot; PRId64 &quot;]&quot;, kvmsg_sequence (self));
        fprintf (stderr, &quot;[key:%s]&quot;, kvmsg_key (self));
        fprintf (stderr, &quot;[size:%zd] &quot;, size);
        if (zlist_size (self-&gt;props)) {
            fprintf (stderr, &quot;[&quot;);
            char *prop = zlist_first (self-&gt;props);
            while (prop) {
                fprintf (stderr, &quot;%s;&quot;, prop);
                prop = zlist_next (self-&gt;props);
            }
            fprintf (stderr, &quot;]&quot;);
        }
        int char_nbr;
        for (char_nbr = 0; char_nbr &lt; size; char_nbr++)
            fprintf (stderr, &quot;%02X&quot;, body [char_nbr]);
        fprintf (stderr, &quot;\n&quot;);
    }
    else
        fprintf (stderr, &quot;NULL message\n&quot;);
}


//  ---------------------------------------------------------------------
//  测试用例

int
kvmsg_test (int verbose)
{
    kvmsg_t
        *kvmsg;

    printf (&quot; * kvmsg: &quot;);

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *output = zsocket_new (ctx, ZMQ_DEALER);
    int rc = zmq_bind (output, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);
    void *input = zsocket_new (ctx, ZMQ_DEALER);
    rc = zmq_connect (input, &quot;ipc://kvmsg_selftest.ipc&quot;);
    assert (rc == 0);

    zhash_t *kvmap = zhash_new ();

    //  测试简单消息的收发
    kvmsg = kvmsg_new (1);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_store (&amp;kvmsg, kvmap);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    kvmsg_store (&amp;kvmsg, kvmap);

    // 测试带有属性的消息的收发
    kvmsg = kvmsg_new (2);
    kvmsg_set_prop (kvmsg, &quot;prop1&quot;, &quot;value1&quot;);
    kvmsg_set_prop (kvmsg, &quot;prop2&quot;, &quot;value1&quot;);
    kvmsg_set_prop (kvmsg, &quot;prop2&quot;, &quot;value2&quot;);
    kvmsg_set_key  (kvmsg, &quot;key&quot;);
    kvmsg_set_uuid (kvmsg);
    kvmsg_set_body (kvmsg, (byte *) &quot;body&quot;, 4);
    assert (streq (kvmsg_get_prop (kvmsg, &quot;prop2&quot;), &quot;value2&quot;));
    if (verbose)
        kvmsg_dump (kvmsg);
    kvmsg_send (kvmsg, output);
    kvmsg_destroy (&amp;kvmsg);

    kvmsg = kvmsg_recv (input);
    if (verbose)
        kvmsg_dump (kvmsg);
    assert (streq (kvmsg_key (kvmsg), &quot;key&quot;));
    assert (streq (kvmsg_get_prop (kvmsg, &quot;prop2&quot;), &quot;value2&quot;));
    kvmsg_destroy (&amp;kvmsg);

    //  关闭并销毁所有对象
    zhash_destroy (&amp;kvmap);
    zctx_destroy (&amp;ctx);

    printf (&quot;OK\n&quot;);
    return 0;
}
</code></pre>
<p>客户端模型5和模型4没有太大区别，只是kvmsg类库变了。在更新消息的时候还需要添加一个过期时间的属性：</p>
<pre><code class="c">kvmsg_set_prop (kvmsg, &quot;ttl&quot;, &quot;%d&quot;, randof (30));
</code></pre>
<p>服务端模型5有较大的变化，我们会用反应堆来代替轮询，这样就能混合处理定时事件和套接字事件了，只是在C语言中是比较麻烦的。下面是代码：</p>
<p><strong>clonesrv5: Clone server, Model Five in C</strong></p>
<pre><code class="c">//
//  克隆模式 - 服务端 - 模型5
//

//  直接编译，不建类库
#include &quot;kvmsg.c&quot;

//  反应堆处理器
static int s_snapshots  (zloop_t *loop, void *socket, void *args);
static int s_collector  (zloop_t *loop, void *socket, void *args);
static int s_flush_ttl  (zloop_t *loop, void *socket, void *args);

//  服务器属性
typedef struct {
    zctx_t *ctx;                //  上下文
    zhash_t *kvmap;             //  键值对存储
    zloop_t *loop;              //  zloop反应堆
    int port;                   //  主端口
    int64_t sequence;           //  更新事件编号
    void *snapshot;             //  处理快照请求
    void *publisher;            //  发布更新事件
    void *collector;            //  从客户端收集接收更新事件
} clonesrv_t;


int main (void)
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));

    self-&gt;port = 5556;
    self-&gt;ctx = zctx_new ();
    self-&gt;kvmap = zhash_new ();
    self-&gt;loop = zloop_new ();
    zloop_set_verbose (self-&gt;loop, FALSE);

    //  打开克隆模式服务端套接字
    self-&gt;snapshot  = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_PULL);
    zsocket_bind (self-&gt;snapshot,  &quot;tcp://*:%d&quot;, self-&gt;port);
    zsocket_bind (self-&gt;publisher, &quot;tcp://*:%d&quot;, self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, &quot;tcp://*:%d&quot;, self-&gt;port + 2);

    //  注册反应堆处理程序
    zloop_reader (self-&gt;loop, self-&gt;snapshot, s_snapshots, self);
    zloop_reader (self-&gt;loop, self-&gt;collector, s_collector, self);
    zloop_timer  (self-&gt;loop, 1000, 0, s_flush_ttl, self);

    //  运行反应堆，直至中断
    zloop_start (self-&gt;loop);

    zloop_destroy (&amp;self-&gt;loop);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);
    return 0;
}


//  ---------------------------------------------------------------------
//  发送快照内容

static int s_send_single (char *key, void *data, void *args);

//  请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求方标识
    char *subtree;          //  子树信息
} kvroute_t;

static int
s_snapshots (zloop_t *loop, void *snapshot, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zframe_t *identity = zframe_recv (snapshot);
    if (identity) {
        //  请求位于消息第二帧
        char *request = zstr_recv (snapshot);
        char *subtree = NULL;
        if (streq (request, &quot;ICANHAZ?&quot;)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        else
            printf (&quot;E: 错误的请求，程序中止\n&quot;);

        if (subtree) {
            //  发送状态快照
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);

            //  发送结束符和版本号
            zclock_log (&quot;I: 正在发送快照，版本号：%d&quot;, (int) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    return 0;
}


//  每次发送一个快照键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方标识
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  收集更新事件

static int
s_collector (zloop_t *loop, void *collector, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (collector);
    if (kvmsg) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        int ttl = atoi (kvmsg_get_prop (kvmsg, &quot;ttl&quot;));
        if (ttl)
            kvmsg_set_prop (kvmsg, &quot;ttl&quot;,
                &quot;%&quot; PRId64, zclock_time () + ttl * 1000);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布更新事件 %d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  删除过期的瞬间值

static int s_flush_single (char *key, void *data, void *args);

static int
s_flush_ttl (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    return 0;
}

//  删除过期的键值对，并广播该事件
static int
s_flush_single (char *key, void *data, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = (kvmsg_t *) data;
    int64_t ttl;
    sscanf (kvmsg_get_prop (kvmsg, &quot;ttl&quot;), &quot;%&quot; PRId64, &amp;ttl);
    if (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 发布删除事件 %d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}
</code></pre>
<h4 id="克隆服务器的可靠性"><a href="#克隆服务器的可靠性" class="headerlink" title="克隆服务器的可靠性"></a>克隆服务器的可靠性</h4><p>克隆模型1至5相对比较简单，下面我们会探讨一个非常复杂的模型。可以发现，为了构建可靠的消息队列，我们需要花费非常多的精力。所以我们经常会问：有必要这么做吗？如果说你能够接受可靠性不够高的、或者说已经足够好的架构，那恭喜你，你在成本和收益之间找到了平衡。虽然我们会偶尔丢失一些消息，但从经济的角度来说还是合理的。不管怎样，下面我们就来介绍这个复杂的模型。</p>
<p>在模型3中，你会关闭和重启服务，这会导致数据的丢失。任何后续加入的客户端只能得到重启之后的那些数据，而非所有的。下面就让我们想办法让克隆模式能够承担服务器重启的故障。</p>
<p>以下列举我们需要处理的问题：</p>
<ul>
<li><p>克隆服务器进程崩溃并自动或手工重启。进程丢失了所有数据，所以必须从别处进行恢复。</p>
</li>
<li><p>克隆服务器硬件故障，长时间不能恢复。客户端需要切换至另一个可用的服务端。</p>
</li>
<li><p>克隆服务器从网络上断开，如交换机发生故障等。它会在某个时点重连，但期间的数据就需要替代的服务器负责处理。</p>
</li>
</ul>
<p>第一步我们需要增加一个服务器。我们可以使用第四章中提到的双子星模式，它是一个反应堆，而我们的程序经过整理后也是一个反应堆，因此可以互相协作。</p>
<p>我们需要保证更新事件在主服务器崩溃时仍能保留，最简单的机制就是同时发送给两台服务器。</p>
<p>备机就可以当做一台客户端来运行，像其他客户端一样从主机获取更新事件。同时它又能从客户端获取更新事件——虽然不应该以此更新数据，但可以先暂存起来。</p>
<p>所以，相较于模型5，模型6中引入了以下特性：</p>
<ul>
<li><p>客户端发送更新事件改用PUB-SUB套接字，而非PUSH-PULL。原因是PUSH套接字会在没有接收方时阻塞，且会进行负载均衡——我们需要两台服务器都接收到消息。我们会在服务器端绑定SUB套接字，在客户端连接PUB套接字。</p>
</li>
<li><p>我们在服务器发送给客户端的更新事件中加入心跳，这样客户端可以知道主机是否已死，然后切换至备机。</p>
</li>
<li><p>我们使用双子星模式的bstar反应堆类来创建主机和备机。双子星模式中需要有一个“投票”套接字，来协助判定对方节点是否已死。这里我们使用快照请求来作为“投票”。</p>
</li>
<li><p>我们将为所有的更新事件添加UUID属性，它由客户端生成，服务端会将其发布给所有客户端。</p>
</li>
<li><p>备机将维护一个“待处理列表”，保存来自客户端、尚未由服务端发布的更新事件；或者反过来，来自服务端、尚未从客户端收到的更新事件。这个列表从旧到新排列，这样就能方便地从顶部删除消息。</p>
</li>
</ul>
<p>我们可以为客户端设计一个有限状态机，它有三种状态：</p>
<ul>
<li><p>客户端打开并连接了套接字，然后向服务端发送快照请求。为了避免消息风暴，它只会请求两次。</p>
</li>
<li><p>客户端等待快照应答，如果获得了则保存它；如果没有获得，则向第二个服务器发送请求。</p>
</li>
<li><p>客户端收到快照，便开始等待更新事件。如果在一定时间内没有收到服务端响应，则会连接第二个服务端。</p>
</li>
</ul>
<p>客户端会一直循环下去，可能在程序刚启动时，部分客户端会试图连接主机，部分连接备机，相信双子星模式会很好地处理这一情况的。</p>
<p>我们可以将客户端状态图绘制出来：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_6.png" alt="6"></p>
<p>故障恢复的步骤如下：</p>
<ul>
<li>客户端检测到主机不再发送心跳，因此转而连接备机，并请求一份新的快照；</li>
<li>备机开始接收快照请求，并检测到主机死亡，于是开始作为主机运行；</li>
<li>备机将待处理列表中的更新事件写入自身状态中，然后开始处理快照请求。</li>
</ul>
<p>当主机恢复连接时：</p>
<ul>
<li>启动为slave状态，并作为克隆模式客户端连接备机；</li>
<li>同时，使用SUB套接字从客户端接收更新事件。</li>
</ul>
<p>我们做两点假设：</p>
<ul>
<li>至少有一台主机会继续运行。如果两台主机都崩溃了，那我们将丢失所有的服务端数据，无法恢复。</li>
<li>不同的客户端不会同时更新同一个键值对。客户端的更新事件会先后到达两个服务器，因此更新的顺序可能会不一致。单个客户端的更新事件到达两台服务器的顺序是相同的，所以不用担心。</li>
</ul>
<p>下面是整体架构图：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter5_7.png" alt="7"></p>
<p>开始编程之前，我们需要将客户端重构成一个可复用的类。在ZMQ中写异步类有时是为了练习如何写出优雅的代码，但这里我们确实是希望克隆模式可以成为一种易于使用的程序。上述架构的伸缩性来源于客户端的正确行为，因此有必要将其封装成一份API。要在客户端中进行故障恢复还是比较复杂的，试想一下自由者模式和克隆模式结合起来会是什么样的吧。</p>
<p>按照我的习惯，我会先写出一份API的列表，然后加以实现。让我们假想一个名为clone的API，在其基础之上编写克隆模式客户端API。将代码封装为API显然会提升代码的稳定性，就以模型5为例，客户端需要打开三个套接字，端点名称直接写在了代码里。我们可以创建这样一组API：</p>
<pre><code class="c">    //  为每个套接字指定端点
    clone_subscribe (clone, &quot;tcp://localhost:5556&quot;);
    clone_snapshot  (clone, &quot;tcp://localhost:5557&quot;);
    clone_updates   (clone, &quot;tcp://localhost:5558&quot;);

    //  由于有两个服务端，因此再执行一次
    clone_subscribe (clone, &quot;tcp://localhost:5566&quot;);
    clone_snapshot  (clone, &quot;tcp://localhost:5567&quot;);
    clone_updates   (clone, &quot;tcp://localhost:5568&quot;);
</code></pre>
<p>但这种写法还是比较啰嗦的，因为没有必要将API内部的一些设计暴露给编程人员。现在我们会使用三个套接字，而将来可能就会使用两个，或者四个。我们不可能让所有的应用程序都相应地修改吧？让我们把这些信息包装到API中：</p>
<pre><code class="c">    //  指定主备服务器端点
    clone_connect (clone, &quot;tcp://localhost:5551&quot;);
    clone_connect (clone, &quot;tcp://localhost:5561&quot;);
</code></pre>
<p>这样一来代码就变得非常简洁，不过也会对现有代码的内部就够造成影响。我们需要从一个端点中推算出三个端点。一种方法是假设客户端和服务端使用三个连续的端点通信，并将这个规则写入协议；另一个方法是向服务器索取缺少的端点信息。我们使用第一种较为简单的方法：</p>
<ul>
<li>服务器状态ROUTER在端点P；</li>
<li>服务器更新事件PUB在端点P + 1；</li>
<li>服务器更新事件SUB在端点P + 2。</li>
</ul>
<p>clone类和第四章的flcliapi类很类似，由两部分组成：</p>
<ul>
<li>一个在后台运行的异步克隆模式代理。该代理处理所有的I/O操作，实时地和服务器进行通信；</li>
<li>一个在前台应用程序中同步运行的clone类。当你创建了一个clone对象后，它会自动创建后台的clone线程；当你销毁clone对象，该后台线程也会被销毁。</li>
</ul>
<p>前台的clone类会使用inproc管道和后台的代理进行通信。C语言中，czmq线程会自动为我们创建这个管道。这也是ZMQ多线程编程的常规方式。</p>
<p>如果没有ZMQ，这种异步的设计将很难处理高压工作，而ZMQ会让其变得简单。编写出来额代码会相对比较复杂。我们可以用反应堆的模式来编写，但这会进一步增加复杂度，且影响应用程序的使用。因此，我们的设计的API将更像是一个能够和服务器进行通信的键值表：</p>
<pre><code class="c">clone_t *clone_new (void);
void clone_destroy (clone_t **self_p);
void clone_connect (clone_t *self, char *address, char *service);
void clone_set (clone_t *self, char *key, char *value);
char *clone_get (clone_t *self, char *key);
</code></pre>
<p>下面就是克隆模式客户端模型6的代码，因为调用了API，所以非常简短：<br><strong>clonecli6: Clone client, Model Six in C</strong></p>
<pre><code>//
//  克隆模式 - 客户端 - 模型6
//

//  直接编译，不建类库
#include &quot;clone.c&quot;

#define SUBTREE &quot;/client/&quot;

int main (void)
{
    //  创建分布式哈希表
    clone_t *clone = clone_new ();

    //  配置
    clone_subtree (clone, SUBTREE);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5556&quot;);
    clone_connect (clone, &quot;tcp://localhost&quot;, &quot;5566&quot;);

    //  插入随机键值
    while (!zctx_interrupted) {
        //  生成随机值
        char key [255];
        char value [10];
        sprintf (key, &quot;%s%d&quot;, SUBTREE, randof (10000));
        sprintf (value, &quot;%d&quot;, randof (1000000));
        clone_set (clone, key, value, randof (30));
        sleep (1);
    }
    clone_destroy (&amp;clone);
    return 0;
}
</code></pre><p>以下是clone类的实现：<br><strong>clone: Clone class in C</strong></p>
<pre><code class="c">/*  =====================================================================
    clone - client-side Clone Pattern class

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;clone.h&quot;

//  请求超时时间
#define GLOBAL_TIMEOUT  4000    //  msecs
//  判定服务器死亡的时间
#define SERVER_TTL      5000    //  msecs
//  服务器数量
#define SERVER_MAX      2


//  =====================================================================
//  同步部分，在应用程序线程中工作

//  ---------------------------------------------------------------------
//  类结构

struct _clone_t {
    zctx_t *ctx;                //  上下文
    void *pipe;                 //  和后台代理间的通信套接字
};

//  该线程用于处理真正的clone类
static void clone_agent (void *args, zctx_t *ctx, void *pipe);


//  ---------------------------------------------------------------------
//  构造函数

clone_t *
clone_new (void)
{
    clone_t
        *self;

    self = (clone_t *) zmalloc (sizeof (clone_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, clone_agent, NULL);
    return self;
}

//  ---------------------------------------------------------------------
//  析构函数

void
clone_destroy (clone_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        clone_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  在链接之前指定快照和更新事件的子树
//  发送给后台代理的消息内容为[SUBTREE][subtree]

void clone_subtree (clone_t *self, char *subtree)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;SUBTREE&quot;);
    zmsg_addstr (msg, subtree);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  连接至新的服务器端点
//  消息内容：[CONNECT][endpoint][service]

void
clone_connect (clone_t *self, char *address, char *service)
{
    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;CONNECT&quot;);
    zmsg_addstr (msg, address);
    zmsg_addstr (msg, service);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  设置新值
//  消息内容：[SET][key][value][ttl]

void
clone_set (clone_t *self, char *key, char *value, int ttl)
{
    char ttlstr [10];
    sprintf (ttlstr, &quot;%d&quot;, ttl);

    assert (self);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;SET&quot;);
    zmsg_addstr (msg, key);
    zmsg_addstr (msg, value);
    zmsg_addstr (msg, ttlstr);
    zmsg_send (&amp;msg, self-&gt;pipe);
}

//  ---------------------------------------------------------------------
//  取值
//  消息内容：[GET][key]
//  如果没有clone可用，会返回NULL

char *
clone_get (clone_t *self, char *key)
{
    assert (self);
    assert (key);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;GET&quot;);
    zmsg_addstr (msg, key);
    zmsg_send (&amp;msg, self-&gt;pipe);

    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    if (reply) {
        char *value = zmsg_popstr (reply);
        zmsg_destroy (&amp;reply);
        return value;
    }
    return NULL;
}


//  =====================================================================
//  异步部分，在后台运行

//  ---------------------------------------------------------------------
//  单个服务端信息

typedef struct {
    char *address;              //  服务端地址
    int port;                   //  端口
    void *snapshot;             //  快照套接字
    void *subscriber;           //  接收更新事件的套接字
    uint64_t expiry;            //  服务器过期时间
    uint requests;              //  收到的快照请求数
} server_t;

static server_t *
server_new (zctx_t *ctx, char *address, int port, char *subtree)
{
    server_t *self = (server_t *) zmalloc (sizeof (server_t));

    zclock_log (&quot;I: adding server %s:%d...&quot;, address, port);
    self-&gt;address = strdup (address);
    self-&gt;port = port;

    self-&gt;snapshot = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (self-&gt;snapshot, &quot;%s:%d&quot;, address, port);
    self-&gt;subscriber = zsocket_new (ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, &quot;%s:%d&quot;, address, port + 1);
    zsockopt_set_subscribe (self-&gt;subscriber, subtree);
    return self;
}

static void
server_destroy (server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;address);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  后台代理类

//  状态
#define STATE_INITIAL       0   //  连接之前
#define STATE_SYNCING       1   //  正在同步
#define STATE_ACTIVE        2   //  正在更新

typedef struct {
    zctx_t *ctx;                //  上下文
    void *pipe;                 //  与主线程通信的套接字
    zhash_t *kvmap;             //  键值表
    char *subtree;              //  子树
    server_t *server [SERVER_MAX];
    uint nbr_servers;           //  范围：0 - SERVER_MAX
    uint state;                 //  当前状态
    uint cur_server;            //  当前master，0/1
    int64_t sequence;           //  键值对编号
    void *publisher;            //  发布更新事件的套接字
} agent_t;

static agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;kvmap = zhash_new ();
    self-&gt;subtree = strdup (&quot;&quot;);
    self-&gt;state = STATE_INITIAL;
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    return self;
}

static void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        int server_nbr;
        for (server_nbr = 0; server_nbr &lt; self-&gt;nbr_servers; server_nbr++)
            server_destroy (&amp;self-&gt;server [server_nbr]);
        zhash_destroy (&amp;self-&gt;kvmap);
        free (self-&gt;subtree);
        free (self);
        *self_p = NULL;
    }
}

//  若线程被中断则返回-1
static int
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    char *command = zmsg_popstr (msg);
    if (command == NULL)
        return -1;

    if (streq (command, &quot;SUBTREE&quot;)) {
        free (self-&gt;subtree);
        self-&gt;subtree = zmsg_popstr (msg);
    }
    else
    if (streq (command, &quot;CONNECT&quot;)) {
        char *address = zmsg_popstr (msg);
        char *service = zmsg_popstr (msg);
        if (self-&gt;nbr_servers &lt; SERVER_MAX) {
            self-&gt;server [self-&gt;nbr_servers++] = server_new (
                self-&gt;ctx, address, atoi (service), self-&gt;subtree);
            //  广播更新事件
            zsocket_connect (self-&gt;publisher, &quot;%s:%d&quot;,
                address, atoi (service) + 2);
        }
        else
            zclock_log (&quot;E: too many servers (max. %d)&quot;, SERVER_MAX);
        free (address);
        free (service);
    }
    else
    if (streq (command, &quot;SET&quot;)) {
        char *key = zmsg_popstr (msg);
        char *value = zmsg_popstr (msg);
        char *ttl = zmsg_popstr (msg);
        zhash_update (self-&gt;kvmap, key, (byte *) value);
        zhash_freefn (self-&gt;kvmap, key, free);

        //  向服务端发送键值对
        kvmsg_t *kvmsg = kvmsg_new (0);
        kvmsg_set_key  (kvmsg, key);
        kvmsg_set_uuid (kvmsg);
        kvmsg_fmt_body (kvmsg, &quot;%s&quot;, value);
        kvmsg_set_prop (kvmsg, &quot;ttl&quot;, ttl);
        kvmsg_send     (kvmsg, self-&gt;publisher);
        kvmsg_destroy (&amp;kvmsg);
puts (key);
        free (ttl);
        free (key);             //  键值对实际由哈希表对象控制
    }
    else
    if (streq (command, &quot;GET&quot;)) {
        char *key = zmsg_popstr (msg);
        char *value = zhash_lookup (self-&gt;kvmap, key);
        if (value)
            zstr_send (self-&gt;pipe, value);
        else
            zstr_send (self-&gt;pipe, &quot;&quot;);
        free (key);
        free (value);
    }
    free (command);
    zmsg_destroy (&amp;msg);
    return 0;
}


//  ---------------------------------------------------------------------
//  异步的后台代理会维护一个服务端池，并处理来自应用程序的请求或应答。

static void
clone_agent (void *args, zctx_t *ctx, void *pipe)
{
    agent_t *self = agent_new (ctx, pipe);

    while (TRUE) {
        zmq_pollitem_t poll_set [] = {
            { pipe, 0, ZMQ_POLLIN, 0 },
            { 0,    0, ZMQ_POLLIN, 0 }
        };
        int poll_timer = -1;
        int poll_size = 2;
        server_t *server = self-&gt;server [self-&gt;cur_server];
        switch (self-&gt;state) {
            case STATE_INITIAL:
                //  该状态下，如果有可用服务，会发送快照请求
                if (self-&gt;nbr_servers &gt; 0) {
                    zclock_log (&quot;I: 正在等待服务器 %s:%d...&quot;,
                        server-&gt;address, server-&gt;port);
                    if (server-&gt;requests &lt; 2) {
                        zstr_sendm (server-&gt;snapshot, &quot;ICANHAZ?&quot;);
                        zstr_send  (server-&gt;snapshot, self-&gt;subtree);
                        server-&gt;requests++;
                    }
                    server-&gt;expiry = zclock_time () + SERVER_TTL;
                    self-&gt;state = STATE_SYNCING;
                    poll_set [1].socket = server-&gt;snapshot;
                }
                else
                    poll_size = 1;
                break;
            case STATE_SYNCING:
                //  该状态下我们从服务器端接收快照内容，若失败则尝试其他服务器
                poll_set [1].socket = server-&gt;snapshot;
                break;
            case STATE_ACTIVE:
                //  该状态下我们从服务器获取更新事件，失败则尝试其他服务器
                poll_set [1].socket = server-&gt;subscriber;
                break;
        }
        if (server) {
            poll_timer = (server-&gt;expiry - zclock_time ())
                       * ZMQ_POLL_MSEC;
            if (poll_timer &lt; 0)
                poll_timer = 0;
        }
        //  ------------------------------------------------------------
        //  poll循环
        int rc = zmq_poll (poll_set, poll_size, poll_timer);
        if (rc == -1)
            break;              //  上下文已被关闭

        if (poll_set [0].revents &amp; ZMQ_POLLIN) {
            if (agent_control_message (self))
                break;          //  中断
        }
        else
        if (poll_set [1].revents &amp; ZMQ_POLLIN) {
            kvmsg_t *kvmsg = kvmsg_recv (poll_set [1].socket);
            if (!kvmsg)
                break;          //  中断

            //  任何服务端的消息将重置它的过期时间
            server-&gt;expiry = zclock_time () + SERVER_TTL;
            if (self-&gt;state == STATE_SYNCING) {
                //  保存快照内容
                server-&gt;requests = 0;
                if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    self-&gt;state = STATE_ACTIVE;
                    zclock_log (&quot;I: received from %s:%d snapshot=%d&quot;,
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                    kvmsg_destroy (&amp;kvmsg);
                }
                else
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            }
            else
            if (self-&gt;state == STATE_ACTIVE) {
                //  丢弃过期的更新事件
                if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
                    self-&gt;sequence = kvmsg_sequence (kvmsg);
                    kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
                    zclock_log (&quot;I: received from %s:%d update=%d&quot;,
                        server-&gt;address, server-&gt;port,
                        (int) self-&gt;sequence);
                }
                else
                    kvmsg_destroy (&amp;kvmsg);
            }
        }
        else {
            //  服务端已死，尝试其他服务器
            zclock_log (&quot;I: 服务器 %s:%d 无响应&quot;,
                    server-&gt;address, server-&gt;port);
            self-&gt;cur_server = (self-&gt;cur_server + 1) % self-&gt;nbr_servers;
            self-&gt;state = STATE_INITIAL;
        }
    }
    agent_destroy (&amp;self);
}
</code></pre>
<p>最后是克隆服务器的模型6代码：</p>
<p><strong>clonesrv6: Clone server, Model Six in C</strong></p>
<pre><code class="c">//
// 克隆模式 - 服务端 - 模型6
//

//  直接编译，不建类库
#include &quot;bstar.c&quot;
#include &quot;kvmsg.c&quot;

//  bstar反应堆API
static int s_snapshots  (zloop_t *loop, void *socket, void *args);
static int s_collector  (zloop_t *loop, void *socket, void *args);
static int s_flush_ttl  (zloop_t *loop, void *socket, void *args);
static int s_send_hugz  (zloop_t *loop, void *socket, void *args);
static int s_new_master (zloop_t *loop, void *unused, void *args);
static int s_new_slave  (zloop_t *loop, void *unused, void *args);
static int s_subscriber (zloop_t *loop, void *socket, void *args);

//  服务端属性
typedef struct {
    zctx_t *ctx;                //  上下文
    zhash_t *kvmap;             //  存放键值对
    bstar_t *bstar;             //  bstar反应堆核心
    int64_t sequence;           //  更新事件编号
    int port;                   //  主端口
    int peer;                   //  同伴端口
    void *publisher;            //  发布更新事件的端口
    void *collector;            //  接收客户端更新事件的端口
    void *subscriber;           //  接受同伴更新事件的端口
    zlist_t *pending;           //  延迟的更新事件
    Bool primary;               //  是否为主机
    Bool master;                //  是否为master
    Bool slave;                 //  是否为slave
} clonesrv_t;


int main (int argc, char *argv [])
{
    clonesrv_t *self = (clonesrv_t *) zmalloc (sizeof (clonesrv_t));
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) {
        zclock_log (&quot;I: 作为主机master运行，正在等待备机slave连接。&quot;);
        self-&gt;bstar = bstar_new (BSTAR_PRIMARY, &quot;tcp://*:5003&quot;,
                                 &quot;tcp://localhost:5004&quot;);
        bstar_voter (self-&gt;bstar, &quot;tcp://*:5556&quot;, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = 5556;
        self-&gt;peer = 5566;
        self-&gt;primary = TRUE;
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) {
        zclock_log (&quot;I: 作为备机slave运行，正在等待主机master连接。&quot;);
        self-&gt;bstar = bstar_new (BSTAR_BACKUP, &quot;tcp://*:5004&quot;,
                                 &quot;tcp://localhost:5003&quot;);
        bstar_voter (self-&gt;bstar, &quot;tcp://*:5566&quot;, ZMQ_ROUTER,
                     s_snapshots, self);
        self-&gt;port = 5566;
        self-&gt;peer = 5556;
        self-&gt;primary = FALSE;
    }
    else {
        printf (&quot;Usage: clonesrv4 { -p | -b }\n&quot;);
        free (self);
        exit (0);
    }
    //  主机将成为master
    if (self-&gt;primary)
        self-&gt;kvmap = zhash_new ();

    self-&gt;ctx = zctx_new ();
    self-&gt;pending = zlist_new ();
    bstar_set_verbose (self-&gt;bstar, TRUE);

    //  设置克隆服务端套接字
    self-&gt;publisher = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    self-&gt;collector = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_bind (self-&gt;publisher, &quot;tcp://*:%d&quot;, self-&gt;port + 1);
    zsocket_bind (self-&gt;collector, &quot;tcp://*:%d&quot;, self-&gt;port + 2);

    //  作为克隆客户端连接同伴
    self-&gt;subscriber = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;subscriber, &quot;tcp://localhost:%d&quot;, self-&gt;peer + 1);

    //  注册状态事件处理器
    bstar_new_master (self-&gt;bstar, s_new_master, self);
    bstar_new_slave (self-&gt;bstar, s_new_slave, self);

    //  注册bstar反应堆其他事件处理器
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;collector, s_collector, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_flush_ttl, self);
    zloop_timer  (bstar_zloop (self-&gt;bstar), 1000, 0, s_send_hugz, self);

    //  开启bstar反应堆
    bstar_start (self-&gt;bstar);

    //  中断，终止。
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_destroy (&amp;kvmsg);
    }
    zlist_destroy (&amp;self-&gt;pending);
    bstar_destroy (&amp;self-&gt;bstar);
    zhash_destroy (&amp;self-&gt;kvmap);
    zctx_destroy (&amp;self-&gt;ctx);
    free (self);

    return 0;
}


//  ---------------------------------------------------------------------
//  发送快照内容

static int s_send_single (char *key, void *data, void *args);

//  请求方信息
typedef struct {
    void *socket;           //  ROUTER套接字
    zframe_t *identity;     //  请求放标识
    char *subtree;          //  子树
} kvroute_t;

static int
s_snapshots (zloop_t *loop, void *snapshot, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zframe_t *identity = zframe_recv (snapshot);
    if (identity) {
        //  请求在消息的第二帧中
        char *request = zstr_recv (snapshot);
        char *subtree = NULL;
        if (streq (request, &quot;ICANHAZ?&quot;)) {
            free (request);
            subtree = zstr_recv (snapshot);
        }
        else
            printf (&quot;E: 错误的请求，正在退出……\n&quot;);

        if (subtree) {
            //  发送状态快照
            kvroute_t routing = { snapshot, identity, subtree };
            zhash_foreach (self-&gt;kvmap, s_send_single, &amp;routing);

            //  发送终止消息，以及消息编号
            zclock_log (&quot;I: 正在发送快照，版本号：%d&quot;, (int) self-&gt;sequence);
            zframe_send (&amp;identity, snapshot, ZFRAME_MORE);
            kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
            kvmsg_set_key  (kvmsg, &quot;KTHXBAI&quot;);
            kvmsg_set_body (kvmsg, (byte *) subtree, 0);
            kvmsg_send     (kvmsg, snapshot);
            kvmsg_destroy (&amp;kvmsg);
            free (subtree);
        }
    }
    return 0;
}


//  每次发送一个快照键值对
static int
s_send_single (char *key, void *data, void *args)
{
    kvroute_t *kvroute = (kvroute_t *) args;
    kvmsg_t *kvmsg = (kvmsg_t *) data;
    if (strlen (kvroute-&gt;subtree) &lt;= strlen (kvmsg_key (kvmsg))
    &amp;&amp;  memcmp (kvroute-&gt;subtree,
                kvmsg_key (kvmsg), strlen (kvroute-&gt;subtree)) == 0) {
        //  先发送接收方的地址
        zframe_send (&amp;kvroute-&gt;identity,
            kvroute-&gt;socket, ZFRAME_MORE + ZFRAME_REUSE);
        kvmsg_send (kvmsg, kvroute-&gt;socket);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  从客户端收集更新事件
//  如果我们是master，则将该事件写入kvmap对象；
//  如果我们是slave，则将其写入延迟队列

static int s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg);

static int
s_collector (zloop_t *loop, void *collector, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_recv (collector);
    kvmsg_dump (kvmsg);
    if (kvmsg) {
        if (self-&gt;master) {
            kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
            kvmsg_send (kvmsg, self-&gt;publisher);
            int ttl = atoi (kvmsg_get_prop (kvmsg, &quot;ttl&quot;));
            if (ttl)
                kvmsg_set_prop (kvmsg, &quot;ttl&quot;,
                    &quot;%&quot; PRId64, zclock_time () + ttl * 1000);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (&quot;I: 正在发布更新事件：%d&quot;, (int) self-&gt;sequence);
        }
        else {
            //  如果我们已经从master中获得了该事件，则丢弃该消息
            if (s_was_pending (self, kvmsg))
                kvmsg_destroy (&amp;kvmsg);
            else
                zlist_append (self-&gt;pending, kvmsg);
        }
    }
    return 0;
}

//  如果消息已在延迟队列中，则删除它并返回TRUE

static int
s_was_pending (clonesrv_t *self, kvmsg_t *kvmsg)
{
    kvmsg_t *held = (kvmsg_t *) zlist_first (self-&gt;pending);
    while (held) {
        if (memcmp (kvmsg_uuid (kvmsg),
                    kvmsg_uuid (held), sizeof (uuid_t)) == 0) {
            zlist_remove (self-&gt;pending, held);
            return TRUE;
        }
        held = (kvmsg_t *) zlist_next (self-&gt;pending);
    }
    return FALSE;
}


//  ---------------------------------------------------------------------
//  删除带有过期时间的瞬间值

static int s_flush_single (char *key, void *data, void *args);

static int
s_flush_ttl (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    zhash_foreach (self-&gt;kvmap, s_flush_single, args);
    return 0;
}

//  如果键值对过期，则进行删除操作，并广播该事件
static int
s_flush_single (char *key, void *data, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = (kvmsg_t *) data;
    int64_t ttl;
    sscanf (kvmsg_get_prop (kvmsg, &quot;ttl&quot;), &quot;%&quot; PRId64, &amp;ttl);
    if (ttl &amp;&amp; zclock_time () &gt;= ttl) {
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布删除事件：%d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  发送心跳

static int
s_send_hugz (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    kvmsg_t *kvmsg = kvmsg_new (self-&gt;sequence);
    kvmsg_set_key  (kvmsg, &quot;HUGZ&quot;);
    kvmsg_set_body (kvmsg, (byte *) &quot;&quot;, 0);
    kvmsg_send     (kvmsg, self-&gt;publisher);
    kvmsg_destroy (&amp;kvmsg);

    return 0;
}


//  ---------------------------------------------------------------------
//  状态改变事件处理函数
//  我们将转变为master
//
//  备机先将延迟列表中的事件更新到自己的快照中，
//  并开始接收客户端发来的快照请求。

static int
s_new_master (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    self-&gt;master = TRUE;
    self-&gt;slave = FALSE;
    zloop_cancel (bstar_zloop (self-&gt;bstar), self-&gt;subscriber);

    //  应用延迟列表中的事件
    while (zlist_size (self-&gt;pending)) {
        kvmsg_t *kvmsg = (kvmsg_t *) zlist_pop (self-&gt;pending);
        kvmsg_set_sequence (kvmsg, ++self-&gt;sequence);
        kvmsg_send (kvmsg, self-&gt;publisher);
        kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        zclock_log (&quot;I: 正在发布延迟列表中的更新事件：%d&quot;, (int) self-&gt;sequence);
    }
    return 0;
}

//  ---------------------------------------------------------------------
//  正在切换为slave

static int
s_new_slave (zloop_t *loop, void *unused, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;

    zhash_destroy (&amp;self-&gt;kvmap);
    self-&gt;master = FALSE;
    self-&gt;slave = TRUE;
    zloop_reader (bstar_zloop (self-&gt;bstar), self-&gt;subscriber,
                  s_subscriber, self);

    return 0;
}

//  ---------------------------------------------------------------------
//  从同伴主机（master）接收更新事件；
//  接收该类更新事件时，我们一定是slave。

static int
s_subscriber (zloop_t *loop, void *subscriber, void *args)
{
    clonesrv_t *self = (clonesrv_t *) args;
    //  获取快照，如果需要的话。
    if (self-&gt;kvmap == NULL) {
        self-&gt;kvmap = zhash_new ();
        void *snapshot = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
        zsocket_connect (snapshot, &quot;tcp://localhost:%d&quot;, self-&gt;peer);
        zclock_log (&quot;I: 正在请求快照：tcp://localhost:%d&quot;,
                    self-&gt;peer);
        zstr_send (snapshot, &quot;ICANHAZ?&quot;);
        while (TRUE) {
            kvmsg_t *kvmsg = kvmsg_recv (snapshot);
            if (!kvmsg)
                break;          //  中断
            if (streq (kvmsg_key (kvmsg), &quot;KTHXBAI&quot;)) {
                self-&gt;sequence = kvmsg_sequence (kvmsg);
                kvmsg_destroy (&amp;kvmsg);
                break;          //  完成
            }
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
        }
        zclock_log (&quot;I: 收到快照，版本号：%d&quot;, (int) self-&gt;sequence);
        zsocket_destroy (self-&gt;ctx, snapshot);
    }
    //  查找并删除
    kvmsg_t *kvmsg = kvmsg_recv (subscriber);
    if (!kvmsg)
        return 0;

    if (strneq (kvmsg_key (kvmsg), &quot;HUGZ&quot;)) {
        if (!s_was_pending (self, kvmsg)) {
            //  如果master的更新事件比客户端的事件早到，则将master的事件存入延迟列表，
            //  当收到客户端更新事件时会将其从列表中清除。
            zlist_append (self-&gt;pending, kvmsg_dup (kvmsg));
        }
        //  如果更新事件比kvmap版本高，则应用它
        if (kvmsg_sequence (kvmsg) &gt; self-&gt;sequence) {
            self-&gt;sequence = kvmsg_sequence (kvmsg);
            kvmsg_store (&amp;kvmsg, self-&gt;kvmap);
            zclock_log (&quot;I: 收到更新事件：%d&quot;, (int) self-&gt;sequence);
        }
        else
            kvmsg_destroy (&amp;kvmsg);
    }
    else
        kvmsg_destroy (&amp;kvmsg);

    return 0;
}
</code></pre>
<p>这段程序只有几百行，但还是花了一些时间来进行调通的。这个模型中包含了故障恢复，瞬间值，子树等等。虽然我们前期设计得很完备，但要在多个套接字之间进行调试还是很困难的。以下是我的工作方式：</p>
<ul>
<li><p>由于使用了反应堆（bstar，建立在zloop之上），我们节省了大量的代码，让程序变得简洁明了。整个服务以一个线程运行，因此不会出现跨线程的问题。只需将结构指针（self）传递给所有的处理器即可。此外，使用发应堆后可以让代码更为模块化，易于重用。</p>
</li>
<li><p>我们逐个模块进行调试，只有某个模块能够正常运行时才会进入下一步。由于使用了四五个套接字，因此调试的工作量是很大的。我直接将调试信息输出到了屏幕上，因为实在没有必要专门开一个调试器来工作。</p>
</li>
<li><p>因为一直在使用valgrind工具进行测试，因此我能确定程序没有内存泄漏的问题。在C语言中，内存泄漏是我们非常关心的问题，因为没有什么垃圾回收机制可以帮你完成。正确地使用像kvmsg、czmq之类的抽象层可以很好地避免内存泄漏。</p>
</li>
</ul>
<p>这段程序肯定还会存在一些BUG，部分读者可能会帮助我调试和修复，我在此表示感谢。</p>
<p>测试模型6时，先开启主机和备机，再打开一组客户端，顺序随意。随机地中止某个服务进程，如果程序设计得是正确的，那客户端获得的数据应该都是一致的。</p>
<h4 id="克隆模式协议"><a href="#克隆模式协议" class="headerlink" title="克隆模式协议"></a>克隆模式协议</h4><p>花费了那么多精力来开发一套可靠的发布-订阅模式机制，我们当然希望将来能够方便地在其基础之上进行扩展。较好的方法是将其编写为一个协议，这样就能让各种语言来实现它了。</p>
<p>我们将其称为“集群化哈希表协议”，这是一个能够跨集群地进行键值哈希表管理，提供了多客户端的通信机制；客户端可以只操作一个子树的数据，包括更新和定义瞬间值。</p>
<ul>
<li><a href="http://rfc.zeromq.org/spec:12" target="_blank" rel="external">http://rfc.zeromq.org/spec:12</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 网络编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zmq,网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zmq学习第四章]]></title>
      <url>/2017/12/24/zmq_chapter4/</url>
      <content type="html"><![CDATA[<h2 id="可靠的请求-应答模式"><a href="#可靠的请求-应答模式" class="headerlink" title="可靠的请求-应答模式"></a>可靠的请求-应答模式</h2><p>第三章中我们使用实例介绍了高级请求-应答模式，本章我们会讲述请求-应答模式的可靠性问题，并使用ZMQ提供的套接字类型组建起可靠的请求-应答消息系统。</p>
<p>本章将介绍的内容有：</p>
<ul>
<li>客户端请求-应答</li>
<li>最近最少使用队列</li>
<li>心跳机制</li>
<li>面向服务的队列</li>
<li>基于磁盘（脱机）队列</li>
<li>主从备份服务</li>
<li>无中间件的请求-应答</li>
</ul>
<a id="more"></a>
<h3 id="什么是可靠性？"><a href="#什么是可靠性？" class="headerlink" title="什么是可靠性？"></a>什么是可靠性？</h3><p>要给可靠性下定义，我们可以先界定它的相反面——故障。如果我们可以处理某些类型的故障，那么我们的模型对于这些故障就是可靠的。下面我们就来列举分布式ZMQ应用程序中可能发生的问题，从可能性高的故障开始：</p>
<ul>
<li>应用程序代码是最大的故障来源。程序会崩溃或中止，停止对数据来源的响应，或是响应得太慢，耗尽内存等。</li>
<li>系统代码，如使用ZMQ编写的中间件，也会意外中止。系统代码应该要比应用程序代码更为可靠，但毕竟也有可能崩溃。特别是当系统代码与速度过慢的客户端交互时，很容易耗尽内存。</li>
<li>消息队列溢出，典型的情况是系统代码中没有对蛮客户端做积极的处理，任由消息队列溢出。</li>
<li>网络临时中断，造成消息丢失。这类错误ZMQ应用程序是无法及时发现的，因为ZMQ会自动进行重连。</li>
<li>硬件系统崩溃，导致所有进程中止。</li>
<li>网络会出现特殊情形的中断，如交换机的某个端口发生故障，导致部分网络无法访问。</li>
<li>数据中心可能遭受雷击、地震、火灾、电压过载、冷却系统失效等。</li>
</ul>
<p>想要让软件系统规避上述所有的风险，需要大量的人力物力，故不在本指南的讨论范围之内。</p>
<p>由于前五个故障类型涵盖了99.9%的情形（这一数据源自我近期进行的一项研究），所以我们会深入探讨。如果你的公司大到足以考虑最后两种情形，那请及时联系我，因为我正愁没钱将我家后院的大坑建成游泳池。</p>
<h3 id="可靠性设计"><a href="#可靠性设计" class="headerlink" title="可靠性设计"></a>可靠性设计</h3><p>简单地来说，可靠性就是当程序发生故障时也能顺利地运行下去，这要比搭建一个消息系统来得困难得多。我们会根据ZMQ提供的每一种核心消息模式，来看看如何保障代码的持续运行。</p>
<ul>
<li><p>请求-应答模式：当服务端在处理请求是中断，客户端能够得知这一信息，并停止接收消息，转而选择等待重试、请求另一服务端等操作。这里我们暂不讨论客户端发生问题的情形。</p>
</li>
<li><p>发布-订阅模式：如果客户端收到一些消息后意外中止，服务端是不知道这一情况的。发布-订阅模式中的订阅者不会返回任何消息给发布者。但是，订阅者可以通过其他方式联系服务端，如请求-应答模式，要求服务端重发消息。这里我们暂不讨论服务端发生问题的情形。此外，订阅者可以通过某些方式检查自身是否运行得过慢，并采取相应措施（向操作者发出警告、中止等）。</p>
</li>
<li><p>管道模式：如果worker意外终止，任务分发器将无从得知。管道模式和发布-订阅模式类似，只朝一个方向发送消息。但是，下游的结果收集器可以检测哪项任务没有完成，并告诉任务分发器重新分配该任务。如果任务分发器或结果收集器意外中止了，那客户端发出的请求只能另作处理。所以说，系统代码真的要减少出错的几率，因为这很难处理。</p>
</li>
</ul>
<p>本章主要讲解请求-应答模式中的可靠性设计，其他模式将在后续章节中讲解。</p>
<p>最基本的请求应答模式是REQ客户端发送一个同步的请求至REP服务端，这种模式的可靠性很低。如果服务端在处理请求时中止，那客户端会永远处于等待状态。</p>
<p>相比TCP协议，ZMQ提供了自动重连机制、消息分发的负载均衡等。但是，在真实环境中这也是不够的。唯一可以完全信任基本请求-应答模式的应用场景是同一进程的两个线程之间进行通信，没有网络问题或服务器失效的情况。</p>
<p>但是，只要稍加修饰，这种基本的请求-应答模式就能很好地在现实环境中工作了。我喜欢将其称为“海盗”模式。</p>
<p>粗略地讲，客户端连接服务端有三种方式，每种方式都需要不同的可靠性设计：</p>
<ul>
<li><p>多个客户端直接和单个服务端进行通信。使用场景：只有一个单点服务器，所有客户端都需要和它通信。需处理的故障：服务器崩溃和重启；网络连接中断。</p>
</li>
<li><p>多个客户端和单个队列装置通信，该装置将请求分发给多个服务端。使用场景：任务分发。需处理的故障：worker崩溃和重启，死循环，过载；队列装置崩溃和重启；网络中断。</p>
</li>
<li><p>多个客户端直接和多个服务端通信，无中间件。使用场景：类似域名解析的分布式服务。需处理的故障：服务端崩溃和重启，死循环，过载；网络连接中断。</p>
</li>
</ul>
<p>以上每种设计都必须有所取舍，很多时候会混合使用。下面我们详细说明。</p>
<h3 id="客户端的可靠性设计（懒惰海盗模式）"><a href="#客户端的可靠性设计（懒惰海盗模式）" class="headerlink" title="客户端的可靠性设计（懒惰海盗模式）"></a>客户端的可靠性设计（懒惰海盗模式）</h3><p>我们可以通过在客户端进行简单的设置，来实现可靠的请求-应答模式。我暂且称之为“懒惰的海盗”（Lazy Pirate）模式。</p>
<p>在接收应答时，我们不进行同步等待，而是做以下操作：</p>
<ul>
<li>对REQ套接字进行轮询，当消息抵达时才进行接收；</li>
<li>请求超时后重发消息，循环多次；</li>
<li>若仍无消息，则结束当前事务。</li>
</ul>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_1.png" alt="1"></p>
<p>使用REQ套接字时必须严格遵守发送-接收过程，因为它内部采用了一个有限状态机来限定状态，这一特性会让我们应用“海盗”模式时遇上一些麻烦。最简单的做法是将REQ套接字关闭重启，从而打破这一限定。</p>
<p><strong>lpclient: Lazy Pirate client in C</strong></p>
<pre><code class="c">//
//  Lazy Pirate client
//  使用zmq_poll轮询来实现安全的请求-应答
//  运行时可随机关闭或重启lpserver程序
//
#include &quot;czmq.h&quot;

#define REQUEST_TIMEOUT     2500    //  毫秒, (&gt; 1000!)
#define REQUEST_RETRIES     3       //  尝试次数
#define SERVER_ENDPOINT     &quot;tcp://localhost:5555&quot;

int main (void)
{
    zctx_t *ctx = zctx_new ();
    printf (&quot;I: 正在连接服务器...\n&quot;);
    void *client = zsocket_new (ctx, ZMQ_REQ);
    assert (client);
    zsocket_connect (client, SERVER_ENDPOINT);

    int sequence = 0;
    int retries_left = REQUEST_RETRIES;
    while (retries_left &amp;&amp; !zctx_interrupted) {
        //  发送一个请求，并开始接收消息
        char request [10];
        sprintf (request, &quot;%d&quot;, ++sequence);
        zstr_send (client, request);

        int expect_reply = 1;
        while (expect_reply) {
            //  对套接字进行轮询，并设置超时时间
            zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  中断

            //  如果接收到回复则进行处理
            if (items [0].revents &amp; ZMQ_POLLIN) {
                //  收到服务器应答，必须和请求时的序号一致
                char *reply = zstr_recv (client);
                if (!reply)
                    break;      //  Interrupted
                if (atoi (reply) == sequence) {
                    printf (&quot;I: 服务器返回正常 (%s)\n&quot;, reply);
                    retries_left = REQUEST_RETRIES;
                    expect_reply = 0;
                }
                else
                    printf (&quot;E: 服务器返回异常: %s\n&quot;,
                        reply);

                free (reply);
            }
            else
            if (--retries_left == 0) {
                printf (&quot;E: 服务器不可用，取消操作\n&quot;);
                break;
            }
            else {
                printf (&quot;W: 服务器没有响应，正在重试...\n&quot;);
                //  关闭旧套接字，并建立新套接字
                zsocket_destroy (ctx, client);
                printf (&quot;I: 服务器重连中...\n&quot;);
                client = zsocket_new (ctx, ZMQ_REQ);
                zsocket_connect (client, SERVER_ENDPOINT);
                //  使用新套接字再次发送请求
                zstr_send (client, request);
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p><strong>lpserver: Lazy Pirate server in C</strong></p>
<pre><code class="c">//
//  Lazy Pirate server
//  将REQ套接字连接至 tcp://*:5555
//  和hwserver程序类似，除了以下两点：
//   - 直接输出请求内容
//   - 随机地降慢运行速度，或中止程序，模拟崩溃
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    srandom ((unsigned) time (NULL));

    void *context = zmq_init (1);
    void *server = zmq_socket (context, ZMQ_REP);
    zmq_bind (server, &quot;tcp://*:5555&quot;);

    int cycles = 0;
    while (1) {
        char *request = s_recv (server);
        cycles++;

        //  循环几次后开始模拟各种故障
        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) {
            printf (&quot;I: 模拟程序崩溃\n&quot;);
            break;
        }
        else
        if (cycles &gt; 3 &amp;&amp; randof (3) == 0) {
            printf (&quot;I: 模拟CPU过载\n&quot;);
            sleep (2);
        }
        printf (&quot;I: 正常请求 (%s)\n&quot;, request);
        sleep (1);              //  耗时的处理过程
        s_send (server, request);
        free (request);
    }
    zmq_close (server);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>运行这个测试用例时，可以打开两个控制台，服务端会随机发生故障，你可以看看客户端的反应。服务端的典型输出如下：</p>
<pre><code class="c">I: normal request (1)
I: normal request (2)
I: normal request (3)
I: simulating CPU overload
I: normal request (4)
I: simulating a crash
</code></pre>
<p>客户端的输出是：</p>
<pre><code>I: connecting to server...
I: server replied OK (1)
I: server replied OK (2)
I: server replied OK (3)
W: no response from server, retrying...
I: connecting to server...
W: no response from server, retrying...
I: connecting to server...
E: server seems to be offline, abandoning
</code></pre><p>客户端为每次请求都加上了序列号，并检查收到的应答是否和序列号一致，以保证没有请求或应答丢失，同一个应答收到多次或乱序。多运行几次实例，看看是否真的能够解决问题。现实环境中你不需要使用到序列号，那只是为了证明这一方式是可行的。</p>
<p>客户端使用REQ套接字进行请求，并在发生问题时打开一个新的套接字来，绕过REQ强制的发送/接收过程。可能你会想用DEALER套接字，但这并不是一个好主意。首先，DEALER并不会像REQ那样处理信封（如果你不知道信封是什么，那更不能用DEALER了）。其次，你可能会获得你并不想得到的结果。</p>
<p>这一方案的优劣是：</p>
<ul>
<li>优点：简单明了，容易实施；</li>
<li>优点：可以方便地应用到现有的客户端和服务端程序中；</li>
<li>优点：ZMQ有自动重连机制；</li>
<li>缺点：单点服务发生故障时不能定位到新的可用服务。</li>
</ul>
<h3 id="基本的可靠队列（简单海盗模式）"><a href="#基本的可靠队列（简单海盗模式）" class="headerlink" title="基本的可靠队列（简单海盗模式）"></a>基本的可靠队列（简单海盗模式）</h3><p>在第二种模式中，我们使用一个队列装置来扩展上述的“懒惰的海盗”模式，使客户端能够透明地和多个服务端通信。这里的服务端可以定义为worker。我们可以从最基础的模型开始，分阶段实施这个方案。</p>
<p>在所有的海盗模式中，worker是无状态的，或者说存在着一个我们所不知道的公共状态，如共享数据库。队列装置的存在意味着worker可以在client毫不知情的情况下随意进出。一个worker死亡后，会有另一个worker接替它的工作。这种拓扑结果非常简洁，但唯一的缺点是队列装置本身会难以维护，可能造成单点故障。</p>
<p>在第三章中，队列装置的基本算法是最近最少使用算法。那么，如果worker死亡或阻塞，我们需要做些什么？答案是很少很少。我们已经在client中加入了重试的机制，所以，使用基本的LRU队列就可以运作得很好了。这种做法也符合ZMQ的逻辑，所以我们可以通过在点对点交互中插入一个简单的队列装置来扩展它：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_2.png" alt="2"></p>
<p>我们可以直接使用“懒惰的海盗”模式中的client，以下是队列装置的代码：</p>
<p><strong>spqueue: Simple Pirate queue in C</strong></p>
<pre><code class="c">//
//  简单海盗队列
//  
//  这个装置和LRU队列完全一致，不存在任何可靠性机制，依靠client的重试来保证装置的运行
//
#include &quot;czmq.h&quot;

#define LRU_READY   &quot;\001&quot;      //  消息：worker准备就绪

int main (void)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);    //  client端点
    zsocket_bind (backend,  &quot;tcp://*:5556&quot;);    //  worker端点

    //  存放可用worker的队列
    zlist_t *workers = zlist_new ();

    while (1) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  当有可用的woker时，轮询前端端点
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);
        if (rc == -1)
            break;              //  中断

        //  处理后端端点的worker消息
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  使用worker的地址进行LRU排队
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  中断
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);

            //  如果消息不是READY，则转发给client
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  获取client请求，转发给第一个可用的worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (msg) {
                zmsg_wrap (msg, (zframe_t *) zlist_pop (workers));
                zmsg_send (&amp;msg, backend);
            }
        }
    }
    //  程序运行结束，进行清理
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>以下是worker的代码，用到了“懒惰的海盗”服务，并将其调整为LRU模式（使用REQ套接字传递“已就绪”信号）：</p>
<p><strong>spworker: Simple Pirate worker in C</strong></p>
<pre><code class="c">//
//  简单海盗模式worker
//  
//  使用REQ套接字连接tcp://*:5556，使用LRU算法实现worker
//
#include &quot;czmq.h&quot;
#define LRU_READY   &quot;\001&quot;      //  消息：worker已就绪

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);

    //  使用随机符号来指定套接字标识，方便追踪
    srandom ((unsigned) time (NULL));
    char identity [10];
    sprintf (identity, &quot;%04X-%04X&quot;, randof (0x10000), randof (0x10000));
    zmq_setsockopt (worker, ZMQ_IDENTITY, identity, strlen (identity));
    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);

    //  告诉代理worker已就绪
    printf (&quot;I: (%s) worker准备就绪\n&quot;, identity);
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    int cycles = 0;
    while (1) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  中断

        //  经过几轮循环后，模拟各种问题
        cycles++;
        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
            printf (&quot;I: (%s) 模拟崩溃\n&quot;, identity);
            zmsg_destroy (&amp;msg);
            break;
        }
        else
        if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
            printf (&quot;I: (%s) 模拟CPU过载\n&quot;, identity);
            sleep (3);
            if (zctx_interrupted)
                break;
        }
        printf (&quot;I: (%s) 正常应答\n&quot;, identity);
        sleep (1);              //  进行某些处理
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>运行上述事例，启动多个worker，一个client，以及一个队列装置，顺序随意。你可以看到worker最终都会崩溃或死亡，client则多次重试并最终放弃。装置从来不会停止，你可以任意重启worker和client，这个模型可以和任意个worker、client交互。</p>
<h3 id="健壮的可靠队列（偏执海盗模式）"><a href="#健壮的可靠队列（偏执海盗模式）" class="headerlink" title="健壮的可靠队列（偏执海盗模式）"></a>健壮的可靠队列（偏执海盗模式）</h3><p>“简单海盗队列”模式工作得非常好，主要是因为它只是两个现有模式的结合体。不过，它也有一些缺点：</p>
<ul>
<li><p>该模式无法处理队列的崩溃或重启。client会进行重试，但worker不会重启。虽然ZMQ会自动重连worker的套接字，但对于新启动的队列装置来说，由于worker并没有发送“已就绪”的消息，所以它相当于是不存在的。为了解决这一问题，我们需要从队列发送心跳给worker，这样worker就能知道队列是否已经死亡。</p>
</li>
<li><p>队列没有检测worker是否已经死亡，所以当worker在处于空闲状态时死亡，队列装置只有在发送了某个请求之后才会将该worker从队列中移除。这时，client什么都不能做，只能等待。这不是一个致命的问题，但是依然是不够好的。所以，我们需要从worker发送心跳给队列装置，从而让队列得知worker什么时候消亡。</p>
</li>
</ul>
<p>我们使用一个名为“偏执的海盗模式”来解决上述两个问题。</p>
<p>之前我们使用REQ套接字作为worker的套接字类型，但在偏执海盗模式中我们会改用DEALER套接字，从而使我们能够任意地发送和接受消息，而不是像REQ套接字那样必须完成发送-接受循环。而DEALER的缺点是我们必须自己管理消息信封。如果你不知道信封是什么，那请阅读第三章。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_3.png" alt="3"></p>
<p>我们仍会使用懒惰海盗模式的client，以下是偏执海盗的队列装置代码：</p>
<p><strong>ppqueue: Paranoid Pirate queue in C</strong></p>
<pre><code class="c">//
//  偏执海盗队列
//
#include &quot;czmq.h&quot;

#define HEARTBEAT_LIVENESS  3       //  心跳健康度，3-5是合理的
#define HEARTBEAT_INTERVAL  1000    //  单位：毫秒

//  偏执海盗协议的消息代码
#define PPP_READY       &quot;\001&quot;      //  worker已就绪
#define PPP_HEARTBEAT   &quot;\002&quot;      //  worker心跳


//  使用以下结构表示worker队列中的一个有效的worker

typedef struct {
    zframe_t *address;          //  worker的地址
    char *identity;             //  可打印的套接字标识
    int64_t expiry;             //  过期时间
} worker_t;

//  创建新的worker
static worker_t *
s_worker_new (zframe_t *address)
{
    worker_t *self = (worker_t *) zmalloc (sizeof (worker_t));
    self-&gt;address = address;
    self-&gt;identity = zframe_strdup (address);
    self-&gt;expiry = zclock_time () + HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS;
    return self;
}

//  销毁worker结构，包括标识
static void
s_worker_destroy (worker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        worker_t *self = *self_p;
        zframe_destroy (&amp;self-&gt;address);
        free (self-&gt;identity);
        free (self);
        *self_p = NULL;
    }
}

//  worker已就绪，将其移至列表末尾
static void
s_worker_ready (worker_t *self, zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (streq (self-&gt;identity, worker-&gt;identity)) {
            zlist_remove (workers, worker);
            s_worker_destroy (&amp;worker);
            break;
        }
        worker = (worker_t *) zlist_next (workers);
    }
    zlist_append (workers, self);
}

//  返回下一个可用的worker地址
static zframe_t *
s_workers_next (zlist_t *workers)
{
    worker_t *worker = zlist_pop (workers);
    assert (worker);
    zframe_t *frame = worker-&gt;address;
    worker-&gt;address = NULL;
    s_worker_destroy (&amp;worker);
    return frame;
}

//  寻找并销毁已过期的worker。
//  由于列表中最旧的worker排在最前，所以当找到第一个未过期的worker时就停止。
static void
s_workers_purge (zlist_t *workers)
{
    worker_t *worker = (worker_t *) zlist_first (workers);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            break;              //  worker未过期，停止扫描

        zlist_remove (workers, worker);
        s_worker_destroy (&amp;worker);
        worker = (worker_t *) zlist_first (workers);
    }
}


int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend  = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);    //  client端点
    zsocket_bind (backend,  &quot;tcp://*:5556&quot;);    //  worker端点
    //  List of available workers
    zlist_t *workers = zlist_new ();

    //  规律地发送心跳
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    while (1) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  当存在可用worker时轮询前端端点
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1,
            HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断

        //  处理后端worker请求
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  使用worker地址进行LRU路由
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  中断

            //  worker的任何信号均表示其仍然存活
            zframe_t *address = zmsg_unwrap (msg);
            worker_t *worker = s_worker_new (address);
            s_worker_ready (worker, workers);

            //  处理控制消息，或者将应答转发给client
            if (zmsg_size (msg) == 1) {
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_READY, 1)
                &amp;&amp;  memcmp (zframe_data (frame), PPP_HEARTBEAT, 1)) {
                    printf (&quot;E: invalid message from worker&quot;);
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  获取下一个client请求，交给下一个可用的worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (!msg)
                break;          //  中断
            zmsg_push (msg, s_workers_next (workers));
            zmsg_send (&amp;msg, backend);
        }

        //  发送心跳给空闲的worker
        if (zclock_time () &gt;= heartbeat_at) {
            worker_t *worker = (worker_t *) zlist_first (workers);
            while (worker) {
                zframe_send (&amp;worker-&gt;address, backend,
                             ZFRAME_REUSE + ZFRAME_MORE);
                zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
                zframe_send (&amp;frame, backend, 0);
                worker = (worker_t *) zlist_next (workers);
            }
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
        s_workers_purge (workers);
    }

    //  程序结束后进行清理
    while (zlist_size (workers)) {
        worker_t *worker = (worker_t *) zlist_pop (workers);
        s_worker_destroy (&amp;worker);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>该队列装置使用心跳机制扩展了LRU模式，看起来很简单，但要想出这个主意还挺难的。下文会更多地介绍心跳机制。</p>
<p>以下是偏执海盗的worker代码：</p>
<p><strong>ppworker: Paranoid Pirate worker in C</strong></p>
<pre><code class="c">//
//  偏执海盗worker
//
#include &quot;czmq.h&quot;

#define HEARTBEAT_LIVENESS  3       //  合理值：3-5
#define HEARTBEAT_INTERVAL  1000    //  单位：毫秒
#define INTERVAL_INIT       1000    //  重试间隔
#define INTERVAL_MAX       32000    //  回退算法最大值

//  偏执海盗规范的常量定义
#define PPP_READY       &quot;\001&quot;      //  消息：worker已就绪
#define PPP_HEARTBEAT   &quot;\002&quot;      //  消息：worker心跳

//  返回一个连接至偏执海盗队列装置的套接字

static void *
s_worker_socket (zctx_t *ctx) {
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);

    //  告知队列worker已准备就绪
    printf (&quot;I: worker已就绪\n&quot;);
    zframe_t *frame = zframe_new (PPP_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    return worker;
}

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *worker = s_worker_socket (ctx);

    //  如果心跳健康度为零，则表示队列装置已死亡
    size_t liveness = HEARTBEAT_LIVENESS;
    size_t interval = INTERVAL_INIT;

    //  规律地发送心跳
    uint64_t heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;

    srandom ((unsigned) time (NULL));
    int cycles = 0;
    while (1) {
        zmq_pollitem_t items [] = { { worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断

        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  获取消息
            //  - 3段消息，信封+内容，表示一个请求
            //  - 1段消息，表示心跳
            zmsg_t *msg = zmsg_recv (worker);
            if (!msg)
                break;          //  中断

            if (zmsg_size (msg) == 3) {
                //  若干词循环后模拟各种问题
                cycles++;
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf (&quot;I: 模拟崩溃\n&quot;);
                    zmsg_destroy (&amp;msg);
                    break;
                }
                else
                if (cycles &gt; 3 &amp;&amp; randof (5) == 0) {
                    printf (&quot;I: 模拟CPU过载\n&quot;);
                    sleep (3);
                    if (zctx_interrupted)
                        break;
                }
                printf (&quot;I: 正常应答\n&quot;);
                zmsg_send (&amp;msg, worker);
                liveness = HEARTBEAT_LIVENESS;
                sleep (1);              //  做一些处理工作
                if (zctx_interrupted)
                    break;
            }
            else
            if (zmsg_size (msg) == 1) {
                zframe_t *frame = zmsg_first (msg);
                if (memcmp (zframe_data (frame), PPP_HEARTBEAT, 1) == 0)
                    liveness = HEARTBEAT_LIVENESS;
                else {
                    printf (&quot;E: 非法消息\n&quot;);
                    zmsg_dump (msg);
                }
                zmsg_destroy (&amp;msg);
            }
            else {
                printf (&quot;E: 非法消息\n&quot;);
                zmsg_dump (msg);
            }
            interval = INTERVAL_INIT;
        }
        else
        if (--liveness == 0) {
            printf (&quot;W: 心跳失败，无法连接队列装置\n&quot;);
            printf (&quot;W: %zd 毫秒后进行重连...\n&quot;, interval);
            zclock_sleep (interval);

            if (interval &lt; INTERVAL_MAX)
                interval *= 2;
            zsocket_destroy (ctx, worker);
            worker = s_worker_socket (ctx);
            liveness = HEARTBEAT_LIVENESS;
        }

        //  适时发送心跳给队列
        if (zclock_time () &gt; heartbeat_at) {
            heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
            printf (&quot;I: worker心跳\n&quot;);
            zframe_t *frame = zframe_new (PPP_HEARTBEAT, 1);
            zframe_send (&amp;frame, worker, 0);
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>代码中包含了几处失败模拟，和先前一样。这会让代码极难维护，所以当投入使用时，应当移除这些模拟代码。</li>
<li>偏执海盗模式中队列的心跳有时会不正常，下文会讲述这一点。</li>
<li>worker使用了一种类似于懒惰海盗client的重试机制，但有两点不同：1、回退算法设置；2、永不言弃。</li>
</ul>
<p>尝试运行以下代码，跑通流程：</p>
<pre><code>ppqueue &amp;
for i in 1 2 3 4; do
    ppworker &amp;
    sleep 1
done
lpclient &amp;
</code></pre><p>你会看到worker逐个崩溃，client在多次尝试后放弃。你可以停止并重启队列装置，client和worker会相继重连，并正确地发送、处理和接收请求，顺序不会混乱。所以说，整个通信过程只有两种情形：交互成功，或client最终放弃。</p>
<h3 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h3><p>当我在写偏执海盗模式的示例时，大约花了五个小时的时间来协调队列至worker的心跳，剩下的请求-应答链路只花了约10分钟的时间。心跳机制在可靠性上带来的益处有时还不及它所引发的问题。使用过程中很有可能会产生“虚假故障”的情况，即节点误认为他们已失去连接，因为心跳没有正确地发送。</p>
<p>在理解和实施心跳时，需要考虑以下几点：</p>
<ul>
<li><p>心跳不是一种请求-应答，它们异步地在节点之间传递，任一节点都可以通过它来判断对方已经死亡，并中止通信。</p>
</li>
<li><p>如果某个节点使用持久套接字（即设定了套接字标识），意味着发送给它的心跳可能会堆砌，并在重连后一起收到。所以说，worker不应该使用持久套接字。示例代码使用持久套接字是为了便于调试，而且代码中使用了随机的套接字标识，避免重用之前的标识。</p>
</li>
<li><p>使用过程中，应先让心跳工作起来，再进行后面的消息处理。你需要保证启动任一节点后，心跳都能正确地执行。停止并重启他们，模拟冻结、崩溃等情况来进行测试。</p>
</li>
<li><p>当你的主循环使用了zmq_poll()，则应该使用另一个计时器来触发心跳。不要使用主循环来控制心跳的发送，这回导致过量地发送心跳（阻塞网络），或是发送得太少（导致节点断开）。zhelpers包提供了s_clock()函数返回当前系统时间戳，单位是毫秒，可以用它来控制心跳的发送间隔。C代码如下：</p>
</li>
</ul>
<pre><code class="c">// 规律地发送心跳
uint64_t heartbeat_at = s_clock () + HEARTBEAT_INTERVAL;
while (1) {
    …
    zmq_poll (items, 1, HEARTBEAT_INTERVAL * 1000);
    …
    // 无论zmq_poll的行为是什么，都使用以下逻辑判断是否发送心跳
    if (s_clock () &gt; heartbeat_at) {
        … 发送心跳给所有节点
        // 设置下一次心跳的时间
        heartbeat_at = s_clock () + HEARTBEAT_INTERVAL;
    }
}
</code></pre>
<ul>
<li><p>主循环应该使用心跳间隔作为超时时间。显然不能使用无超时时间的设置，而短于心跳间隔也只是浪费循环次数而已。</p>
</li>
<li><p>使用简单的追踪方式来进行追踪，如直接输出至控制台。这里有一些追踪的窍门：使用zmsg()函数打印套接字内容；对消息进行编号，判断是否会有间隔。</p>
</li>
<li><p>在真实的应用程序中，心跳必须是可以配置的，并能和节点共同商定。有些节点需要高频心跳，如10毫秒，另一些节点则可能只需要30秒发送一次心跳即可。</p>
</li>
<li><p>如果你要对不同的节点发送不同频率的心跳，那么poll的超时时间应设置为最短的心跳间隔。</p>
</li>
<li><p>也许你会想要用一个单独的套接字来处理心跳，这看起来很棒，可以将同步的请求-应答和异步的心跳隔离开来。但是，这个主意并不好，原因有几点：首先、发送数据时其实是不需要发送心跳的；其次、套接字可能会因为网络问题而阻塞，你需要设法知道用于发送数据的套接字停止响应的原因是死亡了还是过于繁忙而已，这样你就需要对这个套接字进行心跳。最后，处理两个套接字要比处理一个复杂得多。</p>
</li>
<li><p>我们没有设置client至队列的心跳，因为这太过复杂了，而且没有太大价值。</p>
</li>
</ul>
<h3 id="约定和协议"><a href="#约定和协议" class="headerlink" title="约定和协议"></a>约定和协议</h3><p>也许你已经注意到，由于心跳机制，偏执海盗模式和简单海盗模式是不兼容的。</p>
<p>其实，这里我们需要写一个协议。也许在试验阶段是不需要协议的，但这在真实的应用程序中是有必要。如果我们想用其他语言来写worker怎么办？我们是否需要通过源代码来查看通信过程？如果我们想改变协议怎么办？规范可能很简单，但并不显然。越是成功的协议，就会越为复杂。</p>
<p>一个缺乏约定的应用程序一定是不可复用的，所以让我们来为这个协议写一个规范，怎么做呢？</p>
<ul>
<li>位于<a href="http://rfc.zeromq.org/" target="_blank" rel="external">rfc.zeromq.org</a>的wiki页上，我们特地设置了一个用于存放ZMQ协议的页面。<ul>
<li>要创建一个新的协议，你需要注册并按照指导进行。过程很直接，但并不一定所有人都能撰写技术性文档。</li>
</ul>
</li>
</ul>
<p>我大约花了15分钟的时间草拟<a href="http://rfc.zeromq.org/spec:6" target="_blank" rel="external">海盗模式规范（PPP）</a>，麻雀虽小，但五脏俱全。</p>
<p>要用PPP协议进行真实环境下的编程，你还需要：</p>
<ul>
<li>在READY命令中加入版本号，这样就能再日后安全地新增PPP版本号。</li>
<li>目前，READY和HEARTBEAT信号并没有指定其来源于请求还是应答。要区分他们，需要新建一个消息结构，其中包含“消息类型”这一信息。</li>
</ul>
<h3 id="面向服务的可靠队列（管家模式）"><a href="#面向服务的可靠队列（管家模式）" class="headerlink" title="面向服务的可靠队列（管家模式）"></a>面向服务的可靠队列（管家模式）</h3><p>世上的事物往往瞬息万变，正当我们期待有更好的协议来解决上一节的问题时，已经有人制定好了：</p>
<ul>
<li><a href="http://rfc.zeromq.org/spec:7" target="_blank" rel="external">http://rfc.zeromq.org/spec:7</a></li>
</ul>
<p>这份协议只有一页，它将PPP协议变得更为坚固。我们在设计复杂架构时应该这样做：首先写下约定，再用软件去实现它。</p>
<p>管家模式协议（MDP）在扩展PPP协议时引入了一个有趣的特性：client发送的每一个请求都有一个“服务名称”，而worker在像队列装置注册时需要告知自己的服务类型。MDP的优势在于它来源于现实编程，协议简单，且容易提升。</p>
<p>引入“服务名称”的机制，是对偏执海盗队列的一个简单补充，而结果是让其成为一个面向服务的代理。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_4.png" alt="4"></p>
<p>在实施管家模式之前，我们需要为client和worker编写一个框架。如果程序员可以通过简单的API来实现这种模式，那就没有必要让他们去了解管家模式的协议内容和实现方法了。<br>所以，我们第一个协议（即管家模式协议）定义了分布式架构中节点是如何互相交互的，第二个协议则要定义应用程序应该如何通过框架来使用这一协议。<br>管家模式有两个端点，客户端和服务端。因为我们要为client和worker都撰写框架，所以就需要提供两套API。以下是用简单的面向对象方法设计的client端API雏形，使用的是C语言的<a href="http://zfl.zeromq.org/page:read-the-manual" target="_blank" rel="external">ZFL library</a>。</p>
<pre><code class="c">mdcli_t *mdcli_new     (char *broker);
void     mdcli_destroy (mdcli_t **self_p);
zmsg_t  *mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);
</code></pre>
<p>就这么简单。我们创建了一个会话来和代理通信，发送并接收一个请求，最后关闭连接。以下是worker端API的雏形。</p>
<pre><code class="c">mdwrk_t *mdwrk_new     (char *broker,char *service);
void     mdwrk_destroy (mdwrk_t **self_p);
zmsg_t  *mdwrk_recv    (mdwrk_t *self, zmsg_t *reply);
</code></pre>
<p>上面两段代码看起来差不多，但是worker端API略有不同。worker第一次执行recv()后会传递一个空的应答，之后才传递当前的应答，并获得新的请求。</p>
<p>两段的API都很容易开发，只需在偏执海盗模式代码的基础上修改即可。以下是client API：</p>
<p><strong>mdcliapi: Majordomo client API in C</strong></p>
<pre><code class="c">/*  =====================================================================
    mdcliapi.c

    Majordomo Protocol Client API
    Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;mdcliapi.h&quot;

//  类结构
//  我们会通过成员方法来访问这些属性

struct _mdcli_t {
    zctx_t *ctx;                //  上下文
    char *broker;
    void *client;               //  连接至代理的套接字
    int verbose;                //  使用标准输出打印当前活动
    int timeout;                //  请求超时时间
    int retries;                //  请求重试次数
};


//  ---------------------------------------------------------------------
//  连接或重连代理

void s_mdcli_connect_to_broker (mdcli_t *self)
{
    if (self-&gt;client)
        zsocket_destroy (self-&gt;ctx, self-&gt;client);
    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_REQ);
    zmq_connect (self-&gt;client, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log (&quot;I: 正在连接至代理 %s...&quot;, self-&gt;broker);
}


//  ---------------------------------------------------------------------
//  构造函数

mdcli_t *
mdcli_new (char *broker, int verbose)
{
    assert (broker);

    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;verbose = verbose;
    self-&gt;timeout = 2500;           //  毫秒
    self-&gt;retries = 3;              //  尝试次数

    s_mdcli_connect_to_broker (self);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

void
mdcli_destroy (mdcli_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdcli_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  设定请求超时时间

void
mdcli_set_timeout (mdcli_t *self, int timeout)
{
    assert (self);
    self-&gt;timeout = timeout;
}


//  ---------------------------------------------------------------------
//  设定请求重试次数

void
mdcli_set_retries (mdcli_t *self, int retries)
{
    assert (self);
    self-&gt;retries = retries;
}


//  ---------------------------------------------------------------------
//  向代理发送请求，并尝试获取应答；
//  对消息保持所有权，发送后销毁；
//  返回应答消息，或NULL。

zmsg_t *
mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)
{
    assert (self);
    assert (request_p);
    zmsg_t *request = *request_p;

    //  用协议前缀包装消息
    //  Frame 1: &quot;MDPCxy&quot; (six bytes, MDP/Client x.y)
    //  Frame 2: 服务名称 (可打印字符串)
    zmsg_pushstr (request, service);
    zmsg_pushstr (request, MDPC_CLIENT);
    if (self-&gt;verbose) {
        zclock_log (&quot;I: 发送请求给 &#39;%s&#39; 服务:&quot;, service);
        zmsg_dump (request);
    }

    int retries_left = self-&gt;retries;
    while (retries_left &amp;&amp; !zctx_interrupted) {
        zmsg_t *msg = zmsg_dup (request);
        zmsg_send (&amp;msg, self-&gt;client);

        while (TRUE) {
            //  轮询套接字以接收应答，有超时时间
            zmq_pollitem_t items [] = {
                { self-&gt;client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  中断

            //  收到应答后进行处理
            if (items [0].revents &amp; ZMQ_POLLIN) {
                zmsg_t *msg = zmsg_recv (self-&gt;client);
                if (self-&gt;verbose) {
                    zclock_log (&quot;I: received reply:&quot;);
                    zmsg_dump (msg);
                }
                //  不要尝试处理错误，直接报错即可
                assert (zmsg_size (msg) &gt;= 3);

                zframe_t *header = zmsg_pop (msg);
                assert (zframe_streq (header, MDPC_CLIENT));
                zframe_destroy (&amp;header);

                zframe_t *reply_service = zmsg_pop (msg);
                assert (zframe_streq (reply_service, service));
                zframe_destroy (&amp;reply_service);

                zmsg_destroy (&amp;request);
                return msg;     //  成功
            }
            else
            if (--retries_left) {
                if (self-&gt;verbose)
                    zclock_log (&quot;W: no reply, reconnecting...&quot;);
                //  重连并重发消息
                s_mdcli_connect_to_broker (self);
                zmsg_t *msg = zmsg_dup (request);
                zmsg_send (&amp;msg, self-&gt;client);
            }
            else {
                if (self-&gt;verbose)
                    zclock_log (&quot;W: 发生严重错误，放弃重试。&quot;);
                break;          //  放弃
            }
        }
    }
    if (zctx_interrupted)
        printf (&quot;W: 收到中断消息，结束client进程...\n&quot;);
    zmsg_destroy (&amp;request);
    return NULL;
}
</code></pre>
<p>以下测试程序会执行10万次请求应答：</p>
<p><strong>mdclient: Majordomo client application in C</strong></p>
<pre><code class="c">//
//  管家模式协议 - 客户端示例
//  使用mdcli API隐藏管家模式协议的内部实现
//

//  让我们直接编译这段代码，不生成类库
#include &quot;mdcliapi.c&quot;

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);

    int count;
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *request = zmsg_new ();
        zmsg_pushstr (request, &quot;Hello world&quot;);
        zmsg_t *reply = mdcli_send (session, &quot;echo&quot;, &amp;request);
        if (reply)
            zmsg_destroy (&amp;reply);
        else
            break;              //  中断或停止
    }
    printf (&quot;已处理 %d 次请求-应答\n&quot;, count);
    mdcli_destroy (&amp;session);
    return 0;
}
</code></pre>
<p>下面是worker的API：</p>
<p><strong>mdwrkapi: Majordomo worker API in C</strong></p>
<pre><code class="c">/*  =====================================================================
    mdwrkapi.c

    Majordomo Protocol Worker API
    Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;mdwrkapi.h&quot;

//  可靠性参数
#define HEARTBEAT_LIVENESS  3       //  合理值：3-5

//  类结构
//  使用成员函数访问属性

struct _mdwrk_t {
    zctx_t *ctx;                //  上下文
    char *broker;
    char *service;
    void *worker;               //  连接至代理的套接字
    int verbose;                //  使用标准输出打印活动

    //  心跳设置
    uint64_t heartbeat_at;      //  发送心跳的时间
    size_t liveness;            //  尝试次数
    int heartbeat;              //  心跳延时，单位：毫秒
    int reconnect;              //  重连延时，单位：毫秒

    //  内部状态
    int expect_reply;           //  初始值为0

    //  应答地址，如果存在的话
    zframe_t *reply_to;
};


//  ---------------------------------------------------------------------
//  发送消息给代理
//  如果没有提供消息，则内部创建一个

static void
s_mdwrk_send_to_broker (mdwrk_t *self, char *command, char *option,
                        zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  将协议信封压入消息顶部
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);
    zmsg_pushstr (msg, &quot;&quot;);

    if (self-&gt;verbose) {
        zclock_log (&quot;I: sending %s to broker&quot;,
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;worker);
}


//  ---------------------------------------------------------------------
//  连接或重连代理

void s_mdwrk_connect_to_broker (mdwrk_t *self)
{
    if (self-&gt;worker)
        zsocket_destroy (self-&gt;ctx, self-&gt;worker);
    self-&gt;worker = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    zmq_connect (self-&gt;worker, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log (&quot;I: 正在连接代理 %s...&quot;, self-&gt;broker);

    //  向代理注册服务类型
    s_mdwrk_send_to_broker (self, MDPW_READY, self-&gt;service, NULL);

    //  当心跳健康度为零，表示代理已断开连接
    self-&gt;liveness = HEARTBEAT_LIVENESS;
    self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
}


//  ---------------------------------------------------------------------
//  构造函数

mdwrk_t *
mdwrk_new (char *broker,char *service, int verbose)
{
    assert (broker);
    assert (service);

    mdwrk_t *self = (mdwrk_t *) zmalloc (sizeof (mdwrk_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;service = strdup (service);
    self-&gt;verbose = verbose;
    self-&gt;heartbeat = 2500;     //  毫秒
    self-&gt;reconnect = 2500;     //  毫秒

    s_mdwrk_connect_to_broker (self);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

void
mdwrk_destroy (mdwrk_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdwrk_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self-&gt;service);
        free (self);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  设置心跳延迟

void
mdwrk_set_heartbeat (mdwrk_t *self, int heartbeat)
{
    self-&gt;heartbeat = heartbeat;
}


//  ---------------------------------------------------------------------
//  设置重连延迟

void
mdwrk_set_reconnect (mdwrk_t *self, int reconnect)
{
    self-&gt;reconnect = reconnect;
}


//  ---------------------------------------------------------------------
//  若有应答则发送给代理，并等待新的请求

zmsg_t *
mdwrk_recv (mdwrk_t *self, zmsg_t **reply_p)
{
    //  格式化并发送请求传入的应答
    assert (reply_p);
    zmsg_t *reply = *reply_p;
    assert (reply || !self-&gt;expect_reply);
    if (reply) {
        assert (self-&gt;reply_to);
        zmsg_wrap (reply, self-&gt;reply_to);
        s_mdwrk_send_to_broker (self, MDPW_REPLY, NULL, reply);
        zmsg_destroy (reply_p);
    }
    self-&gt;expect_reply = 1;

    while (TRUE) {
        zmq_pollitem_t items [] = {
            { self-&gt;worker,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, self-&gt;heartbeat * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断

        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;worker);
            if (!msg)
                break;          //  中断
            if (self-&gt;verbose) {
                zclock_log (&quot;I: 从代理处获得消息:&quot;);
                zmsg_dump (msg);
            }
            self-&gt;liveness = HEARTBEAT_LIVENESS;

            //  不要处理错误，直接报错即可
            assert (zmsg_size (msg) &gt;= 3);

            zframe_t *empty = zmsg_pop (msg);
            assert (zframe_streq (empty, &quot;&quot;));
            zframe_destroy (&amp;empty);

            zframe_t *header = zmsg_pop (msg);
            assert (zframe_streq (header, MDPW_WORKER));
            zframe_destroy (&amp;header);

            zframe_t *command = zmsg_pop (msg);
            if (zframe_streq (command, MDPW_REQUEST)) {
                //  这里需要将消息中空帧之前的所有地址都保存起来，
                //  但在这里我们暂时只保存一个
                self-&gt;reply_to = zmsg_unwrap (msg);
                zframe_destroy (&amp;command);
                return msg;     //  处理请求
            }
            else
            if (zframe_streq (command, MDPW_HEARTBEAT))
                ;               //  不对心跳做任何处理
            else
            if (zframe_streq (command, MDPW_DISCONNECT))
                s_mdwrk_connect_to_broker (self);
            else {
                zclock_log (&quot;E: 消息不合法&quot;);
                zmsg_dump (msg);
            }
            zframe_destroy (&amp;command);
            zmsg_destroy (&amp;msg);
        }
        else
        if (--self-&gt;liveness == 0) {
            if (self-&gt;verbose)
                zclock_log (&quot;W: 失去与代理的连接 - 正在重试...&quot;);
            zclock_sleep (self-&gt;reconnect);
            s_mdwrk_connect_to_broker (self);
        }
        //  适时地发送消息
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_mdwrk_send_to_broker (self, MDPW_HEARTBEAT, NULL, NULL);
            self-&gt;heartbeat_at = zclock_time () + self-&gt;heartbeat;
        }
    }
    if (zctx_interrupted)
        printf (&quot;W: 收到中断消息，中止worker...\n&quot;);
    return NULL;
}
</code></pre>
<p>以下测试程序实现了名为echo的服务：</p>
<p><strong>mdworker: Majordomo worker application in C</strong></p>
<pre><code class="c">//
//  管家模式协议 - worker示例
//  使用mdwrk API隐藏MDP协议的内部实现
//

//  让我们直接编译代码，而不创建类库
#include &quot;mdwrkapi.c&quot;

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    mdwrk_t *session = mdwrk_new (
        &quot;tcp://localhost:5555&quot;, &quot;echo&quot;, verbose);

    zmsg_t *reply = NULL;
    while (1) {
        zmsg_t *request = mdwrk_recv (session, &amp;reply);
        if (request == NULL)
            break;              //  worker被中止
        reply = request;        //  echo服务……其实很复杂:)
    }
    mdwrk_destroy (&amp;session);
    return 0;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>API是单线程的，所以说worker不会再后台发送心跳，而这也是我们所期望的：如果worker应用程序停止了，心跳就会跟着中止，代理便会停止向该worker发送新的请求。</p>
</li>
<li><p>wroker API没有做回退算法的设置，因为这里不值得使用这一复杂的机制。</p>
</li>
<li><p>API没有提供任何报错机制，如果出现问题，它会直接报断言（或异常，依语言而定）。这一做法对实验性的编程是有用的，这样可以立刻看到执行结果。但在真实编程环境中，API应该足够健壮，合适地处理非法消息。</p>
</li>
</ul>
<p>也许你会问，worker API为什么要关闭它的套接字并新开一个呢？特别是ZMQ是有重连机制的，能够在节点归来后进行重连。我们可以回顾一下简单海盗模式中的worker，以及偏执海盗模式中的worker来加以理解。ZMQ确实会进行自动重连，但如果代理死亡并重连，worker并不会重新进行注册。这个问题有两种解决方案：一是我们这里用到的较为简便的方案，即当worker判断代理已经死亡时，关闭它的套接字并重头来过；另一个方案是当代理收到未知worker的心跳时要求该worker对其提供的服务类型进行注册，这样一来就需要在协议中说明这一规则。</p>
<p>下面让我们设计管家模式的代理，它的核心代码是一组队列，每种服务对应一个队列。我们会在worker出现时创建相应的队列（worker消失时应该销毁对应的队列，不过我们这里暂时不考虑）。额外的，我们会为每种服务维护一个worker的队列。</p>
<p>为了让C语言代码更为易读易写，我使用了<a href="http://zfl.zeromq.org" target="_blank" rel="external">ZFL项目</a>提供的哈希和链表容器，并命名为<a href="https://github.com/imatix/zguide/blob/master/examples/C/zhash.h zhash" target="_blank" rel="external">zhash</a>和<a href="https://github.com/imatix/zguide/blob/master/examples/C/zlist.h" target="_blank" rel="external">zlist</a>。如果使用现代语言编写，那自然可以使用其内置的容器。</p>
<p><strong>mdbroker: Majordomo broker in C</strong></p>
<pre><code class="c">//
//  管家模式协议 - 代理
//  协议 http://rfc.zeromq.org/spec:7 和 spec:8 的最简实现
//
#include &quot;czmq.h&quot;
#include &quot;mdp.h&quot;

//  一般我们会从配置文件中获取以下值

#define HEARTBEAT_LIVENESS  3       //  合理值：3-5
#define HEARTBEAT_INTERVAL  2500    //  单位：毫秒
#define HEARTBEAT_EXPIRY    HEARTBEAT_INTERVAL * HEARTBEAT_LIVENESS

//  定义一个代理
typedef struct {
    zctx_t *ctx;                //  上下文
    void *socket;               //  用于连接client和worker的套接字
    int verbose;                //  使用标准输出打印活动信息
    char *endpoint;             //  代理绑定到的端点
    zhash_t *services;          //  已知服务的哈希表
    zhash_t *workers;           //  已知worker的哈希表
    zlist_t *waiting;           //  正在等待的worker队列
    uint64_t heartbeat_at;      //  发送心跳的时间
} broker_t;

//  定义一个服务
typedef struct {
    char *name;                 //  服务名称
    zlist_t *requests;          //  客户端请求队列
    zlist_t *waiting;           //  正在等待的worker队列
    size_t workers;             //  可用worker数
} service_t;

//  定义一个worker，状态为空闲或占用
typedef struct {
    char *identity;             //  worker的标识
    zframe_t *address;          //  地址帧
    service_t *service;         //  所属服务
    int64_t expiry;             //  过期时间，从未收到心跳起计时
} worker_t;


//  ---------------------------------------------------------------------
//  代理使用的函数
static broker_t *
    s_broker_new (int verbose);
static void
    s_broker_destroy (broker_t **self_p);
static void
    s_broker_bind (broker_t *self, char *endpoint);
static void
    s_broker_purge_workers (broker_t *self);

//  服务使用的函数
static service_t *
    s_service_require (broker_t *self, zframe_t *service_frame);
static void
    s_service_destroy (void *argument);
static void
    s_service_dispatch (broker_t *self, service_t *service, zmsg_t *msg);
static void
    s_service_internal (broker_t *self, zframe_t *service_frame, zmsg_t *msg);

//  worker使用的函数
static worker_t *
    s_worker_require (broker_t *self, zframe_t *address);
static void
    s_worker_delete (broker_t *self, worker_t *worker, int disconnect);
static void
    s_worker_destroy (void *argument);
static void
    s_worker_process (broker_t *self, zframe_t *sender, zmsg_t *msg);
static void
    s_worker_send (broker_t *self, worker_t *worker, char *command,
                   char *option, zmsg_t *msg);
static void
    s_worker_waiting (broker_t *self, worker_t *worker);

//  客户端使用的函数
static void
    s_client_process (broker_t *self, zframe_t *sender, zmsg_t *msg);


//  ---------------------------------------------------------------------
//  主程序

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));

    broker_t *self = s_broker_new (verbose);
    s_broker_bind (self, &quot;tcp://*:5555&quot;);

    //  接受并处理消息，直至程序被中止
    while (TRUE) {
        zmq_pollitem_t items [] = {
            { self-&gt;socket,  0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, HEARTBEAT_INTERVAL * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断

        //  Process next input message, if any
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (self-&gt;socket);
            if (!msg)
                break;          //  中断
            if (self-&gt;verbose) {
                zclock_log (&quot;I: 收到消息:&quot;);
                zmsg_dump (msg);
            }
            zframe_t *sender = zmsg_pop (msg);
            zframe_t *empty  = zmsg_pop (msg);
            zframe_t *header = zmsg_pop (msg);

            if (zframe_streq (header, MDPC_CLIENT))
                s_client_process (self, sender, msg);
            else
            if (zframe_streq (header, MDPW_WORKER))
                s_worker_process (self, sender, msg);
            else {
                zclock_log (&quot;E: 非法消息:&quot;);
                zmsg_dump (msg);
                zmsg_destroy (&amp;msg);
            }
            zframe_destroy (&amp;sender);
            zframe_destroy (&amp;empty);
            zframe_destroy (&amp;header);
        }
        //  断开并删除过期的worker
        //  适时地发送心跳给worker
        if (zclock_time () &gt; self-&gt;heartbeat_at) {
            s_broker_purge_workers (self);
            worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
            while (worker) {
                s_worker_send (self, worker, MDPW_HEARTBEAT, NULL, NULL);
                worker = (worker_t *) zlist_next (self-&gt;waiting);
            }
            self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
        }
    }
    if (zctx_interrupted)
        printf (&quot;W: 收到中断消息，关闭中...\n&quot;);

    s_broker_destroy (&amp;self);
    return 0;
}


//  ---------------------------------------------------------------------
//  代理对象的构造函数

static broker_t *
s_broker_new (int verbose)
{
    broker_t *self = (broker_t *) zmalloc (sizeof (broker_t));

    //  初始化代理状态
    self-&gt;ctx = zctx_new ();
    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;verbose = verbose;
    self-&gt;services = zhash_new ();
    self-&gt;workers = zhash_new ();
    self-&gt;waiting = zlist_new ();
    self-&gt;heartbeat_at = zclock_time () + HEARTBEAT_INTERVAL;
    return self;
}

//  ---------------------------------------------------------------------
//  代理对象的析构函数

static void
s_broker_destroy (broker_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        broker_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        zhash_destroy (&amp;self-&gt;services);
        zhash_destroy (&amp;self-&gt;workers);
        zlist_destroy (&amp;self-&gt;waiting);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  将代理套接字绑定至端点，可以重复调用该函数
//  我们使用一个套接字来同时处理client和worker

void
s_broker_bind (broker_t *self, char *endpoint)
{
    zsocket_bind (self-&gt;socket, endpoint);
    zclock_log (&quot;I: MDP broker/0.1.1 is active at %s&quot;, endpoint);
}

//  ---------------------------------------------------------------------
//  删除空闲状态中过期的worker

static void
s_broker_purge_workers (broker_t *self)
{
    worker_t *worker = (worker_t *) zlist_first (self-&gt;waiting);
    while (worker) {
        if (zclock_time () &lt; worker-&gt;expiry)
            continue;              //  该worker未过期，停止搜索
        if (self-&gt;verbose)
            zclock_log (&quot;I: 正在删除过期的worker: %s&quot;,
                worker-&gt;identity);

        s_worker_delete (self, worker, 0);
        worker = (worker_t *) zlist_first (self-&gt;waiting);
    }
}

//  ---------------------------------------------------------------------
//  定位或创建新的服务项

static service_t *
s_service_require (broker_t *self, zframe_t *service_frame)
{
    assert (service_frame);
    char *name = zframe_strdup (service_frame);

    service_t *service =
        (service_t *) zhash_lookup (self-&gt;services, name);
    if (service == NULL) {
        service = (service_t *) zmalloc (sizeof (service_t));
        service-&gt;name = name;
        service-&gt;requests = zlist_new ();
        service-&gt;waiting = zlist_new ();
        zhash_insert (self-&gt;services, name, service);
        zhash_freefn (self-&gt;services, name, s_service_destroy);
        if (self-&gt;verbose)
            zclock_log (&quot;I: 收到消息:&quot;);
    }
    else
        free (name);

    return service;
}

//  ---------------------------------------------------------------------
//  当服务从broker-&gt;services中移除时销毁该服务对象

static void
s_service_destroy (void *argument)
{
    service_t *service = (service_t *) argument;
    //  销毁请求队列中的所有项目
    while (zlist_size (service-&gt;requests)) {
        zmsg_t *msg = zlist_pop (service-&gt;requests);
        zmsg_destroy (&amp;msg);
    }
    zlist_destroy (&amp;service-&gt;requests);
    zlist_destroy (&amp;service-&gt;waiting);
    free (service-&gt;name);
    free (service);
}

//  ---------------------------------------------------------------------
//  可能时，分发请求给等待中的worker

static void
s_service_dispatch (broker_t *self, service_t *service, zmsg_t *msg)
{
    assert (service);
    if (msg)                    //  将消息加入队列
        zlist_append (service-&gt;requests, msg);

    s_broker_purge_workers (self);
    while (zlist_size (service-&gt;waiting)
        &amp;&amp; zlist_size (service-&gt;requests))
    {
        worker_t *worker = zlist_pop (service-&gt;waiting);
        zlist_remove (self-&gt;waiting, worker);
        zmsg_t *msg = zlist_pop (service-&gt;requests);
        s_worker_send (self, worker, MDPW_REQUEST, NULL, msg);
        zmsg_destroy (&amp;msg);
    }
}

//  ---------------------------------------------------------------------
//  使用8/MMI协定处理内部服务

static void
s_service_internal (broker_t *self, zframe_t *service_frame, zmsg_t *msg)
{
    char *return_code;
    if (zframe_streq (service_frame, &quot;mmi.service&quot;)) {
        char *name = zframe_strdup (zmsg_last (msg));
        service_t *service =
            (service_t *) zhash_lookup (self-&gt;services, name);
        return_code = service &amp;&amp; service-&gt;workers? &quot;200&quot;: &quot;404&quot;;
        free (name);
    }
    else
        return_code = &quot;501&quot;;

    zframe_reset (zmsg_last (msg), return_code, strlen (return_code));

    //  移除并保存返回给client的信封，插入协议头信息和服务名称，并重新包装信封
    zframe_t *client = zmsg_unwrap (msg);
    zmsg_push (msg, zframe_dup (service_frame));
    zmsg_pushstr (msg, MDPC_CLIENT);
    zmsg_wrap (msg, client);
    zmsg_send (&amp;msg, self-&gt;socket);
}

//  ---------------------------------------------------------------------
//  按需创建worker

static worker_t *
s_worker_require (broker_t *self, zframe_t *address)
{
    assert (address);

    //  self-&gt;workers使用wroker的标识为键
    char *identity = zframe_strhex (address);
    worker_t *worker =
        (worker_t *) zhash_lookup (self-&gt;workers, identity);

    if (worker == NULL) {
        worker = (worker_t *) zmalloc (sizeof (worker_t));
        worker-&gt;identity = identity;
        worker-&gt;address = zframe_dup (address);
        zhash_insert (self-&gt;workers, identity, worker);
        zhash_freefn (self-&gt;workers, identity, s_worker_destroy);
        if (self-&gt;verbose)
            zclock_log (&quot;I: 正在注册新的worker: %s&quot;, identity);
    }
    else
        free (identity);
    return worker;
}

//  ---------------------------------------------------------------------
//  从所有数据结构中删除wroker，并销毁worker对象

static void
s_worker_delete (broker_t *self, worker_t *worker, int disconnect)
{
    assert (worker);
    if (disconnect)
        s_worker_send (self, worker, MDPW_DISCONNECT, NULL, NULL);

    if (worker-&gt;service) {
        zlist_remove (worker-&gt;service-&gt;waiting, worker);
        worker-&gt;service-&gt;workers--;
    }
    zlist_remove (self-&gt;waiting, worker);
    //  以下方法间接调用了s_worker_destroy()方法
    zhash_delete (self-&gt;workers, worker-&gt;identity);
}

//  ---------------------------------------------------------------------
//  当worker从broker-&gt;workers中移除时，销毁worker对象

static void
s_worker_destroy (void *argument)
{
    worker_t *worker = (worker_t *) argument;
    zframe_destroy (&amp;worker-&gt;address);
    free (worker-&gt;identity);
    free (worker);
}

//  ---------------------------------------------------------------------
//  处理worker发送来的消息

static void
s_worker_process (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 1);     //  消息中至少包含命令帧

    zframe_t *command = zmsg_pop (msg);
    char *identity = zframe_strhex (sender);
    int worker_ready = (zhash_lookup (self-&gt;workers, identity) != NULL);
    free (identity);
    worker_t *worker = s_worker_require (self, sender);

    if (zframe_streq (command, MDPW_READY)) {
        //  若worker队列中已有该worker，但仍收到了它的“已就绪”消息，则删除这个worker。
        if (worker_ready)
            s_worker_delete (self, worker, 1);
        else
        if (zframe_size (sender) &gt;= 4  //  服务名称为保留的服务
        &amp;&amp;  memcmp (zframe_data (sender), &quot;mmi.&quot;, 4) == 0)
            s_worker_delete (self, worker, 1);
        else {
            //  将worker对应到服务，并置为空闲状态
            zframe_t *service_frame = zmsg_pop (msg);
            worker-&gt;service = s_service_require (self, service_frame);
            worker-&gt;service-&gt;workers++;
            s_worker_waiting (self, worker);
            zframe_destroy (&amp;service_frame);
        }
    }
    else
    if (zframe_streq (command, MDPW_REPLY)) {
        if (worker_ready) {
            //  移除并保存返回给client的信封，插入协议头信息和服务名称，并重新包装信封
            zframe_t *client = zmsg_unwrap (msg);
            zmsg_pushstr (msg, worker-&gt;service-&gt;name);
            zmsg_pushstr (msg, MDPC_CLIENT);
            zmsg_wrap (msg, client);
            zmsg_send (&amp;msg, self-&gt;socket);
            s_worker_waiting (self, worker);
        }
        else
            s_worker_delete (self, worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_HEARTBEAT)) {
        if (worker_ready)
            worker-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
        else
            s_worker_delete (self, worker, 1);
    }
    else
    if (zframe_streq (command, MDPW_DISCONNECT))
        s_worker_delete (self, worker, 0);
    else {
        zclock_log (&quot;E: 非法消息&quot;);
        zmsg_dump (msg);
    }
    free (command);
    zmsg_destroy (&amp;msg);
}

//  ---------------------------------------------------------------------
//  发送消息给worker
//  如果指针指向了一条消息，发送它，但不销毁它，因为这是调用者的工作

static void
s_worker_send (broker_t *self, worker_t *worker, char *command,
               char *option, zmsg_t *msg)
{
    msg = msg? zmsg_dup (msg): zmsg_new ();

    //  将协议信封压入消息顶部
    if (option)
        zmsg_pushstr (msg, option);
    zmsg_pushstr (msg, command);
    zmsg_pushstr (msg, MDPW_WORKER);

    //  在消息顶部插入路由帧
    zmsg_wrap (msg, zframe_dup (worker-&gt;address));

    if (self-&gt;verbose) {
        zclock_log (&quot;I: 正在发送消息给worker %s&quot;,
            mdps_commands [(int) *command]);
        zmsg_dump (msg);
    }
    zmsg_send (&amp;msg, self-&gt;socket);
}

//  ---------------------------------------------------------------------
//  正在等待的worker

static void
s_worker_waiting (broker_t *self, worker_t *worker)
{
    //  将worker加入代理和服务的等待队列
    zlist_append (self-&gt;waiting, worker);
    zlist_append (worker-&gt;service-&gt;waiting, worker);
    worker-&gt;expiry = zclock_time () + HEARTBEAT_EXPIRY;
    s_service_dispatch (self, worker-&gt;service, NULL);
}

//  ---------------------------------------------------------------------
//  处理client发来的请求

static void
s_client_process (broker_t *self, zframe_t *sender, zmsg_t *msg)
{
    assert (zmsg_size (msg) &gt;= 2);     //  服务名称 + 请求内容

    zframe_t *service_frame = zmsg_pop (msg);
    service_t *service = s_service_require (self, service_frame);

    //  为应答内容设置请求方的地址
    zmsg_wrap (msg, zframe_dup (sender));
    if (zframe_size (service_frame) &gt;= 4
    &amp;&amp;  memcmp (zframe_data (service_frame), &quot;mmi.&quot;, 4) == 0)
        s_service_internal (self, service_frame, msg);
    else
        s_service_dispatch (self, service, msg);
    zframe_destroy (&amp;service_frame);
}
</code></pre>
<p>这个例子应该是我们见过最复杂的一个示例了，大约有500行代码。编写这段代码并让其变的健壮，大约花费了两天的时间。但是，这也仅仅是一个完整的面向服务代理的一部分。</p>
<p>几点说明：</p>
<ul>
<li><p>管家模式协议要求我们在一个套接字中同时处理client和worker，这一点对部署和管理代理很有益处：它只会在一个ZMQ端点上收发请求，而不是两个。</p>
</li>
<li><p>代理很好地实现了MDP/0.1协议中规范的内容，包括当代理发送非法命令和心跳时断开的机制。</p>
</li>
<li><p>可以将这段代码扩充为多线程，每个线程管理一个套接字、一组client和worker。这种做法在大型架构的拆分中显得很有趣。C语言代码已经是这样的格式了，因此很容易实现。</p>
</li>
<li><p>还可以将这段代码扩充为主备模式、双在线模式，进一步提高可靠性。因为从本质上来说，代理是无状态的，只是保存了服务的存在与否，因此client和worker可以自行选择除此之外的代理来进行通信。</p>
</li>
<li><p>示例代码中心跳的间隔为5秒，主要是为了减少调试时的输出。现实中的值应该设得低一些，但是，重试的过程应该设置得稍长一些，让服务有足够的时间启动，如10秒钟。</p>
</li>
</ul>
<h3 id="异步管家模式"><a href="#异步管家模式" class="headerlink" title="异步管家模式"></a>异步管家模式</h3><p>上文那种实现管家模式的方法比较简单，client还是简单海盗模式中的，仅仅是用API重写了一下。我在测试机上运行了程序，处理10万条请求大约需要14秒的时间，这和代码也有一些关系，因为复制消息帧的时间浪费了CPU处理时间。但真正的问题在于，我们总是逐个循环进行处理（round-trip），即发送-接收-发送-接收……ZMQ内部禁用了TCP发包优化算法（<a href="http://en.wikipedia.org/wiki/Nagles_algorithm" target="_blank" rel="external">Nagle’s algorithm</a>），但逐个处理循环还是比较浪费。</p>
<p>理论归理论，还是需要由实践来检验。我们用一个简单的测试程序来看看逐个处理循环是否真的耗时。这个测试程序会发送一组消息，第一次它发一条收一条，第二次则一起发送再一起接收。两次结果应该是一样的，但速度截然不同。</p>
<p><strong>tripping: Round-trip demonstrator in C</strong></p>
<pre><code class="c">//
//  Round-trip 模拟
//
//  本示例程序使用多线程的方式启动client、worker、以及代理，
//  当client处理完毕时会发送信号给主程序。
//
#include &quot;czmq.h&quot;

static void
client_task (void *args, zctx_t *ctx, void *pipe)
{
    void *client = zsocket_new (ctx, ZMQ_DEALER);
    zmq_setsockopt (client, ZMQ_IDENTITY, &quot;C&quot;, 1);
    zsocket_connect (client, &quot;tcp://localhost:5555&quot;);

    printf (&quot;开始测试...\n&quot;);
    zclock_sleep (100);

    int requests;
    int64_t start;

    printf (&quot;同步 round-trip 测试...\n&quot;);
    start = zclock_time ();
    for (requests = 0; requests &lt; 10000; requests++) {
        zstr_send (client, &quot;hello&quot;);
        char *reply = zstr_recv (client);
        free (reply);
    }
    printf (&quot; %d 次/秒\n&quot;,
        (1000 * 10000) / (int) (zclock_time () - start));

    printf (&quot;异步 round-trip 测试...\n&quot;);
    start = zclock_time ();
    for (requests = 0; requests &lt; 100000; requests++)
        zstr_send (client, &quot;hello&quot;);
    for (requests = 0; requests &lt; 100000; requests++) {
        char *reply = zstr_recv (client);
        free (reply);
    }
    printf (&quot; %d 次/秒\n&quot;,
        (1000 * 100000) / (int) (zclock_time () - start));

    zstr_send (pipe, &quot;完成&quot;);
}

static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zmq_setsockopt (worker, ZMQ_IDENTITY, &quot;W&quot;, 1);
    zsocket_connect (worker, &quot;tcp://localhost:5556&quot;);

    while (1) {
        zmsg_t *msg = zmsg_recv (worker);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

static void *
broker_task (void *args)
{
    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, &quot;tcp://*:5555&quot;);
    zsocket_bind (backend,  &quot;tcp://*:5556&quot;);

    //  初始化轮询对象
    zmq_pollitem_t items [] = {
        { frontend, 0, ZMQ_POLLIN, 0 },
        { backend,  0, ZMQ_POLLIN, 0 }
    };
    while (1) {
        int rc = zmq_poll (items, 2, -1);
        if (rc == -1)
            break;              //  中断
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (frontend);
            zframe_t *address = zmsg_pop (msg);
            zframe_destroy (&amp;address);
            zmsg_pushstr (msg, &quot;W&quot;);
            zmsg_send (&amp;msg, backend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (backend);
            zframe_t *address = zmsg_pop (msg);
            zframe_destroy (&amp;address);
            zmsg_pushstr (msg, &quot;C&quot;);
            zmsg_send (&amp;msg, frontend);
        }
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

int main (void)
{
    //  创建线程
    zctx_t *ctx = zctx_new ();
    void *client = zthread_fork (ctx, client_task, NULL);
    zthread_new (ctx, worker_task, NULL);
    zthread_new (ctx, broker_task, NULL);

    //  等待client端管道的信号
    char *signal = zstr_recv (client);
    free (signal);

    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>在我的开发环境中运行结果如下：</p>
<pre><code>Setting up test...
Synchronous round-trip test...
 9057 calls/second
Asynchronous round-trip test...
 173010 calls/second
</code></pre><p>需要注意的是client在运行开始会暂停一段时间，这是因为在向ROUTER套接字发送消息时，若指定标识的套接字没有连接，那么ROUTER会直接丢弃该消息。这个示例中我们没有使用LRU算法，所以当worker连接速度稍慢时就有可能丢失数据，影响测试结果。</p>
<p>我们可以看到，逐个处理循环比异步处理要慢将近20倍，让我们把它应用到管家模式中去。</p>
<p>首先，让我们修改client的API，添加独立的发送和接收方法：</p>
<pre><code>mdcli_t *mdcli_new     (char *broker);
void     mdcli_destroy (mdcli_t **self_p);
int      mdcli_send    (mdcli_t *self, char *service, zmsg_t **request_p);
zmsg_t  *mdcli_recv    (mdcli_t *self);
</code></pre><p>然后花很短的时间就能将同步的client API改造成异步的API：</p>
<p><strong>mdcliapi2: Majordomo asynchronous client API in C</strong></p>
<pre><code class="c">/*  =====================================================================
    mdcliapi2.c

    Majordomo Protocol Client API (async version)
    Implements the MDP/Worker spec at http://rfc.zeromq.org/spec:7.

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;mdcliapi2.h&quot;

//  类结构
//  使用成员函数访问属性

struct _mdcli_t {
    zctx_t *ctx;                //  上下文
    char *broker;
    void *client;               //  连接至代理的套接字
    int verbose;                //  在标准输出打印运行状态
    int timeout;                //  请求超时时间
};


//  ---------------------------------------------------------------------
//  连接或重连代理

void s_mdcli_connect_to_broker (mdcli_t *self)
{
    if (self-&gt;client)
        zsocket_destroy (self-&gt;ctx, self-&gt;client);
    self-&gt;client = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    zmq_connect (self-&gt;client, self-&gt;broker);
    if (self-&gt;verbose)
        zclock_log (&quot;I: 正在连接代理 %s...&quot;, self-&gt;broker);
}


//  ---------------------------------------------------------------------
//  构造函数

mdcli_t *
mdcli_new (char *broker, int verbose)
{
    assert (broker);

    mdcli_t *self = (mdcli_t *) zmalloc (sizeof (mdcli_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;broker = strdup (broker);
    self-&gt;verbose = verbose;
    self-&gt;timeout = 2500;           //  毫秒

    s_mdcli_connect_to_broker (self);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

void
mdcli_destroy (mdcli_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        mdcli_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self-&gt;broker);
        free (self);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  设置请求超时时间

void
mdcli_set_timeout (mdcli_t *self, int timeout)
{
    assert (self);
    self-&gt;timeout = timeout;
}


//  ---------------------------------------------------------------------
//  发送请求给代理
//  取得请求消息的所有权，发送后销毁

int
mdcli_send (mdcli_t *self, char *service, zmsg_t **request_p)
{
    assert (self);
    assert (request_p);
    zmsg_t *request = *request_p;

    //  在消息顶部加入协议规定的帧
    //  Frame 0: empty (模拟REQ套接字的行为)
    //  Frame 1: &quot;MDPCxy&quot; (6个字节, MDP/Client x.y)
    //  Frame 2: Service name (看打印字符串)
    zmsg_pushstr (request, service);
    zmsg_pushstr (request, MDPC_CLIENT);
    zmsg_pushstr (request, &quot;&quot;);
    if (self-&gt;verbose) {
        zclock_log (&quot;I: 发送请求给 &#39;%s&#39; 服务:&quot;, service);
        zmsg_dump (request);
    }
    zmsg_send (&amp;request, self-&gt;client);
    return 0;
}


//  ---------------------------------------------------------------------
//  获取应答消息，若无则返回NULL；
//  该函数不会尝试从代理的崩溃中恢复，
//  因为我们没有记录那些未收到应答的请求，所以也无法重发。

zmsg_t *
mdcli_recv (mdcli_t *self)
{
    assert (self);

    //  轮询套接字以获取应答
    zmq_pollitem_t items [] = { { self-&gt;client, 0, ZMQ_POLLIN, 0 } };
    int rc = zmq_poll (items, 1, self-&gt;timeout * ZMQ_POLL_MSEC);
    if (rc == -1)
        return NULL;            //  中断

    //  收到应答后进行处理
    if (items [0].revents &amp; ZMQ_POLLIN) {
        zmsg_t *msg = zmsg_recv (self-&gt;client);
        if (self-&gt;verbose) {
            zclock_log (&quot;I: received reply:&quot;);
            zmsg_dump (msg);
        }
        //  不要处理错误，直接报出
        assert (zmsg_size (msg) &gt;= 4);

        zframe_t *empty = zmsg_pop (msg);
        assert (zframe_streq (empty, &quot;&quot;));
        zframe_destroy (&amp;empty);

        zframe_t *header = zmsg_pop (msg);
        assert (zframe_streq (header, MDPC_CLIENT));
        zframe_destroy (&amp;header);

        zframe_t *service = zmsg_pop (msg);
        zframe_destroy (&amp;service);

        return msg;     //  Success
    }
    if (zctx_interrupted)
        printf (&quot;W: 收到中断消息，正在中止client...\n&quot;);
    else
    if (self-&gt;verbose)
        zclock_log (&quot;W: 严重错误，放弃请求&quot;);

    return NULL;
}
</code></pre>
<p>下面是对应的测试代码：</p>
<p><strong>mdclient2: Majordomo client application in C</strong></p>
<pre><code>//
//  异步管家模式 - client示例程序
//  使用mdcli API隐藏MDP协议的具体实现
//
//  直接编译源码，而不创建类库
#include &quot;mdcliapi2.c&quot;

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);

    int count;
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *request = zmsg_new ();
        zmsg_pushstr (request, &quot;Hello world&quot;);
        mdcli_send (session, &quot;echo&quot;, &amp;request);
    }
    for (count = 0; count &lt; 100000; count++) {
        zmsg_t *reply = mdcli_recv (session);
        if (reply)
            zmsg_destroy (&amp;reply);
        else
            break;              //  使用Ctrl-C中断
    }
    printf (&quot;收到 %d 个应答\n&quot;, count);
    mdcli_destroy (&amp;session);
    return 0;
}
</code></pre><p>代理和worker的代码没有变，因为我们并没有改变MDP协议。经过对client的改造，我们可以明显看到速度的提升。如以下是同步状况下处理10万条请求的时间：</p>
<pre><code>$ time mdclient
100000 requests/replies processed

real    0m14.088s
user    0m1.310s
sys     0m2.670s
</code></pre><p>以下是异步请求的情况：</p>
<pre><code>$ time mdclient2
100000 replies received

real    0m8.730s
user    0m0.920s
sys     0m1.550s
</code></pre><p>让我们建立10个worker，看看效果如何：</p>
<pre><code>$ time mdclient2
100000 replies received

real    0m3.863s
user    0m0.730s
sys     0m0.470s
</code></pre><p>由于worker获得消息需要通过LRU队列机制，所以并不能做到完全的异步。但是，worker越多其效果也会越好。在我的测试机上，当worker的数量达到8个时，速度就不再提升了——四核处理器只能做这么多。但是，我们仍然获得了近四倍的速度提升，而改造过程只有几分钟而已。此外，代理其实还没有进行优化，它仍会复制消息，而没有实现零拷贝。不过，我们已经做到每秒处理2.5万次请求-应答，已经很不错了。</p>
<p>当然，异步的管家模式也并不完美，有一个显著的缺点：它无法从代理的崩溃中恢复。可以看到mdcliapi2的代码中并没有恢复连接的代码，重新连接需要有以下几点作为前提：</p>
<ul>
<li>每个请求都做了编号，每次应答也含有相应的编号，这就需要修改协议，明确定义；</li>
<li>client的API需要保留并跟踪所有已发送、但仍未收到应答的请求；</li>
<li>如果代理发生崩溃，client会重发所有消息。</li>
</ul>
<p>可以看到，高可靠性往往和复杂度成正比，值得在管家模式中应用这一机制吗？这就要看应用场景了。如果是一个名称查询服务，每次会话会调用一次，那不需要应用这一机制；如果是一个位于前端的网页服务，有数千个客户端相连，那可能就需要了。</p>
<h3 id="服务查询"><a href="#服务查询" class="headerlink" title="服务查询"></a>服务查询</h3><p>现在，我们已经有了一个面向服务的代理了，但是我们无法得知代理是否提供了某项特定服务。如果请求失败，那当然就表示该项服务目前不可用，但具体原因是什么呢？所以，如果能够询问代理“echo服务正在运行吗？”，那将会很有用处。最明显的方法是在MDP/Client协议中添加一种命令，客户端可以询问代理某项服务是否可用。但是，MDP/Client最大的优点在于简单，如果添加了服务查询的功能就太过复杂了。</p>
<p>另一种方案是学电子邮件的处理方式，将失败的请求重新返回。但是这同样会增加复杂度，因为我们需要鉴别收到的消息是一个应答还是被退回的请求。</p>
<p>让我们用之前的方式，在MDP的基础上建立新的机制，而不是改变它。服务定位本身也是一项服务，我们还可以提供类似于“禁用某服务”、“提供服务数据”等其他服务。我们需要的是一个能够扩展协议但又不会影响协议本身的机制。</p>
<p>这样就诞生了一个小巧的RFC - MMI（管家接口）的应用层，建立在MDP协议之上：<a href="http://rfc.zeromq.org/spec:8" target="_blank" rel="external">http://rfc.zeromq.org/spec:8</a> 。我们在代理中其实已经加以实现了，不知你是否已经注意到。下面的代码演示了如何使用这项服务查询功能：</p>
<p><strong>mmiecho: Service discovery over Majordomo in C</strong></p>
<pre><code class="c">//
//  MMI echo 服务查询示例程序
//

//  让我们直接编译，不生成类库
#include &quot;mdcliapi.c&quot;

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);

    //  我们需要查询的服务名称
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, &quot;echo&quot;);

    //  发送给“服务查询”服务的消息
    zmsg_t *reply = mdcli_send (session, &quot;mmi.service&quot;, &amp;request);

    if (reply) {
        char *reply_code = zframe_strdup (zmsg_first (reply));
        printf (&quot;查询 echo 服务的结果: %s\n&quot;, reply_code);
        free (reply_code);
        zmsg_destroy (&amp;reply);
    }
    else
        printf (&quot;E: 代理无响应，请确认它正在工作\n&quot;);

    mdcli_destroy (&amp;session);
    return 0;
}
</code></pre>
<p>代理在运行时会检查请求的服务名称，自行处理那些mmi.开头的服务，而不转发给worker。你可以在不开启worker的情况下运行以上代码，可以看到程序是报告200还是404。MMI在示例程序代理中的实现是很简单的，比如，当某个worker消亡时，该服务仍然标记为可用。实践中，代理应该在一定间隔后清除那些没有worker的服务。</p>
<h3 id="幂等服务"><a href="#幂等服务" class="headerlink" title="幂等服务"></a>幂等服务</h3><p>幂等是指能够安全地重复执行某项操作。如，看钟是幂等的，但借钱给别人老婆就不是了。有些客户端至服务端的通信是幂等的，但有些则不是。幂等的通信示例有：</p>
<ul>
<li>无状态的任务分配，即管道模式中服务端是无状态的worker，它的处理结果是根据客户端的请求状态生成的，因此可以重复处理相同的请求；</li>
<li>命名服务中将逻辑地址转化成实际绑定或连接的端点，可以重复查询多次，因此也是幂等的。</li>
</ul>
<p>非幂等的通信示例有：</p>
<ul>
<li>日志服务，我们不会希望相同的日志内容被记录多次；</li>
<li>任何会对下游节点有影响的服务，如该服务会向下游节点发送信息，若收到相同的请求，那下游节点收到的信息就是重复的；</li>
<li>当服务修改了某些共享的数据，且没有进行幂等方面的设置。如某项服务对银行账户进行了借操作（debit），这一定是非幂等的。</li>
</ul>
<p>如果应用程序提供的服务是非幂等的，那就需要考虑它究竟是在哪个阶段崩溃的。如果程序在空闲或处理请求的过程中崩溃，那不会有什么问题。我们可以使用数据库中的事务机制来保证借贷操作是同时发生的。如果应用程序在发送请求的时候崩溃了，那就会有问题，因为对于该程序来说，它已经完成了工作。</p>
<p>如果在返回应答的过程中网络阻塞了，客户端会认为请求发送失败，并进行重发，这样服务端会再一次执行相同的请求。这不是我们想要的结果。</p>
<p>常用的解决方法是在服务端检测并拒绝重复的请求，这就需要：</p>
<ul>
<li>客户端为每个请求加注唯一的标识，包括客户端标识和消息标识；</li>
<li>服务端在发送应答时使用客户端标识和消息标识作为键，保存应答内容；</li>
<li>当服务端发现收到的请求已在应答哈希表中存在，它会跳过该次请求，直接返回应答内容。</li>
</ul>
<h3 id="脱机可靠性（巨人模式）"><a href="#脱机可靠性（巨人模式）" class="headerlink" title="脱机可靠性（巨人模式）"></a>脱机可靠性（巨人模式）</h3><p>当你意识到管家模式是一种非常可靠的消息代理时，你可能会想要使用磁盘做一下消息中转，从而进一步提升可靠性。这种方式虽然在很多企业级消息系统中应用，但我还是有些反对的，原因有：</p>
<ul>
<li><p>我们可以看到，懒惰海盗模式的client可以工作得非常好，能够在多种架构中运行。唯一的问题是它会假设worker是无状态的，且提供的服务是幂等的。但这个问题我们可以通过其他方式解决，而不是添加磁盘。</p>
</li>
<li><p>添加磁盘会带来新的问题，需要额外的管理和维护费用。海盗模式的最大优点就是简单明了，不会崩溃。如果你还是担心硬件会出问题，可以改用点对点的通信模式，这会在本章最后一节讲到。</p>
</li>
</ul>
<p>虽然有以上原因，但还是有一个合理的场景可以用到磁盘中转的——异步脱机网络。海盗模式有一个问题，那就是client发送请求后会一直等待应答。如果client和worker并不是长连接（可以拿电子邮箱做个类比），我们就无法在client和worker之间建立一个无状态的网络，因此需要将这种状态保存起来。</p>
<p>于是我们就有了巨人模式，该模式下会将消息写到磁盘中，确保不会丢失。当我们进行服务查询时，会转向巨人这一层进行。巨人是建立在管家之上的，而不是改写了MDP协议。这样做的好处是我们可以在一个特定的worker中实现这种可靠性，而不用去增加代理的逻辑。</p>
<ul>
<li>实现更为简单；<ul>
<li>代理用一种语言编写，worker使用另一种语言编写；</li>
<li>可以自由升级这种模式。</li>
</ul>
</li>
</ul>
<p>唯一的缺点是，代理和磁盘之间会有一层额外的联系，不过这也是值得的。</p>
<p>我们有很多方法来实现一种持久化的请求-应答架构，而目标当然是越简单越好。我能想到的最简单的方式是提供一种成为“巨人”的代理服务，它不会影响现有worker的工作，若client想要立即得到应答，它可以和代理进行通信；如果它不是那么着急，那就可以和巨人通信：“嗨，巨人，麻烦帮我处理下这个请求，我去买些菜。”</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_5.png" alt="5"></p>
<p>这样一来，巨人就既是worker又是client。client和巨人之间的对话一般是：</p>
<ul>
<li>Client: 请帮我处理这个请求。巨人：好的。</li>
<li>Client: 有要给我的应答吗？巨人：有的。（或者没有）</li>
<li>Client: OK，你可以释放那个请求了，工作已经完成。巨人：好的。</li>
</ul>
<p>巨人和代理之间的对话一般是：</p>
<ul>
<li>巨人：嗨，代理程序，你这里有个叫echo的服务吗？代理：恩，好像有。</li>
<li>巨人：嗨，echo服务，请帮我处理一下这个请求。Echo: 好了，这是应答。</li>
<li>巨人：谢谢！</li>
</ul>
<p>你可以想象一些发生故障的情形，看看上述模式是否能解决？worker在处理请求的时候崩溃，巨人会不断地重新发送请求；应答在传输过程中丢失了，巨人也会重试；如果请求已经处理，但client没有得到应答，那它会再次询问巨人；如果巨人在处理请求或进行应答的时候崩溃了，客户端会进行重试；只要请求是被保存在磁盘上的，那它就不会丢失。</p>
<p>这个机制中，握手的过程是比较漫长的，但client可以使用异步的管家模式，一次发送多个请求，并一起等待应答。</p>
<p>我们需要一种方法，让client会去请求应答内容。不同的client会访问到相同的服务，且client是来去自由的，有着不同的标识。一个简单、合理、安全的解决方案是：</p>
<ul>
<li>当巨人收到请求时，它会为每个请求生成唯一的编号（UUID），并将这个编号返回给client；</li>
<li>client在请求应答内容时需要提供这个编号。</li>
</ul>
<p>这样一来client就需要负责将UUID安全地保存起来，不过这就省去了验证的过程。有其他方案吗？我们可以使用持久化的套接字，即显式声明客户端的套接字标识。然而，这会造成管理上的麻烦，而且万一两个client的套接字标识相同，那会引来无穷的麻烦。</p>
<p>在我们开始制定一个新的协议之前，我们先思考一下client如何和巨人通信。一种方案是提供一种服务，配合三个不同的命令；另一种方案则更为简单，提供三种独立的服务：</p>
<ul>
<li><strong>titanic.request</strong> - 保存一个请求，并返回UUID</li>
<li><strong>titanic.reply</strong> - 根据UUID获取应答内容</li>
<li><strong>titanic.close</strong> - 确认某个请求已被正确地处理</li>
</ul>
<p>我们需要创建一个多线程的worker，正如我们之前用ZMQ进行多线程编程一样，很简单。但是，在我们开始编写代码之前，先讲巨人模式的一些定义写下来：<a href="http://rfc.zeromq.org/spec:9" target="_blank" rel="external">http://rfc.zeromq.org/spec:9</a> 。我们称之为“巨人服务协议”，或TSP。</p>
<p>使用TSP协议自然会让client多出额外的工作，下面是一个简单但足够健壮的client：</p>
<p><strong>ticlient: Titanic client example in C</strong></p>
<pre><code class="c">//
//  巨人模式client示例
//  实现 http://rfc.zeromq.org/spec:9 协议中的client端

//  让我们直接编译，不创建类库
#include &quot;mdcliapi.c&quot;

//  请求TSP协议下的服务
//  如果成功则返回应答（状态码：200），否则返回NULL
//
static zmsg_t *
s_service_call (mdcli_t *session, char *service, zmsg_t **request_p)
{
    zmsg_t *reply = mdcli_send (session, service, request_p);
    if (reply) {
        zframe_t *status = zmsg_pop (reply);
        if (zframe_streq (status, &quot;200&quot;)) {
            zframe_destroy (&amp;status);
            return reply;
        }
        else
        if (zframe_streq (status, &quot;400&quot;)) {
            printf (&quot;E: 客户端发生严重错误，取消请求\n&quot;);
            exit (EXIT_FAILURE);
        }
        else
        if (zframe_streq (status, &quot;500&quot;)) {
            printf (&quot;E: 服务端发生严重错误，取消请求\n&quot;);
            exit (EXIT_FAILURE);
        }
    }
    else
        exit (EXIT_SUCCESS);    //  中断或发生错误

    zmsg_destroy (&amp;reply);
    return NULL;        //  请求不成功，但不返回失败原因
}

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    mdcli_t *session = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);

    //  1. 发送echo服务的请求给巨人
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, &quot;echo&quot;);
    zmsg_addstr (request, &quot;Hello world&quot;);
    zmsg_t *reply = s_service_call (
        session, &quot;titanic.request&quot;, &amp;request);

    zframe_t *uuid = NULL;
    if (reply) {
        uuid = zmsg_pop (reply);
        zmsg_destroy (&amp;reply);
        zframe_print (uuid, &quot;I: request UUID &quot;);
    }

    //  2. 等待应答
    while (!zctx_interrupted) {
        zclock_sleep (100);
        request = zmsg_new ();
        zmsg_add (request, zframe_dup (uuid));
        zmsg_t *reply = s_service_call (
            session, &quot;titanic.reply&quot;, &amp;request);

        if (reply) {
            char *reply_string = zframe_strdup (zmsg_last (reply));
            printf (&quot;Reply: %s\n&quot;, reply_string);
            free (reply_string);
            zmsg_destroy (&amp;reply);

            //  3. 关闭请求
            request = zmsg_new ();
            zmsg_add (request, zframe_dup (uuid));
            reply = s_service_call (session, &quot;titanic.close&quot;, &amp;request);
            zmsg_destroy (&amp;reply);
            break;
        }
        else {
            printf (&quot;I: 尚未收到应答，准备稍后重试...\n&quot;);
            zclock_sleep (5000);     //  5秒后重试
        }
    }
    zframe_destroy (&amp;uuid);
    mdcli_destroy (&amp;session);
    return 0;
}
</code></pre>
<p>当然，上面的代码可以整合到一个框架中，程序员不需要了解其中的细节。如果我有时间的话，我会尝试写一个这样的API的，让应用程序又变回短短的几行。这种理念和MDP中的一致：不要做重复的事。</p>
<p>下面是巨人的实现。这个服务端会使用三个线程来处理三种服务。它使用最原始的持久化方法来保存请求：为每个请求创建一个磁盘文件。虽然简单，但也挺恐怖的。比较复杂的部分是，巨人会维护一个队列来保存这些请求，从而避免重复地扫描目录。</p>
<p><strong>titanic: Titanic broker example in C</strong></p>
<pre><code class="c">//
//  巨人模式 - 服务
//
//  实现 http://rfc.zeromq.org/spec:9 协议的服务端

//  让我们直接编译，不创建类库
#include &quot;mdwrkapi.c&quot;
#include &quot;mdcliapi.c&quot;

#include &quot;zfile.h&quot;
#include &lt;uuid/uuid.h&gt;

//  返回一个可打印的唯一编号（UUID）
//  调用者负责释放UUID字符串的内存

static char *
s_generate_uuid (void)
{
    char hex_char [] = &quot;0123456789ABCDEF&quot;;
    char *uuidstr = zmalloc (sizeof (uuid_t) * 2 + 1);
    uuid_t uuid;
    uuid_generate (uuid);
    int byte_nbr;
    for (byte_nbr = 0; byte_nbr &lt; sizeof (uuid_t); byte_nbr++) {
        uuidstr [byte_nbr * 2 + 0] = hex_char [uuid [byte_nbr] &gt;&gt; 4];
        uuidstr [byte_nbr * 2 + 1] = hex_char [uuid [byte_nbr] &amp; 15];
    }
    return uuidstr;
}

//  根据UUID生成用于保存请求内容的文件名，并返回

#define TITANIC_DIR &quot;.titanic&quot;

static char *
s_request_filename (char *uuid) {
    char *filename = malloc (256);
    snprintf (filename, 256, TITANIC_DIR &quot;/%s.req&quot;, uuid);
    return filename;
}

//  根据UUID生成用于保存应答内容的文件名，并返回

static char *
s_reply_filename (char *uuid) {
    char *filename = malloc (256);
    snprintf (filename, 256, TITANIC_DIR &quot;/%s.rep&quot;, uuid);
    return filename;
}


//  ---------------------------------------------------------------------
//  巨人模式 - 请求服务

static void
titanic_request (void *args, zctx_t *ctx, void *pipe)
{
    mdwrk_t *worker = mdwrk_new (
        &quot;tcp://localhost:5555&quot;, &quot;titanic.request&quot;, 0);
    zmsg_t *reply = NULL;

    while (TRUE) {
        //  若应答非空则发送，再从代理处获得新的请求
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  中断并退出

        //  确保消息目录是存在的
        file_mkdir (TITANIC_DIR);

        //  生成UUID，并将消息保存至磁盘
        char *uuid = s_generate_uuid ();
        char *filename = s_request_filename (uuid);
        FILE *file = fopen (filename, &quot;w&quot;);
        assert (file);
        zmsg_save (request, file);
        fclose (file);
        free (filename);
        zmsg_destroy (&amp;request);

        //  将UUID加入队列
        reply = zmsg_new ();
        zmsg_addstr (reply, uuid);
        zmsg_send (&amp;reply, pipe);

        //  将UUID返回给客户端
        //  将由循环顶部的mdwrk_recv()函数完成
        reply = zmsg_new ();
        zmsg_addstr (reply, &quot;200&quot;);
        zmsg_addstr (reply, uuid);
        free (uuid);
    }
    mdwrk_destroy (&amp;worker);
}


//  ---------------------------------------------------------------------
//  巨人模式 - 应答服务

static void *
titanic_reply (void *context)
{
    mdwrk_t *worker = mdwrk_new (
        &quot;tcp://localhost:5555&quot;, &quot;titanic.reply&quot;, 0);
    zmsg_t *reply = NULL;

    while (TRUE) {
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  中断并退出

        char *uuid = zmsg_popstr (request);
        char *req_filename = s_request_filename (uuid);
        char *rep_filename = s_reply_filename (uuid);
        if (file_exists (rep_filename)) {
            FILE *file = fopen (rep_filename, &quot;r&quot;);
            assert (file);
            reply = zmsg_load (file);
            zmsg_pushstr (reply, &quot;200&quot;);
            fclose (file);
        }
        else {
            reply = zmsg_new ();
            if (file_exists (req_filename))
                zmsg_pushstr (reply, &quot;300&quot;); //挂起
            else
                zmsg_pushstr (reply, &quot;400&quot;); //未知
        }
        zmsg_destroy (&amp;request);
        free (uuid);
        free (req_filename);
        free (rep_filename);
    }
    mdwrk_destroy (&amp;worker);
    return 0;
}


//  ---------------------------------------------------------------------
//  巨人模式 - 关闭请求

static void *
titanic_close (void *context)
{
    mdwrk_t *worker = mdwrk_new (
        &quot;tcp://localhost:5555&quot;, &quot;titanic.close&quot;, 0);
    zmsg_t *reply = NULL;

    while (TRUE) {
        zmsg_t *request = mdwrk_recv (worker, &amp;reply);
        if (!request)
            break;      //  中断并退出

        char *uuid = zmsg_popstr (request);
        char *req_filename = s_request_filename (uuid);
        char *rep_filename = s_reply_filename (uuid);
        file_delete (req_filename);
        file_delete (rep_filename);
        free (uuid);
        free (req_filename);
        free (rep_filename);

        zmsg_destroy (&amp;request);
        reply = zmsg_new ();
        zmsg_addstr (reply, &quot;200&quot;);
    }
    mdwrk_destroy (&amp;worker);
    return 0;
}

//  处理某个请求，成功则返回1

static int
s_service_success (mdcli_t *client, char *uuid)
{
    //  读取请求内容，第一帧为服务名称
    char *filename = s_request_filename (uuid);
    FILE *file = fopen (filename, &quot;r&quot;);
    free (filename);

    //  如果client已经关闭了该请求，则返回1
    if (!file)
        return 1;

    zmsg_t *request = zmsg_load (file);
    fclose (file);
    zframe_t *service = zmsg_pop (request);
    char *service_name = zframe_strdup (service);

    //  使用MMI协议检查服务是否可用
    zmsg_t *mmi_request = zmsg_new ();
    zmsg_add (mmi_request, service);
    zmsg_t *mmi_reply = mdcli_send (client, &quot;mmi.service&quot;, &amp;mmi_request);
    int service_ok = (mmi_reply
        &amp;&amp; zframe_streq (zmsg_first (mmi_reply), &quot;200&quot;));
    zmsg_destroy (&amp;mmi_reply);

    if (service_ok) {
        zmsg_t *reply = mdcli_send (client, service_name, &amp;request);
        if (reply) {
            filename = s_reply_filename (uuid);
            FILE *file = fopen (filename, &quot;w&quot;);
            assert (file);
            zmsg_save (reply, file);
            fclose (file);
            free (filename);
            return 1;
        }
        zmsg_destroy (&amp;reply);
    }
    else
        zmsg_destroy (&amp;request);

    free (service_name);
    return 0;
}


int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));
    zctx_t *ctx = zctx_new ();

    //  创建MDP客户端会话
    mdcli_t *client = mdcli_new (&quot;tcp://localhost:5555&quot;, verbose);
    mdcli_set_timeout (client, 1000);  //  1 秒
    mdcli_set_retries (client, 1);     //  只尝试一次

    void *request_pipe = zthread_fork (ctx, titanic_request, NULL);
    zthread_new (ctx, titanic_reply, NULL);
    zthread_new (ctx, titanic_close, NULL);

    //  主循环
    while (TRUE) {
        //  如果没有活动，我们将每秒循环一次
        zmq_pollitem_t items [] = { { request_pipe, 0, ZMQ_POLLIN, 0 } };
        int rc = zmq_poll (items, 1, 1000 * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  确保消息目录是存在的
            file_mkdir (TITANIC_DIR);

            //  将UUID添加到队列中，使用“-”号标识等待中的请求
            zmsg_t *msg = zmsg_recv (request_pipe);
            if (!msg)
                break;          //  中断
            FILE *file = fopen (TITANIC_DIR &quot;/queue&quot;, &quot;a&quot;);
            char *uuid = zmsg_popstr (msg);
            fprintf (file, &quot;-%s\n&quot;, uuid);
            fclose (file);
            free (uuid);
            zmsg_destroy (&amp;msg);
        }
        //  分派
        //
        char entry [] = &quot;?.......:.......:.......:.......:&quot;;
        FILE *file = fopen (TITANIC_DIR &quot;/queue&quot;, &quot;r+&quot;);
        while (file &amp;&amp; fread (entry, 33, 1, file) == 1) {
            //  处理UUID前缀为“-”的请求
            if (entry [0] == &#39;-&#39;) {
                if (verbose)
                    printf (&quot;I: 开始处理请求 %s\n&quot;, entry + 1);
                if (s_service_success (client, entry + 1)) {
                    //  标记为已处理
                    fseek (file, -33, SEEK_CUR);
                    fwrite (&quot;+&quot;, 1, 1, file);
                    fseek (file, 32, SEEK_CUR);
                }
            }
            //  跳过最后一行
            if (fgetc (file) == &#39;\r&#39;)
                fgetc (file);
            if (zctx_interrupted)
                break;
        }
        if (file)
            fclose (file);
    }
    mdcli_destroy (&amp;client);
    return 0;
}
</code></pre>
<p>测试时，打开mdbroker和titanic，再运行ticlient，然后开启任意个mdworker，就可以看到client获得了应答。</p>
<p>几点说明：</p>
<ul>
<li>我们使用MMI协议去向代理询问某项服务是否可用，这一点和MDP中的逻辑一致；</li>
<li>我们使用inproc（进程内）协议建立主循环和titanic.request服务间的联系，保存新的请求信息。这样可以避免主循环不断扫描磁盘目录，读取所有请求文件，并按照时间日期排序。</li>
</ul>
<p>这个示例程序不应关注它的性能（一定会非常糟糕，虽然我没有测试过），而是应该看到它是如何提供一种可靠的通信模式的。你可以测试一下，打开代理、巨人、worker和client，使用-v参数显示跟踪信息，然后随意地开关代理、巨人、或worker（client不能关闭），可以看到所有的请求都能获得应答。</p>
<p>如果你想在真实环境中使用巨人模式，你肯定会问怎样才能让速度快起来。以下是我的做法：</p>
<ul>
<li>使用一个磁盘文件保存所有数据。操作系统处理大文件的效率要比处理许多小文件来的高。</li>
<li>使用一种循环的机制来组织该磁盘文件的结构，这样新的请求可以被连续地写入这个文件。单个线程在全速写入磁盘时的效率是比较高的。</li>
<li>将索引保存在内存中，可以在启动程序时重建这个索引。这样做可以节省磁盘缓存，让索引安全地保存在磁盘上。你需要用到fsync的机制来保存每一条数据；或者可以等待几毫秒，如果不怕丢失上千条数据的话。</li>
<li>如果条件允许，应选择使用固态硬盘；</li>
<li>提前分配该磁盘文件的空间，或者将每次分配的空间调大一些，这样可以避免磁盘碎片的产生，并保证读写是连续的。</li>
</ul>
<p>另外，我不建议将消息保存在数据库中，甚至不建议交给那些所谓的高速键值缓存，它们比起一个磁盘文件要来得昂贵。</p>
<p>如果你想让巨人模式变得更为可靠，你可以将请求复制到另一台服务器上，这样就不需要担心主程序遭到核武器袭击了。</p>
<p>如果你想让巨人模式变得更为快速，但可以牺牲一些可靠性，那你可以将请求和应答都保存在内存中。这样做可以让该服务作为脱机网络运行，不过若巨人服务本身崩溃了，我也无能为力。</p>
<h3 id="高可靠对称节点（双子星模式）"><a href="#高可靠对称节点（双子星模式）" class="headerlink" title="高可靠对称节点（双子星模式）"></a>高可靠对称节点（双子星模式）</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>双子星模式是一对具有主从机制的高可靠节点。任一时间，某个节点会充当主机，接收所有客户端的请求；另一个则作为一种备机存在。两个节点会互相监控对方，当主机从网络中消失时，备机会替代主机的位置。</p>
<p>双子星模式由Pieter Hintjens和Martin Sustrik设计，应用在iMatix的<a href="http://www.openamq.org/" target="_blank" rel="external">OpenAMQ服务器</a>中。它的设计理念是：</p>
<ul>
<li>提供一种简明的高可靠性解决方案；</li>
<li>易于理解和使用；</li>
<li>能够进行可靠的故障切换。</li>
</ul>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_6.png" alt="6"></p>
<p>假设我们有一组双子星模式的服务器，以下是可能发生的故障：</p>
<ol>
<li>主机发生硬件故障（断电、失火等），应用程序发送后立刻使用备机进行连接；</li>
<li>主机的网络环境发生故障，可能某个路由器被雷击了，立刻使用备机；</li>
<li>主机上的服务被维护人员误杀，无法自动恢复。</li>
</ol>
<p>恢复步骤如下：</p>
<ol>
<li>维护人员排查主机故障；</li>
<li>将备机关闭，造成短时间的服务不可用；</li>
<li>待应用程序都连接到主机后，维护人员重启备机。</li>
</ol>
<p>恢复过程是人工进行的，惨痛的经验告诉我们自动恢复是很可怕的：</p>
<ul>
<li><p>故障的发生会造成10-30秒之间的服务暂停，如果这是一个真正的突发状况，那最好还是让主机暂停服务的好，因为立刻重启服务可能造成另一个10-30秒的暂停，不如让用户停止使用。</p>
</li>
<li><p>当有紧急状况发生时，可以在修复的过程中记录故障发生原因，而不是让系统自动恢复，管理员因此无法用其经验抵御下一次突发状况。</p>
</li>
<li><p>最后，如果自动恢复确实成功了，管理员将无从得知故障的发生原因，因而无法进行分析。</p>
</li>
</ul>
<p>双子星模式的故障恢复过程是：在修复了主机的问题后，将备机做关闭处理，稍后再重新开启：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_7.png" alt="7"></p>
<p>双子星模式的关闭过程有两种：</p>
<ol>
<li>先关闭备机，等待一段时间后再关闭主机；</li>
<li>同时关闭主机和备机，间隔时间不超过几秒。</li>
</ol>
<p>关闭时，间隔时间要比故障切换时间短，否则会导致应用程序失去连接、重新连接、并再次失去连接，导致用户投诉。</p>
<h4 id="详细要求"><a href="#详细要求" class="headerlink" title="详细要求"></a>详细要求</h4><p>双子星模式可以非常简单，但能工作得很出色。事实上，这里的实现方法已经历经三个版本了，之前的版本都过于复杂，想要做太多的事情，因而被我们抛弃。我们需要的只是最基本的功能，能够提供易理解、易开发、高可靠的解决方法就可以了。</p>
<p>以下是该架构的详细需求：</p>
<ul>
<li>需要用到双子星模式的故障是：系统遭受灾难性的打击，如硬件崩溃、火灾、意外等。对于其他常规的服务器故障，可以用更简单的方法。</li>
<li>故障恢复时间应该在60秒以内，理想情况下应该在10秒以内；</li>
<li>故障恢复(failover)应该是自动完成的，而系统还原(recover)则是由人工完成的。我们希望应用程序能够在发生故障时自动从主机切换到备机，但不希望在问题解决之前自动切换回主机，因为这很有可能让主机再次崩溃。</li>
<li>程序的逻辑应该尽量简单，易于使用，最好能封装在API中；</li>
<li>需要提供一个明确的指示，哪台主机正在提供服务，以避免“精神分裂”的症状，即两台服务器都认为自己是主机；</li>
<li>两台服务器的启动顺序不应该有限制；</li>
<li>启动或关闭主从机时不需要更改客户端的配置，但有可能会中断连接；</li>
<li>管理员需要能够同时监控两台机器；</li>
<li>两台机器之间必须有专用的高速网络连接，必须能使用特定IP进行路由。</li>
</ul>
<p>我们做如下架假设：</p>
<ul>
<li>单台备机能够提供足够的保障，不需要再进行其他备份机制；</li>
<li>主从机应该都能够提供完整的服务，承载相同的压力，不需要进行负载均衡；</li>
<li>预算中允许有这样一台长时间闲置的备机。</li>
</ul>
<p>双子星模式不会用到：</p>
<ul>
<li>多台备机，或在主从机之间进行负载均衡。该模式中的备机将一直处于空闲状态，只有主机发生问题时才会工作；</li>
<li>处理持久化的消息或事务。我们假设所连接的网络是不可靠的（或不可信的）。</li>
<li>自动搜索网络。双子星模式是手工配置的，他们知道对方的存在，应用程序则知道双子星的存在。</li>
<li>主从机之间状态的同步。所有服务端的状态必须能由应用程序进行重建。</li>
</ul>
<p>以下是双子星模式中的几个术语：</p>
<ul>
<li><strong>主机</strong> - 通常情况下作为master的机器；</li>
<li><strong>备机</strong> - 通常情况下作为slave的机器，只有当主机从网络中消失时，备机才会切换成master状态，接收所有的应用程序请求；</li>
<li><strong>master</strong> - 双子星模式中接收应用程序请求的机器；同一时刻只有一台master；</li>
<li><strong>slave</strong> - 当master消失时用以顶替的机器。</li>
</ul>
<p>配置双子星模式的步骤：</p>
<ol>
<li>让主机知道备机的位置；</li>
<li>让备机知道主机的位置；</li>
<li>调整故障恢复时间，两台机器的配置必须相同。</li>
</ol>
<p>比较重要的配置是应让两台机器间隔多久检查一次对方的状态，以及多长时间后采取行动。在我们的示例中，故障恢复时间设置为2000毫秒，超过这个时间备机就会代替主机的位置。但若你将主机的服务包裹在一个shell脚本中进行重启，就需要延长这个时间，否则备机可能在主机恢复连接的过程中转换成master。</p>
<p>要让客户端应用程序和双子星模式配合，你需要做的是：</p>
<ol>
<li>知道两台服务器的地址；</li>
<li>尝试连接主机，若失败则连接备机；</li>
<li>检测失效的连接，一般使用心跳机制；</li>
<li>尝试重连主机，然后再连接备机，其间的间隔应比服务器故障恢复时间长；</li>
<li>重建服务器端需要的所有状态数据；</li>
<li>如果要保证可靠性，应重发故障期间的消息。</li>
</ol>
<p>这不是件容易的事，所以我们一般会将其封装成一个API，供程序员使用。</p>
<p>双子星模式的主要限制有：</p>
<ul>
<li>服务端进程不能涉及到一个以上的双子星对称节点；</li>
<li>主机只能有一个备机；</li>
<li>当备机处于slave状态时，它不会处理任何请求；</li>
<li>备机必须能够承受所有的应用程序请求；</li>
<li>故障恢复时间不能在运行时调整；</li>
<li>客户端应用程序需要做一些重连的工作。</li>
</ul>
<h4 id="防止精神分裂"><a href="#防止精神分裂" class="headerlink" title="防止精神分裂"></a>防止精神分裂</h4><p>“精神分裂”症状指的是一个集群中的不同部分同时认为自己是master，从而停止对对方的检测。双子星模式中的算法会降低这种症状的发生几率：主备机在决定自己是否为master时会检测自身是否收到了应用程序的请求，以及对方是否已经从网络中消失。</p>
<p>但在某些情况下，双子星模式也会发生精神分裂。比如说，主备机被配置在两幢大楼里，每幢大楼的局域网中又分布了一些应用程序。这样，当两幢大楼的网络通信被阻断，双子星模式的主备机就会分别在两幢大楼里接受和处理请求。</p>
<p>为了防止精神分裂，我们必须让主备机使用专用的网络进行连接，最简单的方法当然是用一根双绞线将他们相连。</p>
<p>我们不能将双子星部署在两个不同的岛屿上，为各自岛屿的应用程序服务。这种情况下，我们会使用诸如联邦模式的机制进行可靠性设计。</p>
<p>最好但最夸张的做法是，将两台机器之间的连接和应用程序的连接完全隔离开来，甚至是使用不同的网卡，而不仅仅是不同的端口。这样做也是为了日后排查错误时更为明确。</p>
<h4 id="实现双子星模式"><a href="#实现双子星模式" class="headerlink" title="实现双子星模式"></a>实现双子星模式</h4><p>闲话少说，下面是双子星模式的服务端代码：</p>
<p><strong>bstarsrv: Binary Star server in C</strong></p>
<pre><code class="c">//
//  双子星模式 - 服务端
//
#include &quot;czmq.h&quot;

//  发送状态信息的间隔时间
//  如果对方在两次心跳过后都没有应答，则视为断开
#define HEARTBEAT 1000          //  In msecs

//  服务器状态枚举
typedef enum {
    STATE_PRIMARY = 1,          //  主机，等待同伴连接
    STATE_BACKUP = 2,           //  备机，等待同伴连接
    STATE_ACTIVE = 3,           //  激活态，处理应用程序请求
    STATE_PASSIVE = 4           //  被动态，不接收请求
} state_t;

//  对话节点事件
typedef enum {
    PEER_PRIMARY = 1,           //  主机
    PEER_BACKUP = 2,            //  备机
    PEER_ACTIVE = 3,            //  激活态
    PEER_PASSIVE = 4,           //  被动态
    CLIENT_REQUEST = 5          //  客户端请求
} event_t;

//  有限状态机
typedef struct {
    state_t state;              //  当前状态
    event_t event;              //  当前事件
    int64_t peer_expiry;        //  判定节点死亡的时限
} bstar_t;


//  执行有限状态机（将事件绑定至状态）；
//  发生异常时返回TRUE。

static Bool
s_state_machine (bstar_t *fsm)
{
    Bool exception = FALSE;
    //  主机等待同伴连接
    //  该状态下接收CLIENT_REQUEST事件
    if (fsm-&gt;state == STATE_PRIMARY) {
        if (fsm-&gt;event == PEER_BACKUP) {
            printf (&quot;I: 已连接至备机（slave），可以作为master运行。\n&quot;);
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_ACTIVE) {
            printf (&quot;I: 已连接至备机（master），可以作为slave运行。\n&quot;);
            fsm-&gt;state = STATE_PASSIVE;
        }
    }
    else
    //  备机等待同伴连接
    //  该状态下拒绝CLIENT_REQUEST事件
    if (fsm-&gt;state == STATE_BACKUP) {
        if (fsm-&gt;event == PEER_ACTIVE) {
            printf (&quot;I: 已连接至主机（master），可以作为slave运行。\n&quot;);
            fsm-&gt;state = STATE_PASSIVE;
        }
        else
        if (fsm-&gt;event == CLIENT_REQUEST)
            exception = TRUE;
    }
    else
    //  服务器处于激活态
    //  该状态下接受CLIENT_REQUEST事件
    if (fsm-&gt;state == STATE_ACTIVE) {
        if (fsm-&gt;event == PEER_ACTIVE) {
            //  若出现两台master，则抛出异常
            printf (&quot;E: 严重错误：双master。正在退出。\n&quot;);
            exception = TRUE;
        }
    }
    else
    //  服务器处于被动态
    //  若同伴已死，CLIENT_REQUEST事件将触发故障恢复
    if (fsm-&gt;state == STATE_PASSIVE) {
        if (fsm-&gt;event == PEER_PRIMARY) {
            //  同伴正在重启 - 转为激活态，同伴将转为被动态。
            printf (&quot;I: 主机（slave）正在重启，可作为master运行。\n&quot;);
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_BACKUP) {
            //  同伴正在重启 - 转为激活态，同伴将转为被动态。
            printf (&quot;I: 备机（slave）正在重启，可作为master运行。\n&quot;);
            fsm-&gt;state = STATE_ACTIVE;
        }
        else
        if (fsm-&gt;event == PEER_PASSIVE) {
            //  若出现两台slave，集群将无响应
            printf (&quot;E: 严重错误：双slave。正在退出\n&quot;);
            exception = TRUE;
        }
        else
        if (fsm-&gt;event == CLIENT_REQUEST) {
            //  若心跳超时，同伴将成为master；
            //  此行为由客户端请求触发。
            assert (fsm-&gt;peer_expiry &gt; 0);
            if (zclock_time () &gt;= fsm-&gt;peer_expiry) {
                //  同伴已死，转为激活态。
                printf (&quot;I: 故障恢复，可作为master运行。\n&quot;);
                fsm-&gt;state = STATE_ACTIVE;
            }
            else
                //  同伴还在，拒绝请求。
                exception = TRUE;
        }
    }
    return exception;
}


int main (int argc, char *argv [])
{
    //  命令行参数可以为：
    //      -p  作为主机启动, at tcp://localhost:5001
    //      -b  作为备机启动, at tcp://localhost:5002
    zctx_t *ctx = zctx_new ();
    void *statepub = zsocket_new (ctx, ZMQ_PUB);
    void *statesub = zsocket_new (ctx, ZMQ_SUB);
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    bstar_t fsm = { 0 };

    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) {
        printf (&quot;I: 主机master，等待备机（slave）连接。\n&quot;);
        zsocket_bind (frontend, &quot;tcp://*:5001&quot;);
        zsocket_bind (statepub, &quot;tcp://*:5003&quot;);
        zsocket_connect (statesub, &quot;tcp://localhost:5004&quot;);
        fsm.state = STATE_PRIMARY;
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) {
        printf (&quot;I: 备机slave，等待主机（master）连接。\n&quot;);
        zsocket_bind (frontend, &quot;tcp://*:5002&quot;);
        zsocket_bind (statepub, &quot;tcp://*:5004&quot;);
        zsocket_connect (statesub, &quot;tcp://localhost:5003&quot;);
        fsm.state = STATE_BACKUP;
    }
    else {
        printf (&quot;Usage: bstarsrv { -p | -b }\n&quot;);
        zctx_destroy (&amp;ctx);
        exit (0);
    }
    //  设定下一次发送状态的时间
    int64_t send_state_at = zclock_time () + HEARTBEAT;

    while (!zctx_interrupted) {
        zmq_pollitem_t items [] = {
            { frontend, 0, ZMQ_POLLIN, 0 },
            { statesub, 0, ZMQ_POLLIN, 0 }
        };
        int time_left = (int) ((send_state_at - zclock_time ()));
        if (time_left &lt; 0)
            time_left = 0;
        int rc = zmq_poll (items, 2, time_left * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文对象被关闭

        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  收到客户端请求
            zmsg_t *msg = zmsg_recv (frontend);
            fsm.event = CLIENT_REQUEST;
            if (s_state_machine (&amp;fsm) == FALSE)
                //  返回应答
                zmsg_send (&amp;msg, frontend);
            else
                zmsg_destroy (&amp;msg);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  收到状态消息，作为事件处理
            char *message = zstr_recv (statesub);
            fsm.event = atoi (message);
            free (message);
            if (s_state_machine (&amp;fsm))
                break;          //  错误，退出。
            fsm.peer_expiry = zclock_time () + 2 * HEARTBEAT;
        }
        //  定时发送状态信息
        if (zclock_time () &gt;= send_state_at) {
            char message [2];
            sprintf (message, &quot;%d&quot;, fsm.state);
            zstr_send (statepub, message);
            send_state_at = zclock_time () + HEARTBEAT;
        }
    }
    if (zctx_interrupted)
        printf (&quot;W: 中断\n&quot;);

    //  关闭套接字和上下文
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>下面是客户端代码：</p>
<p><strong>bstarcli: Binary Star client in C</strong></p>
<pre><code class="c">//
//  双子星模式 - 客户端
//
#include &quot;czmq.h&quot;

#define REQUEST_TIMEOUT     1000    //  毫秒
#define SETTLE_DELAY        2000    //  超时时间

int main (void)
{
    zctx_t *ctx = zctx_new ();

    char *server [] = { &quot;tcp://localhost:5001&quot;, &quot;tcp://localhost:5002&quot; };
    uint server_nbr = 0;

    printf (&quot;I: 正在连接服务器 %s...\n&quot;, server [server_nbr]);
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, server [server_nbr]);

    int sequence = 0;
    while (!zctx_interrupted) {
        //  发送请求并等待应答
        char request [10];
        sprintf (request, &quot;%d&quot;, ++sequence);
        zstr_send (client, request);

        int expect_reply = 1;
        while (expect_reply) {
            //  轮询套接字
            zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  中断

            //  处理应答
            if (items [0].revents &amp; ZMQ_POLLIN) {
                //  审核应答编号
                char *reply = zstr_recv (client);
                if (atoi (reply) == sequence) {
                    printf (&quot;I: 服务端应答正常 (%s)\n&quot;, reply);
                    expect_reply = 0;
                    sleep (1);  //  每秒发送一个请求
                }
                else {
                    printf (&quot;E: 错误的应答内容: %s\n&quot;,
                        reply);
                }
                free (reply);
            }
            else {
                printf (&quot;W: 服务器无响应，正在重试\n&quot;);
                //  重开套接字
                zsocket_destroy (ctx, client);
                server_nbr = (server_nbr + 1) % 2;
                zclock_sleep (SETTLE_DELAY);
                printf (&quot;I: 正在连接服务端 %s...\n&quot;,
                        server [server_nbr]);
                client = zsocket_new (ctx, ZMQ_REQ);
                zsocket_connect (client, server [server_nbr]);

                //  使用新套接字重发请求
                zstr_send (client, request);
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>运行以下命令进行测试，顺序随意：</p>
<pre><code>bstarsrv -p     # Start primary
bstarsrv -b     # Start backup
bstarcli
</code></pre><p>可以将主机进程杀掉，测试故障恢复机制；再开启主机，杀掉备机，查看还原机制。要注意是由客户端触发这两个事件的。</p>
<p>下图展现了服务进程的状态图。绿色状态下会接收客户端请求，粉色状态会拒绝请求。事件指的是同伴的状态，所以“同伴激活态”指的是同伴机器告知我们它处于激活态。“客户请求”表示我们从客户端获得了请求，“客户投票”则指我们从客户端获得了请求并且同伴已经超时死亡。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_8.png" alt="8"></p>
<p>需要注意的是，服务进程使用PUB-SUB套接字进行状态交换，其它类型的套接字在这里不适用。比如，PUSH和DEALER套接字在没有节点相连的时候会发生阻塞；PAIR套接字不会在节点断开后进行重连；ROUTER套接字需要地址才能发送消息。</p>
<p>These are the main limitations of the Binary Star pattern:</p>
<ul>
<li>A server process cannot be part of more than one Binary Star pair.</li>
<li>A primary server can have a single backup server, no more.</li>
<li>The backup server cannot do useful work while in slave mode.</li>
<li>The backup server must be capable of handling full application loads.</li>
<li>Failover configuration cannot be modified at runtime.</li>
<li>Client applications must do some work to benefit from failover.</li>
</ul>
<h4 id="双子星反应堆"><a href="#双子星反应堆" class="headerlink" title="双子星反应堆"></a>双子星反应堆</h4><p>我们可以将双子星模式打包成一个类似反应堆的类，供以后复用。在C语言中，我们使用czmq的zloop类，其他语言应该会有相应的实现。以下是C语言版的bstar接口：</p>
<pre><code class="c">// 创建双子星模式实例，使用本地（绑定）和远程（连接）端点来设置节点对。
bstar_t *bstar_new (int primary, char *local, char *remote);

// 销毁实例
void bstar_destroy (bstar_t **self_p);

// 返回底层的zloop反应堆，用以添加定时器、读取器、注册和取消等功能。
zloop_t *bstar_zloop (bstar_t *self);

// 注册投票读取器
int bstar_voter (bstar_t *self, char *endpoint, int type,
zloop_fn handler, void *arg);

// 注册状态机处理器
void bstar_new_master (bstar_t *self, zloop_fn handler, void *arg);
void bstar_new_slave (bstar_t *self, zloop_fn handler, void *arg);

// 开启反应堆，当回调函数返回-1，或进程收到SIGINT、SIGTERM信号时中止。
int bstar_start (bstar_t *self);
</code></pre>
<p>以下是类的实现：</p>
<p><strong>bstar: Binary Star core class in C</strong></p>
<pre><code class="c">/*  =====================================================================
    bstar - Binary Star reactor

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;bstar.h&quot;

//  服务器状态枚举
typedef enum {
    STATE_PRIMARY = 1,          //  主机，等待同伴连接
    STATE_BACKUP = 2,           //  备机，等待同伴连接
    STATE_ACTIVE = 3,           //  激活态，处理应用程序请求
    STATE_PASSIVE = 4           //  被动态，不接收请求
} state_t;

//  对话节点事件
typedef enum {
    PEER_PRIMARY = 1,           //  主机
    PEER_BACKUP = 2,            //  备机
    PEER_ACTIVE = 3,            //  激活态
    PEER_PASSIVE = 4,           //  被动态
    CLIENT_REQUEST = 5          //  客户端请求
} event_t;


//  发送状态信息的间隔时间
//  如果对方在两次心跳过后都没有应答，则视为断开
#define BSTAR_HEARTBEAT     1000        //  In msecs

//  类结构

struct _bstar_t {
    zctx_t *ctx;                //  私有上下文
    zloop_t *loop;              //  反应堆循环
    void *statepub;             //  状态发布者
    void *statesub;             //  状态订阅者
    state_t state;              //  当前状态
    event_t event;              //  当前事件
    int64_t peer_expiry;        //  判定节点死亡的时限
    zloop_fn *voter_fn;         //  投票套接字处理器
    void *voter_arg;            //  投票处理程序的参数
    zloop_fn *master_fn;        //  成为master时回调
    void *master_arg;           //  参数
    zloop_fn *slave_fn;         //  成为slave时回调
    void *slave_arg;            //  参数
};


//  ---------------------------------------------------------------------
//  执行有限状态机（将事件绑定至状态）；
//  发生异常时返回-1，正确时返回0。

static int
s_execute_fsm (bstar_t *self)
{
    int rc = 0;
    //  主机等待同伴连接
    //  该状态下接收CLIENT_REQUEST事件
    if (self-&gt;state == STATE_PRIMARY) {
        if (self-&gt;event == PEER_BACKUP) {
            zclock_log (&quot;I: 已连接至备机（slave），可以作为master运行。&quot;);
            self-&gt;state = STATE_ACTIVE;
            if (self-&gt;master_fn)
                (self-&gt;master_fn) (self-&gt;loop, NULL, self-&gt;master_arg);
        }
        else
        if (self-&gt;event == PEER_ACTIVE) {
            zclock_log (&quot;I: 已连接至备机（master），可以作为slave运行。&quot;);
            self-&gt;state = STATE_PASSIVE;
            if (self-&gt;slave_fn)
                (self-&gt;slave_fn) (self-&gt;loop, NULL, self-&gt;slave_arg);
        }
        else
        if (self-&gt;event == CLIENT_REQUEST) {
            zclock_log (&quot;I: 收到客户端请求，可作为master运行。&quot;);
            self-&gt;state = STATE_ACTIVE;
            if (self-&gt;master_fn)
                (self-&gt;master_fn) (self-&gt;loop, NULL, self-&gt;master_arg);
        }
    }
    else
    //  备机等待同伴连接
    //  该状态下拒绝CLIENT_REQUEST事件
    if (self-&gt;state == STATE_BACKUP) {
        if (self-&gt;event == PEER_ACTIVE) {
            zclock_log (&quot;I: 已连接至主机（master），可以作为slave运行。&quot;);
            self-&gt;state = STATE_PASSIVE;
            if (self-&gt;slave_fn)
                (self-&gt;slave_fn) (self-&gt;loop, NULL, self-&gt;slave_arg);
        }
        else
        if (self-&gt;event == CLIENT_REQUEST)
            rc = -1;
    }
    else
    //  服务器处于激活态
    //  该状态下接受CLIENT_REQUEST事件
    //  只有服务器死亡才会离开激活态
    if (self-&gt;state == STATE_ACTIVE) {
        if (self-&gt;event == PEER_ACTIVE) {
            //  若出现两台master，则抛出异常
            zclock_log (&quot;E: 严重错误：双master。正在退出。&quot;);
            rc = -1;
        }
    }
    else
    //  服务器处于被动态
    //  若同伴已死，CLIENT_REQUEST事件将触发故障恢复
    if (self-&gt;state == STATE_PASSIVE) {
        if (self-&gt;event == PEER_PRIMARY) {
            //  同伴正在重启 - 转为激活态，同伴将转为被动态。
            zclock_log (&quot;I: 主机（slave）正在重启，可作为master运行。&quot;);
            self-&gt;state = STATE_ACTIVE;
        }
        else
        if (self-&gt;event == PEER_BACKUP) {
            //  同伴正在重启 - 转为激活态，同伴将转为被动态。
            zclock_log (&quot;I: 备机（slave）正在重启，可作为master运行。&quot;);
            self-&gt;state = STATE_ACTIVE;
        }
        else
        if (self-&gt;event == PEER_PASSIVE) {
            //  若出现两台slave，集群将无响应
            zclock_log (&quot;E: 严重错误：双slave。正在退出&quot;);
            rc = -1;
        }
        else
        if (self-&gt;event == CLIENT_REQUEST) {
            //  若心跳超时，同伴将成为master；
            //  此行为由客户端请求触发。
            assert (self-&gt;peer_expiry &gt; 0);
            if (zclock_time () &gt;= self-&gt;peer_expiry) {
                //  同伴已死，转为激活态。
                zclock_log (&quot;I: 故障恢复，可作为master运行。&quot;);
                self-&gt;state = STATE_ACTIVE;
            }
            else
                //  同伴还在，拒绝请求。
                rc = -1;
        }
        //  触发状态更改事件处理函数
        if (self-&gt;state == STATE_ACTIVE &amp;&amp; self-&gt;master_fn)
            (self-&gt;master_fn) (self-&gt;loop, NULL, self-&gt;master_arg);
    }
    return rc;
}


//  ---------------------------------------------------------------------
//  反应堆事件处理程序

//  发送状态信息
int s_send_state (zloop_t *loop, void *socket, void *arg)
{
    bstar_t *self = (bstar_t *) arg;
    zstr_sendf (self-&gt;statepub, &quot;%d&quot;, self-&gt;state);
    return 0;
}

//  接收状态信息，启动有限状态机
int s_recv_state (zloop_t *loop, void *socket, void *arg)
{
    bstar_t *self = (bstar_t *) arg;
    char *state = zstr_recv (socket);
    if (state) {
        self-&gt;event = atoi (state);
        self-&gt;peer_expiry = zclock_time () + 2 * BSTAR_HEARTBEAT;
        free (state);
    }
    return s_execute_fsm (self);
}

//  收到应用程序请求，判断是否接收
int s_voter_ready (zloop_t *loop, void *socket, void *arg)
{
    bstar_t *self = (bstar_t *) arg;
    //  如果能够处理请求，则调用函数
    self-&gt;event = CLIENT_REQUEST;
    if (s_execute_fsm (self) == 0) {
        puts (&quot;CLIENT REQUEST&quot;);
        (self-&gt;voter_fn) (self-&gt;loop, socket, self-&gt;voter_arg);
    }
    else {
        //  销毁等待中的消息
        zmsg_t *msg = zmsg_recv (socket);
        zmsg_destroy (&amp;msg);
    }
    return 0;
}


//  ---------------------------------------------------------------------
//  构造函数

bstar_t *
bstar_new (int primary, char *local, char *remote)
{
    bstar_t
        *self;

    self = (bstar_t *) zmalloc (sizeof (bstar_t));

    //  初始化双子星
    self-&gt;ctx = zctx_new ();
    self-&gt;loop = zloop_new ();
    self-&gt;state = primary? STATE_PRIMARY: STATE_BACKUP;

    //  创建状态PUB套接字
    self-&gt;statepub = zsocket_new (self-&gt;ctx, ZMQ_PUB);
    zsocket_bind (self-&gt;statepub, local);

    //  创建状态SUB套接字
    self-&gt;statesub = zsocket_new (self-&gt;ctx, ZMQ_SUB);
    zsocket_connect (self-&gt;statesub, remote);

    //  设置基本的反应堆事件处理器
    zloop_timer (self-&gt;loop, BSTAR_HEARTBEAT, 0, s_send_state, self);
    zloop_reader (self-&gt;loop, self-&gt;statesub, s_recv_state, self);
    return self;
}


//  ---------------------------------------------------------------------
//  析构函数

void
bstar_destroy (bstar_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        bstar_t *self = *self_p;
        zloop_destroy (&amp;self-&gt;loop);
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}


//  ---------------------------------------------------------------------
//  返回底层zloop对象，用以添加额外的定时器、阅读器等。

zloop_t *
bstar_zloop (bstar_t *self)
{
    return self-&gt;loop;
}


//  ---------------------------------------------------------------------
//  创建套接字，连接至本地端点，注册成为阅读器；
//  只有当有限状态机允许时才会读取该套接字；
//  从该套接字获得的消息将作为一次“投票”；
//  我们要求双子星模式中只有一个“投票”套接字。

int
bstar_voter (bstar_t *self, char *endpoint, int type, zloop_fn handler,
             void *arg)
{
    //  保存原始的回调函数和参数，稍后使用
    void *socket = zsocket_new (self-&gt;ctx, type);
    zsocket_bind (socket, endpoint);
    assert (!self-&gt;voter_fn);
    self-&gt;voter_fn = handler;
    self-&gt;voter_arg = arg;
    return zloop_reader (self-&gt;loop, socket, s_voter_ready, self);
}

//  ---------------------------------------------------------------------
//  注册状态变化事件处理器

void
bstar_new_master (bstar_t *self, zloop_fn handler, void *arg)
{
    assert (!self-&gt;master_fn);
    self-&gt;master_fn = handler;
    self-&gt;master_arg = arg;
}

void
bstar_new_slave (bstar_t *self, zloop_fn handler, void *arg)
{
    assert (!self-&gt;slave_fn);
    self-&gt;slave_fn = handler;
    self-&gt;slave_arg = arg;
}


//  ---------------------------------------------------------------------
//  启用或禁止跟踪信息
void bstar_set_verbose (bstar_t *self, Bool verbose)
{
    zloop_set_verbose (self-&gt;loop, verbose);
}


//  ---------------------------------------------------------------------
//  开启反应堆，当回调函数返回-1，或进程收到SIGINT、SIGTERM信号时中止。

int
bstar_start (bstar_t *self)
{
    assert (self-&gt;voter_fn);
    return zloop_start (self-&gt;loop);
}
</code></pre>
<p>这样一来，我们的服务端代码会变得非常简短：</p>
<p><strong>bstarsrv2: Binary Star server, using core class in C</strong></p>
<pre><code class="c">//
//  双子星模式服务端，使用bstar反应堆
//

//  直接编译，不建类库
#include &quot;bstar.c&quot;

//  Echo service
int s_echo (zloop_t *loop, void *socket, void *arg)
{
    zmsg_t *msg = zmsg_recv (socket);
    zmsg_send (&amp;msg, socket);
    return 0;
}

int main (int argc, char *argv [])
{
    //  命令行参数可以为：
    //      -p  作为主机启动, at tcp://localhost:5001
    //      -b  作为备机启动, at tcp://localhost:5002
    bstar_t *bstar;
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-p&quot;)) {
        printf (&quot;I: 主机master，等待备机（slave）连接。\n&quot;);
        bstar = bstar_new (BSTAR_PRIMARY,
            &quot;tcp://*:5003&quot;, &quot;tcp://localhost:5004&quot;);
        bstar_voter (bstar, &quot;tcp://*:5001&quot;, ZMQ_ROUTER, s_echo, NULL);
    }
    else
    if (argc == 2 &amp;&amp; streq (argv [1], &quot;-b&quot;)) {
        printf (&quot;I: 备机slave，等待主机（master）连接。\n&quot;);
        bstar = bstar_new (BSTAR_BACKUP,
            &quot;tcp://*:5004&quot;, &quot;tcp://localhost:5003&quot;);
        bstar_voter (bstar, &quot;tcp://*:5002&quot;, ZMQ_ROUTER, s_echo, NULL);
    }
    else {
        printf (&quot;Usage: bstarsrvs { -p | -b }\n&quot;);
        exit (0);
    }
    bstar_start (bstar);
    bstar_destroy (&amp;bstar);
    return 0;
}
</code></pre>
<h3 id="无中间件的可靠性（自由者模式）"><a href="#无中间件的可靠性（自由者模式）" class="headerlink" title="无中间件的可靠性（自由者模式）"></a>无中间件的可靠性（自由者模式）</h3><p>我们讲了那么多关于中间件的示例，好像有些违背“ZMQ是无中间件”的说法。但要知道在现实生活中，中间件一直是让人又爱又恨的东西。实践中的很多消息架构能都在使用中间件进行分布式架构的搭建，所以说最终的决定还是需要你自己去权衡的。这也是为什么虽然我能驾车10分钟到一个大型商场里购买五箱音量，但我还是会选择走10分钟到楼下的便利店里去买。这种出于经济方面的考虑（时间、精力、成本等）不仅在日常生活中很常见，在软件架构中也很重要。</p>
<p>这就是为什么ZMQ不会强制使用带有中间件的架构，但仍提供了像内置装置这样的中间件供编程人员自由选用。</p>
<p>这一节我们会打破以往使用中间件进行可靠性设计的架构，转而使用点对点架构，即自由者模式，来进行可靠的消息传输。我们的示例程序会是一个名称解析服务。ZMQ中的一个常见问题是：我们如何得知需要连接的端点？在代码中直接写入TCP/IP地址肯定是不合适的；使用配置文件会造成管理上的不便。试想一下，你要在上百台计算机中进行配置，只是为了让它们知道google.com的IP地址是74.125.230.82。</p>
<p>一个ZMQ的名称解析服务需要实现的功能有：</p>
<ul>
<li>将逻辑名称解析为一个或多个端点地址，包括绑定端和连接端。实际使用时，名称服务会提供一组端点。</li>
<li>允许我们在不同的环境下，即开发环境和生产环境，进行解析；</li>
<li>该服务必须是可靠的，否则应用程序将无法连接到网络。</li>
</ul>
<p>为管家模式提供名称解析服务会很有用，虽然将代理程序的端点对外暴露也很简单，但是如果用好名称解析服务，那它将成为唯一一个对外暴露的接口，将更便于管理。</p>
<p>我们需要处理的故障类型有：服务崩溃或重启、服务过载、网络因素等。为获取可靠性，我们必须建立一个服务群，当某个服务端崩溃后，客户端可以连接其他的服务端。实践中，两个服务端就已经足够了，但事实上服务端的数量可以是任意个。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter4_9.png" alt="9"></p>
<p>在这个架构中，大量客户端和少量服务端进行通信，服务端将套接字绑定至单独的端口，这和管家模式中的代理有很大不同。对于客户端来说，它有这样几种选择：</p>
<ul>
<li><p>客户端可以使用REQ套接字和懒惰海盗模式，但需要有一个机制防止客户端不断地请求已停止的服务端。</p>
</li>
<li><p>客户端可以使用DEALER套接字，向所有的服务端发送请求。很简单，但并不太妙；</p>
</li>
<li><p>客户端使用ROUTER套接字，连接特定的服务端。但客户端如何得知服务端的套接字标识呢？一种方式是让服务端主动连接客户端（很复杂），或者将服务端标识写入代码进行固化（很混乱）。</p>
</li>
</ul>
<h4 id="模型一：简单重试"><a href="#模型一：简单重试" class="headerlink" title="模型一：简单重试"></a>模型一：简单重试</h4><p>让我们先尝试简单的方案，重写懒惰海盗模式，让其能够和多个服务端进行通信。启动服务端时用命令行参数指定端口。然后启动多个服务端。</p>
<p><strong>flserver1: Freelance server, Model One in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 服务端 - 模型1
//  提供echo服务
//
#include &quot;czmq.h&quot;

int main (int argc, char *argv [])
{
    if (argc &lt; 2) {
        printf (&quot;I: syntax: %s &lt;endpoint&gt;\n&quot;, argv [0]);
        exit (EXIT_SUCCESS);
    }
    zctx_t *ctx = zctx_new ();
    void *server = zsocket_new (ctx, ZMQ_REP);
    zsocket_bind (server, argv [1]);

    printf (&quot;I: echo服务端点： %s\n&quot;, argv [1]);
    while (TRUE) {
        zmsg_t *msg = zmsg_recv (server);
        if (!msg)
            break;          //  中断
        zmsg_send (&amp;msg, server);
    }
    if (zctx_interrupted)
        printf (&quot;W: 中断\n&quot;);

    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>启动客户端，指定一个或多个端点：</p>
<p><strong>flclient1: Freelance client, Model One in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 客户端 - 模型1
//  使用REQ套接字请求一个或多个服务端
//
#include &quot;czmq.h&quot;

#define REQUEST_TIMEOUT     1000
#define MAX_RETRIES         3       //  尝试次数


static zmsg_t *
s_try_request (zctx_t *ctx, char *endpoint, zmsg_t *request)
{
    printf (&quot;I: 在端点 %s 上尝试请求echo服务...\n&quot;, endpoint);
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, endpoint);

    //  发送请求，并等待应答
    zmsg_t *msg = zmsg_dup (request);
    zmsg_send (&amp;msg, client);
    zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
    zmq_poll (items, 1, REQUEST_TIMEOUT * ZMQ_POLL_MSEC);
    zmsg_t *reply = NULL;
    if (items [0].revents &amp; ZMQ_POLLIN)
        reply = zmsg_recv (client);

    //  关闭套接字
    zsocket_destroy (ctx, client);
    return reply;
}


int main (int argc, char *argv [])
{
    zctx_t *ctx = zctx_new ();
    zmsg_t *request = zmsg_new ();
    zmsg_addstr (request, &quot;Hello world&quot;);
    zmsg_t *reply = NULL;

    int endpoints = argc - 1;
    if (endpoints == 0)
        printf (&quot;I: syntax: %s &lt;endpoint&gt; ...\n&quot;, argv [0]);
    else
    if (endpoints == 1) {
        //  若只有一个端点，则尝试N次
        int retries;
        for (retries = 0; retries &lt; MAX_RETRIES; retries++) {
            char *endpoint = argv [1];
            reply = s_try_request (ctx, endpoint, request);
            if (reply)
                break;          //  成功
            printf (&quot;W: 没有收到 %s 的应答, 准备重试...\n&quot;, endpoint);
        }
    }
    else {
        //  若有多个端点，则每个尝试一次
        int endpoint_nbr;
        for (endpoint_nbr = 0; endpoint_nbr &lt; endpoints; endpoint_nbr++) {
            char *endpoint = argv [endpoint_nbr + 1];
            reply = s_try_request (ctx, endpoint, request);
            if (reply)
                break;          //  Successful
            printf (&quot;W: 没有收到 %s 的应答\n&quot;, endpoint);
        }
    }
    if (reply)
        printf (&quot;服务运作正常\n&quot;);

    zmsg_destroy (&amp;request);
    zmsg_destroy (&amp;reply);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>可用如下命令运行：</p>
<pre><code>flserver1 tcp://*:5555 &amp;
flserver1 tcp://*:5556 &amp;
flclient1 tcp://localhost:5555 tcp://localhost:5556
</code></pre><p>客户端的核心机制是懒惰海盗模式，即获得一次成功的应答后就结束。会有两种情况：</p>
<ul>
<li>如果只有一个服务端，客户端会再尝试N次后停止，这和懒惰海盗模式的逻辑一致；</li>
<li>如果有多个服务端，客户端会每个尝试一次，收到应答后停止。</li>
</ul>
<p>这种机制补充了海盗模式，使其能够克服只有一个服务端的情况。</p>
<p>但是，这种设计无法在现实程序中使用：当有很多客户端连接了服务端，而主服务端崩溃了，那所有客户端都需要在超时后才能继续执行。</p>
<h4 id="模型二：批量发送"><a href="#模型二：批量发送" class="headerlink" title="模型二：批量发送"></a>模型二：批量发送</h4><p>下面让我们使用DEALER套接字。我们的目标是能再最短的时间里收到一个应答，不能受主服务端崩溃的影响。可以采取以下措施：</p>
<ul>
<li>连接所有的服务端；</li>
<li>当有请求时，一次性发送给所有的服务端；</li>
<li>等待第一个应答；</li>
<li>忽略其他应答。</li>
</ul>
<p>这样设计客户端时，当发送请求后，所有的服务端都会收到这个请求，并返回应答。如果某个服务端断开连接了，ZMQ可能会将请求发给其他服务端，导致某些服务端会收到两次请求。</p>
<p>更麻烦的是客户端无法得知应答的数量，容易发生混乱。</p>
<p>我们可以为请求进行编号，忽略不匹配的应答。我们要对服务端进行改造，返回的消息中需要包含请求编号：<br><strong>flserver2: Freelance server, Model Two in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 服务端 - 模型2
//  返回带有请求编号的OK信息
//
#include &quot;czmq.h&quot;

int main (int argc, char *argv [])
{
    if (argc &lt; 2) {
        printf (&quot;I: syntax: %s &lt;endpoint&gt;\n&quot;, argv [0]);
        exit (EXIT_SUCCESS);
    }
    zctx_t *ctx = zctx_new ();
    void *server = zsocket_new (ctx, ZMQ_REP);
    zsocket_bind (server, argv [1]);

    printf (&quot;I: 服务已就绪 %s\n&quot;, argv [1]);
    while (TRUE) {
        zmsg_t *request = zmsg_recv (server);
        if (!request)
            break;          //  中断
        //  判断请求内容是否正确
        assert (zmsg_size (request) == 2);

        zframe_t *address = zmsg_pop (request);
        zmsg_destroy (&amp;request);

        zmsg_t *reply = zmsg_new ();
        zmsg_add (reply, address);
        zmsg_addstr (reply, &quot;OK&quot;);
        zmsg_send (&amp;reply, server);
    }
    if (zctx_interrupted)
        printf (&quot;W: interrupted\n&quot;);

    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>客户端代码：</p>
<p><strong>flclient2: Freelance client, Model Two in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 客户端 - 模型2
//  使用DEALER套接字发送批量消息
//
#include &quot;czmq.h&quot;

//  超时时间
#define GLOBAL_TIMEOUT 2500

//  将客户端API封装成一个类

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

//  声明类结构
typedef struct _flclient_t flclient_t;

flclient_t *
    flclient_new (void);
void
    flclient_destroy (flclient_t **self_p);
void
    flclient_connect (flclient_t *self, char *endpoint);
zmsg_t *
    flclient_request (flclient_t *self, zmsg_t **request_p);

#ifdef __cplusplus
}
#endif


int main (int argc, char *argv [])
{
    if (argc == 1) {
        printf (&quot;I: syntax: %s &lt;endpoint&gt; ...\n&quot;, argv [0]);
        exit (EXIT_SUCCESS);
    }
    //  创建自由者模式客户端
    flclient_t *client = flclient_new ();

    //  连接至各个端点
    int argn;
    for (argn = 1; argn &lt; argc; argn++)
        flclient_connect (client, argv [argn]);

    //  发送一组请求，并记录时间
    int requests = 10000;
    uint64_t start = zclock_time ();
    while (requests--) {
        zmsg_t *request = zmsg_new ();
        zmsg_addstr (request, &quot;random name&quot;);
        zmsg_t *reply = flclient_request (client, &amp;request);
        if (!reply) {
            printf (&quot;E: 名称解析服务不可用，正在退出\n&quot;);
            break;
        }
        zmsg_destroy (&amp;reply);
    }
    printf (&quot;平均请求时间: %d 微秒\n&quot;,
        (int) (zclock_time () - start) / 10);

    flclient_destroy (&amp;client);
    return 0;
}



//  --------------------------------------------------------------------
//  类结构

struct _flclient_t {
    zctx_t *ctx;        //  上下文
    void *socket;       //  用于和服务端通信的DEALER套接字
    size_t servers;     //  以连接的服务端数量
    uint sequence;      //  已发送的请求数
};


//  --------------------------------------------------------------------
//  Constructor

flclient_t *
flclient_new (void)
{
    flclient_t
        *self;

    self = (flclient_t *) zmalloc (sizeof (flclient_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;socket = zsocket_new (self-&gt;ctx, ZMQ_DEALER);
    return self;
}

//  --------------------------------------------------------------------
//  析构函数

void
flclient_destroy (flclient_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        flclient_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}

//  --------------------------------------------------------------------
//  连接至新的服务端端点

void
flclient_connect (flclient_t *self, char *endpoint)
{
    assert (self);
    zsocket_connect (self-&gt;socket, endpoint);
    self-&gt;servers++;
}

//  --------------------------------------------------------------------
//  发送请求，接收应答
//  发送后销毁请求

zmsg_t *
flclient_request (flclient_t *self, zmsg_t **request_p)
{
    assert (self);
    assert (*request_p);
    zmsg_t *request = *request_p;

    //  向消息添加编号和空帧
    char sequence_text [10];
    sprintf (sequence_text, &quot;%u&quot;, ++self-&gt;sequence);
    zmsg_pushstr (request, sequence_text);
    zmsg_pushstr (request, &quot;&quot;);

    //  向所有已连接的服务端发送请求
    int server;
    for (server = 0; server &lt; self-&gt;servers; server++) {
        zmsg_t *msg = zmsg_dup (request);
        zmsg_send (&amp;msg, self-&gt;socket);
    }
    //  接收来自任何服务端的应答
    //  因为我们可能poll多次，所以每次都进行计算
    zmsg_t *reply = NULL;
    uint64_t endtime = zclock_time () + GLOBAL_TIMEOUT;
    while (zclock_time () &lt; endtime) {
        zmq_pollitem_t items [] = { { self-&gt;socket, 0, ZMQ_POLLIN, 0 } };
        zmq_poll (items, 1, (endtime - zclock_time ()) * ZMQ_POLL_MSEC);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  应答内容是 [empty][sequence][OK]
            reply = zmsg_recv (self-&gt;socket);
            assert (zmsg_size (reply) == 3);
            free (zmsg_popstr (reply));
            char *sequence = zmsg_popstr (reply);
            int sequence_nbr = atoi (sequence);
            free (sequence);
            if (sequence_nbr == self-&gt;sequence)
                break;
        }
    }
    zmsg_destroy (request_p);
    return reply;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li>客户端被封装成了一个API类，将复杂的代码都包装了起来。</li>
<li>客户端会在几秒之后放弃寻找可用的服务端；</li>
<li>客户端需要创建一个合法的REP信封，所以需要添加一个空帧。</li>
</ul>
<p>程序中，客户端发出了1万次名称解析请求（虽然是假的），并计算平均耗费时间。在我的测试机上，有一个服务端时，耗时60微妙；三个时80微妙。</p>
<p>该模型的优缺点是：</p>
<ul>
<li>优点：简单，容易理解和编写；</li>
<li>优点：它工作迅速，有重试机制；</li>
<li>缺点：占用了额外的网络带宽；</li>
<li>缺点：我们不能为服务端设置优先级，如主服务、次服务等；</li>
<li>缺点：服务端不能同时处理多个请求。</li>
</ul>
<h4 id="Model-Three-Complex-and-Nasty"><a href="#Model-Three-Complex-and-Nasty" class="headerlink" title="Model Three - Complex and Nasty"></a>Model Three - Complex and Nasty</h4><p>批量发送模型看起来不太真实，那就让我们来探索最后这个极度复杂的模型。很有可能在编写完之后我们又会转而使用批量发送，哈哈，这就是我的作风。</p>
<p>我们可以将客户端使用的套接字更换为ROUTER，让我们能够向特定的服务端发送请求，停止向已死亡的服务端发送请求，从而做得尽可能地智能。我们还可以将服务端的套接字更换为ROUTER，从而突破单线程的瓶颈。</p>
<p>但是，使用ROUTER-ROUTER套接字连接两个瞬时套接字是不可行的，节点只有在收到第一条消息时才会为对方生成套接字标识。唯一的方法是让其中一个节点使用持久化的套接字，比较好的方式是让客户端知道服务端的标识，即服务端作为持久化的套接字。</p>
<p>为了避免产生新的配置项，我们直接使用服务端的端点作为套接字标识。</p>
<p>回想一下ZMQ套接字标识是如何工作的。服务端的ROUTER套接字为自己设置一个标识（在绑定之前），当客户端连接时，通过一个握手的过程来交换双方的标识。客户端的ROUTER套接字会先发送一条空消息，服务端为客户端生成一个随机的UUID。然后，服务端会向客户端发送自己的标识。</p>
<p>这样一来，客户端就可以将消息发送给特定的服务端了。不过还有一个问题：我们不知道服务端会在什么时候完成这个握手的过程。如果服务端是在线的，那可能几毫秒就能完成。如果不在线，那可能需要很久很久。</p>
<p>这里有一个矛盾：我们需要知道服务端何时连接成功且能够开始工作。自由者模式不像中间件模式，它的服务端必须要先发送请求后才能的应答。所以在服务端发送消息给客户端之前，客户端必须要先请求服务端，这看似是不可能的。</p>
<p>我有一个解决方法，那就是批量发送。这里发送的不是真正的请求，而是一个试探性的心跳（PING-PONG）。当收到应答时，就说明对方是在线的。</p>
<p>下面让我们制定一个协议，来定义自由者模式是如何传递这种心跳的：</p>
<ul>
<li><a href="http://rfc.zeromq.org/spec:10" target="_blank" rel="external">http://rfc.zeromq.org/spec:10</a></li>
</ul>
<p>实现这个协议的服务端很方便，下面就是经过改造的echo服务：</p>
<p><strong>flserver3: Freelance server, Model Three in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 服务端 - 模型3
//  使用ROUTER-ROUTER套接字进行通信；单线程。
//
#include &quot;czmq.h&quot;

int main (int argc, char *argv [])
{
    int verbose = (argc &gt; 1 &amp;&amp; streq (argv [1], &quot;-v&quot;));

    zctx_t *ctx = zctx_new ();

    //  准备服务端套接字，其标识和端点名相同
    char *bind_endpoint = &quot;tcp://*:5555&quot;;
    char *connect_endpoint = &quot;tcp://localhost:5555&quot;;
    void *server = zsocket_new (ctx, ZMQ_ROUTER);
    zmq_setsockopt (server,
        ZMQ_IDENTITY, connect_endpoint, strlen (connect_endpoint));
    zsocket_bind (server, bind_endpoint);
    printf (&quot;I: 服务端已准备就绪 %s\n&quot;, bind_endpoint);

    while (!zctx_interrupted) {
        zmsg_t *request = zmsg_recv (server);
        if (verbose &amp;&amp; request)
            zmsg_dump (request);
        if (!request)
            break;          //  中断

        //  Frame 0: 客户端标识
        //  Frame 1: 心跳，或客户端控制信息帧
        //  Frame 2: 请求内容
        zframe_t *address = zmsg_pop (request);
        zframe_t *control = zmsg_pop (request);
        zmsg_t *reply = zmsg_new ();
        if (zframe_streq (control, &quot;PONG&quot;))
            zmsg_addstr (reply, &quot;PONG&quot;);
        else {
            zmsg_add (reply, control);
            zmsg_addstr (reply, &quot;OK&quot;);
        }
        zmsg_destroy (&amp;request);
        zmsg_push (reply, address);
        if (verbose &amp;&amp; reply)
            zmsg_dump (reply);
        zmsg_send (&amp;reply, server);
    }
    if (zctx_interrupted)
        printf (&quot;W: 中断\n&quot;);

    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>但是，自由者模式的客户端会变得大一写。为了清晰期间，我们将其拆分为两个类来实现。首先是在上层使用的程序：</p>
<p><strong>flclient3: Freelance client, Model Three in C</strong></p>
<pre><code class="c">//
//  自由者模式 - 客户端 - 模型3
//  使用flcliapi类来封装自由者模式
//
//  直接编译，不建类库
#include &quot;flcliapi.c&quot;

int main (void)
{
    //  创建自由者模式实例
    flcliapi_t *client = flcliapi_new ();

    //  链接至服务器端点
    flcliapi_connect (client, &quot;tcp://localhost:5555&quot;);
    flcliapi_connect (client, &quot;tcp://localhost:5556&quot;);
    flcliapi_connect (client, &quot;tcp://localhost:5557&quot;);

    //  发送随机请求，计算时间
    int requests = 1000;
    uint64_t start = zclock_time ();
    while (requests--) {
        zmsg_t *request = zmsg_new ();
        zmsg_addstr (request, &quot;random name&quot;);
        zmsg_t *reply = flcliapi_request (client, &amp;request);
        if (!reply) {
            printf (&quot;E: 名称解析服务不可用，正在退出\n&quot;);
            break;
        }
        zmsg_destroy (&amp;reply);
    }
    printf (&quot;平均执行时间： %d usec\n&quot;,
        (int) (zclock_time () - start) / 10);

    flcliapi_destroy (&amp;client);
    return 0;
}
</code></pre>
<p>下面是该模式复杂的实现过程：</p>
<p><strong>flcliapi: Freelance client API in C</strong></p>
<pre><code class="c">/*  =====================================================================
    flcliapi - Freelance Pattern agent class
    Model 3: uses ROUTER socket to address specific services

    ---------------------------------------------------------------------
    Copyright (c) 1991-2011 iMatix Corporation &lt;www.imatix.com&gt;
    Copyright other contributors as noted in the AUTHORS file.

    This file is part of the ZeroMQ Guide: http://zguide.zeromq.org

    This is free software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation; either version 3 of the License, or (at
    your option) any later version.

    This software is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this program. If not, see
    &lt;http://www.gnu.org/licenses/&gt;.
    =====================================================================
*/

#include &quot;flcliapi.h&quot;

//  请求超时时间
#define GLOBAL_TIMEOUT  3000    //  msecs
//  心跳间隔
#define PING_INTERVAL   2000    //  msecs
//  判定服务死亡的时间
#define SERVER_TTL      6000    //  msecs


//  =====================================================================
//  同步部分，在应用程序层面运行

//  ---------------------------------------------------------------------
//  类结构

struct _flcliapi_t {
    zctx_t *ctx;        //  上下文
    void *pipe;         //  用于和主线程通信的套接字
};

//  这是运行后台代理程序的线程
static void flcliapi_agent (void *args, zctx_t *ctx, void *pipe);


//  ---------------------------------------------------------------------
//  构造函数

flcliapi_t *
flcliapi_new (void)
{
    flcliapi_t
        *self;

    self = (flcliapi_t *) zmalloc (sizeof (flcliapi_t));
    self-&gt;ctx = zctx_new ();
    self-&gt;pipe = zthread_fork (self-&gt;ctx, flcliapi_agent, NULL);
    return self;
}

//  ---------------------------------------------------------------------
//  析构函数

void
flcliapi_destroy (flcliapi_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        flcliapi_t *self = *self_p;
        zctx_destroy (&amp;self-&gt;ctx);
        free (self);
        *self_p = NULL;
    }
}

//  ---------------------------------------------------------------------
//  连接至新服务器端点
//  消息内容：[CONNECT][endpoint]

void
flcliapi_connect (flcliapi_t *self, char *endpoint)
{
    assert (self);
    assert (endpoint);
    zmsg_t *msg = zmsg_new ();
    zmsg_addstr (msg, &quot;CONNECT&quot;);
    zmsg_addstr (msg, endpoint);
    zmsg_send (&amp;msg, self-&gt;pipe);
    zclock_sleep (100);      //  等待连接
}

//  ---------------------------------------------------------------------
//  发送并销毁请求，接收应答

zmsg_t *
flcliapi_request (flcliapi_t *self, zmsg_t **request_p)
{
    assert (self);
    assert (*request_p);

    zmsg_pushstr (*request_p, &quot;REQUEST&quot;);
    zmsg_send (request_p, self-&gt;pipe);
    zmsg_t *reply = zmsg_recv (self-&gt;pipe);
    if (reply) {
        char *status = zmsg_popstr (reply);
        if (streq (status, &quot;FAILED&quot;))
            zmsg_destroy (&amp;reply);
        free (status);
    }
    return reply;
}


//  =====================================================================
//  异步部分，在后台运行

//  ---------------------------------------------------------------------
//  单个服务端信息

typedef struct {
    char *endpoint;             //  服务端端点/套接字标识
    uint alive;                 //  是否在线
    int64_t ping_at;            //  下一次心跳时间
    int64_t expires;            //  过期时间
} server_t;

server_t *
server_new (char *endpoint)
{
    server_t *self = (server_t *) zmalloc (sizeof (server_t));
    self-&gt;endpoint = strdup (endpoint);
    self-&gt;alive = 0;
    self-&gt;ping_at = zclock_time () + PING_INTERVAL;
    self-&gt;expires = zclock_time () + SERVER_TTL;
    return self;
}

void
server_destroy (server_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        server_t *self = *self_p;
        free (self-&gt;endpoint);
        free (self);
        *self_p = NULL;
    }
}

int
server_ping (char *key, void *server, void *socket)
{
    server_t *self = (server_t *) server;
    if (zclock_time () &gt;= self-&gt;ping_at) {
        zmsg_t *ping = zmsg_new ();
        zmsg_addstr (ping, self-&gt;endpoint);
        zmsg_addstr (ping, &quot;PING&quot;);
        zmsg_send (&amp;ping, socket);
        self-&gt;ping_at = zclock_time () + PING_INTERVAL;
    }
    return 0;
}

int
server_tickless (char *key, void *server, void *arg)
{
    server_t *self = (server_t *) server;
    uint64_t *tickless = (uint64_t *) arg;
    if (*tickless &gt; self-&gt;ping_at)
        *tickless = self-&gt;ping_at;
    return 0;
}


//  ---------------------------------------------------------------------
//  后台处理程序信息

typedef struct {
    zctx_t *ctx;                //  上下文
    void *pipe;                 //  用于应用程序通信的套接字
    void *router;               //  用于服务端通信的套接字
    zhash_t *servers;           //  已连接的服务端
    zlist_t *actives;           //  在线的服务端
    uint sequence;              //  请求编号
    zmsg_t *request;            //  当前请求
    zmsg_t *reply;              //  当前应答
    int64_t expires;            //  请求过期时间
} agent_t;

agent_t *
agent_new (zctx_t *ctx, void *pipe)
{
    agent_t *self = (agent_t *) zmalloc (sizeof (agent_t));
    self-&gt;ctx = ctx;
    self-&gt;pipe = pipe;
    self-&gt;router = zsocket_new (self-&gt;ctx, ZMQ_ROUTER);
    self-&gt;servers = zhash_new ();
    self-&gt;actives = zlist_new ();
    return self;
}

void
agent_destroy (agent_t **self_p)
{
    assert (self_p);
    if (*self_p) {
        agent_t *self = *self_p;
        zhash_destroy (&amp;self-&gt;servers);
        zlist_destroy (&amp;self-&gt;actives);
        zmsg_destroy (&amp;self-&gt;request);
        zmsg_destroy (&amp;self-&gt;reply);
        free (self);
        *self_p = NULL;
    }
}

//  当服务端从列表中移除时，回调该函数。

static void
s_server_free (void *argument)
{
    server_t *server = (server_t *) argument;
    server_destroy (&amp;server);
}

void
agent_control_message (agent_t *self)
{
    zmsg_t *msg = zmsg_recv (self-&gt;pipe);
    char *command = zmsg_popstr (msg);

    if (streq (command, &quot;CONNECT&quot;)) {
        char *endpoint = zmsg_popstr (msg);
        printf (&quot;I: connecting to %s...\n&quot;, endpoint);
        int rc = zmq_connect (self-&gt;router, endpoint);
        assert (rc == 0);
        server_t *server = server_new (endpoint);
        zhash_insert (self-&gt;servers, endpoint, server);
        zhash_freefn (self-&gt;servers, endpoint, s_server_free);
        zlist_append (self-&gt;actives, server);
        server-&gt;ping_at = zclock_time () + PING_INTERVAL;
        server-&gt;expires = zclock_time () + SERVER_TTL;
        free (endpoint);
    }
    else
    if (streq (command, &quot;REQUEST&quot;)) {
        assert (!self-&gt;request);    //  遵循请求-应答循环
        //  将请求编号和空帧加入消息顶部
        char sequence_text [10];
        sprintf (sequence_text, &quot;%u&quot;, ++self-&gt;sequence);
        zmsg_pushstr (msg, sequence_text);
        //  获取请求消息的所有权
        self-&gt;request = msg;
        msg = NULL;
        //  设置请求过期时间
        self-&gt;expires = zclock_time () + GLOBAL_TIMEOUT;
    }
    free (command);
    zmsg_destroy (&amp;msg);
}

void
agent_router_message (agent_t *self)
{
    zmsg_t *reply = zmsg_recv (self-&gt;router);

    //  第一帧是应答的服务端标识
    char *endpoint = zmsg_popstr (reply);
    server_t *server =
        (server_t *) zhash_lookup (self-&gt;servers, endpoint);
    assert (server);
    free (endpoint);
    if (!server-&gt;alive) {
        zlist_append (self-&gt;actives, server);
        server-&gt;alive = 1;
    }
    server-&gt;ping_at = zclock_time () + PING_INTERVAL;
    server-&gt;expires = zclock_time () + SERVER_TTL;

    //  第二帧是应答的编号
    char *sequence = zmsg_popstr (reply);
    if (atoi (sequence) == self-&gt;sequence) {
        zmsg_pushstr (reply, &quot;OK&quot;);
        zmsg_send (&amp;reply, self-&gt;pipe);
        zmsg_destroy (&amp;self-&gt;request);
    }
    else
        zmsg_destroy (&amp;reply);
}


//  ---------------------------------------------------------------------
//  异步的后台代理会维护一个服务端池，处理请求和应答。

static void
flcliapi_agent (void *args, zctx_t *ctx, void *pipe)
{
    agent_t *self = agent_new (ctx, pipe);

    zmq_pollitem_t items [] = {
        { self-&gt;pipe, 0, ZMQ_POLLIN, 0 },
        { self-&gt;router, 0, ZMQ_POLLIN, 0 }
    };
    while (!zctx_interrupted) {
        //  计算超时时间
        uint64_t tickless = zclock_time () + 1000 * 3600;
        if (self-&gt;request
        &amp;&amp;  tickless &gt; self-&gt;expires)
            tickless = self-&gt;expires;
        zhash_foreach (self-&gt;servers, server_tickless, &amp;tickless);

        int rc = zmq_poll (items, 2,
            (tickless - zclock_time ()) * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  上下文对象被关闭

        if (items [0].revents &amp; ZMQ_POLLIN)
            agent_control_message (self);

        if (items [1].revents &amp; ZMQ_POLLIN)
            agent_router_message (self);

        //  如果我们需要处理一项请求，将其发送给下一个可用的服务端
        if (self-&gt;request) {
            if (zclock_time () &gt;= self-&gt;expires) {
                //  请求超时
                zstr_send (self-&gt;pipe, &quot;FAILED&quot;);
                zmsg_destroy (&amp;self-&gt;request);
            }
            else {
                //  寻找可用的服务端
                while (zlist_size (self-&gt;actives)) {
                    server_t *server =
                        (server_t *) zlist_first (self-&gt;actives);
                    if (zclock_time () &gt;= server-&gt;expires) {
                        zlist_pop (self-&gt;actives);
                        server-&gt;alive = 0;
                    }
                    else {
                        zmsg_t *request = zmsg_dup (self-&gt;request);
                        zmsg_pushstr (request, server-&gt;endpoint);
                        zmsg_send (&amp;request, self-&gt;router);
                        break;
                    }
                }
            }
        }
        //  断开并删除已过期的服务端
        //  发送心跳给空闲服务器
        zhash_foreach (self-&gt;servers, server_ping, self-&gt;router);
    }
    agent_destroy (&amp;self);
}
</code></pre>
<p>这组API使用了较为复杂的机制，我们之前也有用到过：</p>
<p><strong>异步后台代理</strong></p>
<p>客户端API由两部分组成：同步的flcliapi类，运行于应用程序线程；异步的agent类，运行于后台线程。flcliapi和agent类通过一个inproc套接字互相通信。所有和ZMQ相关的内容都封装在API中。agent类实质上是作为一个迷你的代理程序在运行，负责在后台与服务端进行通信，只要我们发送请求，它就会设法连接一个服务器来处理请求。</p>
<p><strong>连接等待机制</strong></p>
<p>ROUTER套接字的特点之一是会直接丢弃无法路由的消息，这就意味着当与服务器建立了ROUTER-ROUTER连接后，如果立刻发送一条消息，该消息是会丢失的。flcliapi类则延迟了一会儿后再发送消息。之后的通信中，由于服务端套接字是持久的，客户端就不再丢弃消息了。</p>
<p><strong>Ping silence</strong></p>
<p>0MQ will queue messages for a dead server indefinitely. So if a client repeatedly PINGs a dead server, when that server comes back to life it’ll get a whole bunch of PING messages all at once. Rather than continuing to ping a server we know is offline, we count on 0MQ’s handling of durable sockets to deliver the old PING messages when the server comes back online. As soon as a server reconnects, it’ll get PINGs from all clients that were connected to it, it’ll PONG back, and those clients will recognize it as alive again.</p>
<p><strong>调整轮询时间</strong></p>
<p>在之前的示例程序中，我们一般会为轮询设置固定的超时时间（如1秒），这种做法虽然简单，但是对于用电较为敏感的设备来说（如笔记本电脑或手机）唤醒CPU是需要额外的电力的。所以，为了完美也好，好玩也好，我们这里调整了轮询时间，将其设置为到达过期时间时才超时，这样就能节省一部分轮询次数了。我们可以将过期时间放入一个列表中存储，方便查询。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一章中我们看到了很多可靠的请求-应答机制，每种机制都有其优劣性。大部分示例代码是可以直接用于生产环境的，不过还可以进一步优化。有两个模式会比较典型：使用了中间件的管家模式，以及未使用中间件的自由者模式。</p>
]]></content>
      
        <categories>
            
            <category> 网络编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zmq,网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zmq学习第三章]]></title>
      <url>/2017/12/23/zmq_chapter3/</url>
      <content type="html"><![CDATA[<h2 id="第三章-高级请求-应答模式"><a href="#第三章-高级请求-应答模式" class="headerlink" title="第三章 高级请求-应答模式"></a>第三章 高级请求-应答模式</h2><p>在第二章中我们通过开发一系列的小应用来熟悉ØMQ的基本使用方法，每个应用会引入一些新的特性。本章会沿用这种方式，来探索更多建立在ØMQ请求-应答模式之上的高级工作模式。</p>
<p>本章涉及的内容有：</p>
<ul>
<li>在请求-应答模式中创建和使用消息信封</li>
<li>使用REQ、REP、DEALER和ROUTER套接字</li>
<li>使用标识来手工指定应答目标</li>
<li>使用自定义离散路由模式</li>
<li>使用自定义最近最少使用路由模式</li>
<li>构建高层消息封装类</li>
<li>构建基本的请求应答代理</li>
<li>合理命名套接字</li>
<li>模拟client-worker集群</li>
<li>构建可扩展的请求-应答集群云</li>
<li>使用管道套接字监控线程</li>
</ul>
<a id="more"></a>
<h3 id="Request-Reply-Envelopes"><a href="#Request-Reply-Envelopes" class="headerlink" title="Request-Reply Envelopes"></a>Request-Reply Envelopes</h3><p>在请求-应答模式中，信封里保存了应答目标的位置。这就是为什么ØMQ网络虽然是无状态的，但仍能完成请求-应答的过程。</p>
<p>在一般使用过程中，你并不需要知道请求-应答信封的工作原理。使用REQ、REP时，ØMQ会自动处理消息信封。下一章讲到的装置（device），使用时也只需保证读取和写入所有的信息即可。ØMQ使用多段消息的方式来存储信封，所以在复制消息时也会复制信封。</p>
<p>然而，在使用高级请求-应答模式之前是需要了解信封这一机制的，以下是信封机制在ROUTER中的工作原理：</p>
<ul>
<li>从ROUTER中读取一条消息时，ØMQ会包上一层信封，上面注明了消息的来源。</li>
<li>向ROUTER写入一条消息时（包含信封），ØMQ会将信封拆开，并将消息递送给相应的对象。</li>
</ul>
<p>如果将从ROUTER A中获取的消息（包含信封）写入ROUTER B（即将消息发送给一个DEALER，该DEALER连接到了ROUTER），那么在从ROUTER B中获取该消息时就会包含两层信封。</p>
<p>信封机制的根本作用是让ROUTER知道如何将消息递送给正确的应答目标，你需要做的就是在程序中保留好该信封。回顾一下REP套接字，它会将收到消息的信封逐个拆开，将消息本身传送给应用程序。而在发送时，又会在消息外层包裹该信封，发送给ROUTER，从而传递给正确的应答目标。</p>
<p>我们可以使用上述原理建立起一个ROUTER-DEALER装置：</p>
<pre><code>[REQ] &lt;--&gt; [REP]
[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]
[REQ] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [ROUTER--DEALER] &lt;--&gt; [REP]
...etc.
</code></pre><p>当你用REQ套接字去连接ROUTER套接字，并发送一条请求消息，你会从ROUTER中获得一条如下所示的消息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_1.png" alt="1"></p>
<ul>
<li>第三帧是应用程序发送给REQ套接字的消息；</li>
<li>第二帧的空信息是REQ套接字在发送消息给ROUTER之前添加的；</li>
<li>第一帧即信封，是由ROUTER套接字添加的，记录了消息的来源。</li>
</ul>
<p>如果我们在一条装置链路上传递该消息，最终会得到包含多层信封的消息。最新的信封会在消息的顶部。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_2.png" alt="2"></p>
<p>以下将详述我们在请求-应答模式中使用到的四种套接字类型：</p>
<ul>
<li><p>DEALER是一种负载均衡，它会将消息分发给已连接的节点，并使用公平队列的机制处理接受到的消息。DEALER的作用就像是PUSH和PULL的结合。</p>
</li>
<li><p>REQ发送消息时会在消息顶部插入一个空帧，接受时会将空帧移去。其实REQ是建立在DEALER之上的，但REQ只有当消息发送并接受到回应后才能继续运行。</p>
</li>
<li><p>ROUTER在收到消息时会在顶部添加一个信封，标记消息来源。发送时会通过该信封决定哪个节点可以获取到该条消息。</p>
</li>
<li><p>REP在收到消息时会将第一个空帧之前的所有信息保存起来，将原始信息传送给应用程序。在发送消息时，REP会用刚才保存的信息包裹应答消息。REP其实是建立在ROUTER之上的，但和REQ一样，必须完成接受和发送这两个动作后才能继续。</p>
</li>
</ul>
<p>REP要求消息中的信封由一个空帧结束，所以如果你没有用REQ发送消息，则需要自己在消息中添加这个空帧。</p>
<p>你肯定会问，ROUTER是怎么标识消息的来源的？答案当然是套接字的标识。我们之前讲过，一个套接字可能是瞬时的，它所连接的套接字（如ROUTER）则会给它生成一个标识，与之相关联。一个套接字也可以显式地给自己定义一个标识，这样其他套接字就可以直接使用了。</p>
<p>这是一个瞬时的套接字，ROUTER会自动生成一个UUID来标识消息的来源。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_3.png" alt="3"></p>
<p>这是一个持久的套接字，标识由消息来源自己指定。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_4.png" alt="4"></p>
<p>下面让我们在实例中观察上述两种操作。下列程序会打印出ROUTER从两个REP套接字中获得的消息，其中一个没有指定标识，另一个指定了“Hello”作为标识。</p>
<p><strong>identity.c</strong></p>
<pre><code class="c">// 
// 以下程序演示了如何在请求-应答模式中使用套接字标识。
// 需要注意的是s_开头的函数是由zhelpers.h提供的。
// 我们没有必要重复编写那些代码。
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    void *context = zmq_init (1);

    void *sink = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (sink, &quot;inproc://example&quot;);

    // 第一个套接字由0MQ自动设置标识
    void *anonymous = zmq_socket (context, ZMQ_REQ);
    zmq_connect (anonymous, &quot;inproc://example&quot;);
    s_send (anonymous, &quot;ROUTER uses a generated UUID&quot;);
    s_dump (sink);

    // 第二个由自己设置
    void *identified = zmq_socket (context, ZMQ_REQ);
    zmq_setsockopt (identified, ZMQ_IDENTITY, &quot;Hello&quot;, 5);
    zmq_connect (identified, &quot;inproc://example&quot;);
    s_send (identified, &quot;ROUTER socket uses REQ&#39;s socket identity&quot;);
    s_dump (sink);

    zmq_close (sink);
    zmq_close (anonymous);
    zmq_close (identified);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>运行结果：</p>
<pre><code>----------------------------------------
[017] 00314F043F46C441E28DD0AC54BE8DA727
[000]
[026] ROUTER uses a generated UUID
----------------------------------------
[005] Hello
[000]
[038] ROUTER socket uses REQ&#39;s socket identity
</code></pre><h3 id="自定义请求-应答路由"><a href="#自定义请求-应答路由" class="headerlink" title="自定义请求-应答路由"></a>自定义请求-应答路由</h3><p>我们已经看到ROUTER套接字是如何使用信封将消息发送给正确的应答目标的，下面我们从一个角度来定义ROUTER：在发送消息时使用一定格式的信封提供正确的路由目标，ROUTER就能够将该条消息异步地发送给对应的节点。</p>
<p>所以说ROUTER的行为是完全可控的。在深入理解这一特性之前，让我们先近距离观察一下REQ和REP套接字，赋予他们一些鲜活的角色：</p>
<ul>
<li>REQ是一个“妈妈”套接字，不会耐心听别人说话，但会不断地抛出问题寻求解答。REQ是严格同步的，它永远位于消息链路的请求端；</li>
<li>REP则是一个“爸爸”套接字，只会回答问题，不会主动和别人对话。REP也是严格同步的，并一直位于应答端。</li>
</ul>
<p>关于“妈妈”套接字，正如我们小时候所经历的，只能等她向你开口时你们才能对话。妈妈不像爸爸那么开明，也不会像DEALER套接字一样接受模棱两可的回答。所以，想和REQ套接字对话只有等它主动发出请求后才行，之后它就会一直等待你的回答，不管有多久。</p>
<p>“爸爸”套接字则给人一种强硬、冷漠的感觉，他只做一件事：无论你提出什么问题，都会给出一个精确的回答。不要期望一个REP套接字会主动和你对话或是将你俩的交谈传达给别人，它不会这么做的。</p>
<p>我们通常认为请求-应答模式一定是有来有往、有去有回的过程，但实际上这个过程是可以异步进行的。我们只需获得相应节点的地址，即可通过ROUTER套接字来异步地发送消息。ROUTER是ZMQ中唯一一个可以定位消息来源的套接字。</p>
<p>我们对请求-应答模式下的路由做一个小结：</p>
<ul>
<li>对于瞬时的套接字，ROUTER会动态生成一个UUID来标识它，因此从ROUTER中获取到的消息里会包含这个标识；</li>
<li>对于持久的套接字，可以自定义标识，ROUTER会如直接将该标识放入消息之中；</li>
<li>具有显式声明标识的节点可以连接到其他类型的套接字；</li>
<li>节点可以通过配置文件等机制提前获知对方节点的标识，作出相应的处理。</li>
</ul>
<p>我们至少有三种模式来实现和ROUTER的连接：</p>
<ul>
<li>ROUTER-DEALER</li>
<li>ROUTER-REQ</li>
<li>ROUTER-REP</li>
</ul>
<p>每种模式下我们都可以完全掌控消息的路由方式，但不同的模式会有不一样的应用场景和消息流，下一节开始我们会逐一解释。</p>
<p>自定义路由也有一些注意事项：</p>
<ul>
<li>自定义路由让节点能够控制消息的去向，这一点有悖ØMQ的规则。使用自定义路由的唯一理由是ØMQ缺乏更多的路由算法供我们选择；</li>
<li>未来的ØMQ版本可能包含一些我们自定义的路由方式，这意味着我们现在设计的代码可能无法在新版本的ØMQ中运行，或者成为一种多余；</li>
<li>内置的路由机制是可扩展的，且对装置友好，但自定义路由就需要自己解决这些问题。</li>
</ul>
<p>所以说自定义路由的成本是比较高的，更多情况下应当交由ØMQ来完成。不过既然我们已经讲到这儿了，就继续深入下去吧！</p>
<h3 id="ROUTER-DEALER路由"><a href="#ROUTER-DEALER路由" class="headerlink" title="ROUTER-DEALER路由"></a>ROUTER-DEALER路由</h3><p>ROUTER-DEALDER是一种最简单的路由方式。将ROUTER和多个DEALER相连接，用一种合适的算法来决定如何分发消息给DEALER。DEALER可以是一个黑洞（只负责处理消息，不给任何返回）、代理（将消息转发给其他节点）或是服务（会发送返回信息）。</p>
<p>如果你要求DEALER能够进行回复，那就要保证只有一个ROUTER连接到DEALER，因为DEALER并不知道哪个特定的节点在联系它，如果有多个节点，它会做负载均衡，将消息分发出去。但如果DEALER是一个黑洞，那就可以连接任何数量的节点。</p>
<p>ROUTER-DEALER路由可以用来做什么呢？如果DEALER会将它完成任务的时间回复给ROUTER，那ROUTER就可以知道这个DEALER的处理速度有多快了。因为ROUTER和DEALER都是异步的套接字，所以我们要用zmq_poll()来处理这种情况。</p>
<p>下面例子中的两个DEALER不会返回消息给ROUTER，我们的路由采用加权随机算法：发送两倍多的信息给其中的一个DEALER。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_5.png" alt="5"></p>
<p><strong>rtdealer.c</strong></p>
<pre><code class="c">//
// 自定义ROUTER-DEALER路由
//
// 这个实例是单个进程，这样方便启动。
// 每个线程都有自己的ZMQ上下文，所以可以认为是多个进程在运行。
//
#include &quot;zhelpers.h&quot;
#include &lt;pthread.h&gt;

// 这里定义了两个worker，其代码是一样的。
//
static void *
worker_task_a (void *args)
{
    void *context = zmq_init (1);
    void *worker = zmq_socket (context, ZMQ_DEALER);
    zmq_setsockopt (worker, ZMQ_IDENTITY, &quot;A&quot;, 1);
    zmq_connect (worker, &quot;ipc://routing.ipc&quot;);

    int total = 0;
    while (1) {
        // 我们只接受到消息的第二部分
        char *request = s_recv (worker);
        int finished = (strcmp (request, &quot;END&quot;) == 0);
        free (request);
        if (finished) {
            printf (&quot;A received: %d\n&quot;, total);
            break;
        }
        total++;
    }
    zmq_close (worker);
    zmq_term (context);
    return NULL;
}

static void *
worker_task_b (void *args)
{
    void *context = zmq_init (1);
    void *worker = zmq_socket (context, ZMQ_DEALER);
    zmq_setsockopt (worker, ZMQ_IDENTITY, &quot;B&quot;, 1);
    zmq_connect (worker, &quot;ipc://routing.ipc&quot;);

    int total = 0;
    while (1) {
        // 我们只接受到消息的第二部分
        char *request = s_recv (worker);
        int finished = (strcmp (request, &quot;END&quot;) == 0);
        free (request);
        if (finished) {
            printf (&quot;B received: %d\n&quot;, total);
            break;
        }
        total++;
    }
    zmq_close (worker);
    zmq_term (context);
    return NULL;
}

int main (void)
{
    void *context = zmq_init (1);
    void *client = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (client, &quot;ipc://routing.ipc&quot;);

    pthread_t worker;
    pthread_create (&amp;worker, NULL, worker_task_a, NULL);
    pthread_create (&amp;worker, NULL, worker_task_b, NULL);

    // 等待线程连接至套接字，否则我们发送的消息将不能被正确路由
    sleep (1);

    // 发送10个任务，给A两倍多的量
    int task_nbr;
    srandom ((unsigned) time (NULL));
    for (task_nbr = 0; task_nbr &lt; 10; task_nbr++) {
        // 发送消息的两个部分：第一部分是目标地址
        if (randof (3) &gt; 0)
            s_sendmore (client, &quot;A&quot;);
        else
            s_sendmore (client, &quot;B&quot;);

        // 然后是任务
        s_send (client, &quot;This is the workload&quot;);
    }
    s_sendmore (client, &quot;A&quot;);
    s_send (client, &quot;END&quot;);

    s_sendmore (client, &quot;B&quot;);
    s_send (client, &quot;END&quot;);

    zmq_close (client);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>对上述代码的两点说明：</p>
<ul>
<li>ROUTER并不知道DEALER何时会准备好，我们可以用信号机制来解决，但为了不让这个例子太过复杂，我们就用sleep(1)的方式来处理。如果没有这句话，那ROUTER一开始发出的消息将无法被路由，ØMQ会丢弃这些消息。</li>
<li>需要注意的是，除了ROUTER会丢弃无法路由的消息外，PUB套接字当没有SUB连接它时也会丢弃发送出去的消息。其他套接字则会将无法发送的消息存储起来，直到有节点来处理它们。</li>
</ul>
<p>在将消息路由给DEALER时，我们手工建立了这样一个信封：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_6.png" alt="6"></p>
<p>ROUTER套接字会移除第一帧，只将第二帧的内容传递给相应的DEALER。当DEALER发送消息给ROUTER时，只会发送一帧，ROUTER会在外层包裹一个信封（添加第一帧），返回给我们。</p>
<p>如果你定义了一个非法的信封地址，ROUTER会直接丢弃该消息，不作任何提示。对于这一点我们也无能为力，因为出现这种情况只有两种可能，一是要送达的目标节点不复存在了，或是程序中错误地指定了目标地址。如何才能知道消息会被正确地路由？唯一的方法是让路由目标发送一些反馈消息给我们。后面几章会讲述这一点。</p>
<p>DEALER的工作方式就像是PUSH和PULL的结合。但是，我们不能用PULL或PUSH去构建请求-应答模式。</p>
<h3 id="最近最少使用算法路由（LRU模式）"><a href="#最近最少使用算法路由（LRU模式）" class="headerlink" title="最近最少使用算法路由（LRU模式）"></a>最近最少使用算法路由（LRU模式）</h3><p>我们之前讲过REQ套接字永远是对话的发起方，然后等待对方回答。这一特性可以让我们能够保持多个REQ套接字等待调配。换句话说，REQ套接字会告诉我们它已经准备好了。</p>
<p>你可以将ROUTER和多个REQ相连，请求-应答的过程如下：</p>
<ul>
<li>REQ发送消息给ROUTER</li>
<li>ROUTER返回消息给REQ</li>
<li>REQ发送消息给ROUTER</li>
<li>ROUTER返回消息给REQ</li>
<li>…</li>
</ul>
<p>和DEALER相同，REQ只能和一个ROUTER连接，除非你想做类似多路冗余路由这样的事（我甚至不想在这里解释），其复杂度会超过你的想象并迫使你放弃的。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_7.png" alt="7"></p>
<p>ROUTER-REQ模式可以用来做什么？最常用的做法就是最近最少使用算法（LRU）路由了，ROUTER发出的请求会让等待最久的REQ来处理。请看示例：</p>
<pre><code class="c">//
// 自定义ROUTER-REQ路由
//
#include &quot;zhelpers.h&quot;
#include &lt;pthread.h&gt;

#define NBR_WORKERS 10

static void *
worker_task(void *args) {
    void *context = zmq_init(1);
    void *worker = zmq_socket(context, ZMQ_REQ);

    // s_set_id()函数会根据套接字生成一个可打印的字符串，
    // 并以此作为该套接字的标识。 
    s_set_id(worker);
    zmq_connect(worker, &quot;ipc://routing.ipc&quot;);

    int total = 0;
    while (1) {
        // 告诉ROUTER我已经准备好了
        s_send(worker, &quot;ready&quot;);

        // 从ROUTER中获取工作，直到收到结束的信息
        char *workload = s_recv(worker);
        int finished = (strcmp(workload, &quot;END&quot;) == 0);
        free(workload);
        if (finished) {
            printf(&quot;Processed: %d tasks\n&quot;, total);
            break;
        }
        total++;

        // 随机等待一段时间
        s_sleep(randof(1000) + 1);
    }
    zmq_close(worker);
    zmq_term(context);
    return NULL;
}

int main(void) {
    void *context = zmq_init(1);
    void *client = zmq_socket(context, ZMQ_ROUTER);
    zmq_bind(client, &quot;ipc://routing.ipc&quot;);
    srandom((unsigned) time(NULL));

    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        pthread_t worker;
        pthread_create(&amp;worker, NULL, worker_task, NULL);
    }
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; NBR_WORKERS * 10; task_nbr++) {
        // 最近最少使用的worker就在消息队列中
        char *address = s_recv(client);
        char *empty = s_recv(client);
        free(empty);
        char *ready = s_recv(client);
        free(ready);

        s_sendmore(client, address);
        s_sendmore(client, &quot;&quot;);
        s_send(client, &quot;This is the workload&quot;);
        free(address);
    }
    // 通知所有REQ套接字结束工作
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        char *address = s_recv(client);
        char *empty = s_recv(client);
        free(empty);
        char *ready = s_recv(client);
        free(ready);

        s_sendmore(client, address);
        s_sendmore(client, &quot;&quot;);
        s_send(client, &quot;END&quot;);
        free(address);
    }
    zmq_close(client);
    zmq_term(context);
    return 0;
}
</code></pre>
<p>在这个示例中，实现LRU算法并没有用到特别的数据结构，因为ØMQ的消息队列机制已经提供了等价的实现。一个更为实际的LRU算法应该将已准备好的worker收集起来，保存在一个队列中进行分配。以后我们会讲到这个例子。</p>
<p>程序的运行结果会将每个worker的执行次数打印出来。由于REQ套接字会随机等待一段时间，而我们也没有做负载均衡，所以我们希望看到的是每个worker执行相近的工作量。这也是程序执行的结果。</p>
<pre><code>Processed: 8 tasks
Processed: 8 tasks
Processed: 11 tasks
Processed: 7 tasks
Processed: 9 tasks
Processed: 11 tasks
Processed: 14 tasks
Processed: 11 tasks
Processed: 11 tasks
Processed: 10 tasks
</code></pre><p>关于以上代码的几点说明：</p>
<ul>
<li><p>我们不需要像前一个例子一样等待一段时间，因为REQ套接字会明确告诉ROUTER它已经准备好了。</p>
</li>
<li><p>我们使用了zhelpers.h提供的s_set_id()函数来为套接字生成一个可打印的字符串标识，这是为了让例子简单一些。在现实环境中，REQ套接字都是匿名的，你需要直接调用zmq_recv()和zmq_send()来处理消息，因为s_recv()和s_send()只能处理字符串标识的套接字。</p>
</li>
<li><p>更糟的是，我们使用了随机的标识，不要在现实环境中使用随机标识的持久套接字，这样做会将节点消耗殆尽。</p>
</li>
<li><p>如果你只是将上面的代码拷贝过来，没有充分理解，那你就像是看到蜘蛛人从屋顶上飞下来，你也照着做了，后果自负吧。</p>
</li>
</ul>
<p>在将消息路由给REQ套接字时，需要注意一定的格式，即地址-空帧-消息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_8.png" alt="8"></p>
<h3 id="使用地址进行路由"><a href="#使用地址进行路由" class="headerlink" title="使用地址进行路由"></a>使用地址进行路由</h3><p>在经典的请求-应答模式中，ROUTER一般不会和REP套接字通信，而是由DEALER去和REP通信。DEALER会将消息随机分发给多个REP，并获得结果。ROUTER更适合和REQ套接字通信。</p>
<p>我们应该记住，ØMQ的经典模型往往是运行得最好的，毕竟人走得多的路往往是条好路，如果不按常理出牌，那很有可能会跌入无敌深潭。下面我们就将ROUTER和REP进行连接，看看会发生什么。</p>
<p>REP套接字有两个特点：</p>
<ul>
<li>它需要完成完整的请求-应答周期；</li>
<li>它可以接受任意大小的信封，并能完整地返回该信封。</li>
</ul>
<p>在一般的请求-应答模式中，REP是匿名的，可以随时替换。因为我们这里在将自定义路由，就要做到将一条消息发送给REP A，而不是REP B。这样才能保证网络的一端是你，另一端是特定的REP。</p>
<p>ØMQ的核心理念之一是周边的节点应该尽可能的智能，且数量众多，而中间件则是固定和简单的。这就意味着周边节点可以向其他特定的节点发送消息，比如可以连接到一个特定的REP。这里我们先不讨论如何在多个节点之间进行路由，只看最后一步中ROUTER如何和特定的REP通信的。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_9.png" alt="9"></p>
<p>这张图描述了以下事件：</p>
<ul>
<li>client有一条消息，将来会通过另一个ROUTER将该消息发送回去。这条信息包含了两个地址、一个空帧、以及消息内容；</li>
<li>client将该条消息发送给了ROUTER，并指定了REP的地址；</li>
<li>ROUTER将该地址移去，并以此决定其下哪个REP可以获得该消息；</li>
<li>REP收到该条包含地址、空帧、以及内容的消息；</li>
<li>REP将空帧之前的所有内容移去，交给worker去处理消息；</li>
<li>worker处理完成后将回复交给REP；</li>
<li>REP将之前保存好的信封包裹住该条回复，并发送给ROUTER；</li>
<li>ROUTER在该条回复上又添加了一个注明REP的地址的帧。</li>
</ul>
<p>这个过程看起来很复杂，但还是有必要取了解清楚的。只要记住，REP套接字会原封不动地将信封返回回去。</p>
<p><strong>rtpapa.c</strong></p>
<pre><code class="c">//
//  自定义ROUTER-REP路由
//
#include &quot;zhelpers.h&quot;

//  这里使用一个进程来强调事件发生的顺序性
int main (void) 
{
    void *context = zmq_init (1);

    void *client = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (client, &quot;ipc://routing.ipc&quot;);

    void *worker = zmq_socket (context, ZMQ_REP);
    zmq_setsockopt (worker, ZMQ_IDENTITY, &quot;A&quot;, 1);
    zmq_connect (worker, &quot;ipc://routing.ipc&quot;);

    //  等待worker连接
    sleep (1);

    //  发送REP的标识、地址、空帧、以及消息内容
    s_sendmore (client, &quot;A&quot;);
    s_sendmore (client, &quot;address 3&quot;);
    s_sendmore (client, &quot;address 2&quot;);
    s_sendmore (client, &quot;address 1&quot;);
    s_sendmore (client, &quot;&quot;);
    s_send     (client, &quot;This is the workload&quot;);

    //  worker只会得到消息内容
    s_dump (worker);

    //  worker不需要处理信封
    s_send (worker, &quot;This is the reply&quot;);

    //  看看ROUTER里收到了什么
    s_dump (client);

    zmq_close (client);
    zmq_close (worker);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>运行结果</p>
<pre><code>----------------------------------------
[020] This is the workload
----------------------------------------
[001] A
[009] address 3
[009] address 2
[009] address 1
[000]
[017] This is the reply
</code></pre><p>关于以上代码的几点说明：</p>
<ul>
<li><p>在现实环境中，ROUTER和REP套接字处于不同的节点。本例没有启用多进程，为的是让事件的发生顺序更为清楚。</p>
</li>
<li><p>zmq_connect()并不是瞬间完成的，REP和ROUTER连接的时候是会花费一些时间的。在现实环境中，ROUTER无从得知REP是否已经连接成功了，除非得到REP的某些回应。本例中使用sleep(1)来处理这一问题，如果不这样做，那REP将无法获得消息（自己尝试一下吧）。</p>
</li>
<li><p>我们使用REP的套接字标识来进行路由，如果你不信，可以将消息发送给B，看看A能不能收到。</p>
</li>
<li><p>本例中的s_dump()等函数来自于zhelpers.h文件，可以看到在进行套接字连接时代码都是一样的，所以我们才能在ØMQ API的基础上搭建上层的API。等今后我们讨论到复杂应用程序的时候再详细说明。</p>
</li>
</ul>
<p>要将消息路由给REP，我们需要创建它能辨别的信封：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_10.png" alt="10"></p>
<h3 id="请求-应答模式下的消息代理"><a href="#请求-应答模式下的消息代理" class="headerlink" title="请求-应答模式下的消息代理"></a>请求-应答模式下的消息代理</h3><p>这一节我们将对如何使用ØMQ消息信封做一个回顾，并尝试编写一个通用的消息代理装置。我们会建立一个队列装置来连接多个client和worker，装置的路由算法可以由我们自己决定。这里我们选择最近最少使用算法，因为这和负载均衡一样比较实用。</p>
<p>首先让我们回顾一下经典的请求-应答模型，尝试用它建立一个不断增长的巨型服务网络。最基本的请求-应答模型是：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_11.png" alt="11"></p>
<p>这个模型支持多个REP套接字，但如果我们想支持多个REQ套接字，就需要增加一个中间件，它通常是ROUTER和DEALER的结合体，简单将两个套接字之间的信息进行搬运，因此可以用现成的ZMQ_QUEUE装置来实现：</p>
<pre><code>+--------+  +--------+  +--------+
| Client |  | Client |  | Client |
+--------+  +--------+  +--------+
|  REQ   |  |  REQ   |  |  REQ   |
+---+----+  +---+----+  +---+----+
    |           |           |
    +-----------+-----------+
                |
            +---+----+
            | ROUTER |
            +--------+
            | Device |
            +--------+
            | DEALER |
            +---+----+
                |
    +-----------+-----------+
    |           |           |
+---+----+  +---+----+  +---+----+
|  REP   |  |  REP   |  |  REP   |
+--------+  +--------+  +--------+
| Worker |  | Worker |  | Worker |
+--------+  +--------+  +--------+


Figure # - Stretched request-reply
</code></pre><p>这种结构的关键在于，ROUTER会将消息来自哪个REQ记录下来，生成一个信封。DEALER和REP套接字在传输消息的过程中不会丢弃或更改信封的内容，这样当消息返回给ROUTER时，它就知道应该发送给哪个REQ了。这个模型中的REP套接字是匿名的，并没有特定的地址，所以只能提供同一种服务。</p>
<p>上述结构中，对REP的路由我们使用了DEADER自带的负载均衡算法。但是，我们想用LRU算法来进行路由，这就要用到ROUTER-REP模式：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_12.png" alt="12"></p>
<p>这个ROUTER-ROUTER的LRU队列不能简单地在两个套接字间搬运消息，以下代码会比较复杂，不过在请求-应答模式中复用性很高。</p>
<p><strong>lruqueue.c</strong></p>
<pre><code class="c">//
//  使用LRU算法的装置
//  client和worker处于不同的线程中
//
#include &quot;zhelpers.h&quot;
#include &lt;pthread.h&gt;

#define NBR_CLIENTS 10
#define NBR_WORKERS 3

//  出队操作，使用一个可存储任何类型的数组实现
#define DEQUEUE(q) memmove (&amp;(q)[0], &amp;(q)[1], sizeof (q) - sizeof (q [0]))

//  使用REQ套接字实现基本的请求-应答模式
//  由于s_send()和s_recv()不能处理0MQ的二进制套接字标识，
//  所以这里会生成一个可打印的字符串标识。
//
static void *
client_task (void *args)
{
    void *context = zmq_init (1);
    void *client = zmq_socket (context, ZMQ_REQ);
    s_set_id (client);          //  设置可打印的标识
    zmq_connect (client, &quot;ipc://frontend.ipc&quot;);

    //  发送请求并获取应答信息
    s_send (client, &quot;HELLO&quot;);
    char *reply = s_recv (client);
    printf (&quot;Client: %s\n&quot;, reply);
    free (reply);
    zmq_close (client);
    zmq_term (context);
    return NULL;
}

//  worker使用REQ套接字实现LRU算法
//
static void *
worker_task (void *args)
{
    void *context = zmq_init (1);
    void *worker = zmq_socket (context, ZMQ_REQ);
    s_set_id (worker);          //  设置可打印的标识
    zmq_connect (worker, &quot;ipc://backend.ipc&quot;);

    //  告诉代理worker已经准备好
    s_send (worker, &quot;READY&quot;);

    while (1) {
        //  将消息中空帧之前的所有内容（信封）保存起来，
        //  本例中空帧之前只有一帧，但可以有更多。
        char *address = s_recv (worker);
        char *empty = s_recv (worker);
        assert (*empty == 0);
        free (empty);

        //  获取请求，并发送回应
        char *request = s_recv (worker);
        printf (&quot;Worker: %s\n&quot;, request);
        free (request);

        s_sendmore (worker, address);
        s_sendmore (worker, &quot;&quot;);
        s_send     (worker, &quot;OK&quot;);
        free (address);
    }
    zmq_close (worker);
    zmq_term (context);
    return NULL;
}

int main (void)
{
    //  准备0MQ上下文和套接字
    void *context = zmq_init (1);
    void *frontend = zmq_socket (context, ZMQ_ROUTER);
    void *backend  = zmq_socket (context, ZMQ_ROUTER);
    zmq_bind (frontend, &quot;ipc://frontend.ipc&quot;);
    zmq_bind (backend,  &quot;ipc://backend.ipc&quot;);

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++) {
        pthread_t client;
        pthread_create (&amp;client, NULL, client_task, NULL);
    }
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++) {
        pthread_t worker;
        pthread_create (&amp;worker, NULL, worker_task, NULL);
    }
    //  LRU逻辑
    //  - 一直从backend中获取消息；当有超过一个worker空闲时才从frontend获取消息。
    //  - 当woker回应时，会将该worker标记为已准备好，并转发woker的回应给client
    //  - 如果client发送了请求，就将该请求转发给下一个worker

    //  存放可用worker的队列
    int available_workers = 0;
    char *worker_queue [10];

    while (1) {
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        zmq_poll (items, available_workers? 2: 1, -1);

        //  处理backend中worker的队列
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  将worker的地址入队
            char *worker_addr = s_recv (backend);
            assert (available_workers &lt; NBR_WORKERS);
            worker_queue [available_workers++] = worker_addr;

            //  跳过空帧

            char *empty = s_recv (backend);
            assert (empty [0] == 0);
            free (empty);

            // 第三帧是“READY”或是一个client的地址
            char *client_addr = s_recv (backend);

            //  如果是一个应答消息，则转发给client
            if (strcmp (client_addr, &quot;READY&quot;) != 0) {
                empty = s_recv (backend);
                assert (empty [0] == 0);
                free (empty);
                char *reply = s_recv (backend);
                s_sendmore (frontend, client_addr);
                s_sendmore (frontend, &quot;&quot;);
                s_send     (frontend, reply);
                free (reply);
                if (--client_nbr == 0)
                    break;      //  处理N条消息后退出
            }
            free (client_addr);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  获取下一个client的请求，交给空闲的worker处理
            //  client请求的消息格式是：[client地址][空帧][请求内容]
            char *client_addr = s_recv (frontend);
            char *empty = s_recv (frontend);
            assert (empty [0] == 0);
            free (empty);
            char *request = s_recv (frontend);

            s_sendmore (backend, worker_queue [0]);
            s_sendmore (backend, &quot;&quot;);
            s_sendmore (backend, client_addr);
            s_sendmore (backend, &quot;&quot;);
            s_send     (backend, request);

            free (client_addr);
            free (request);

            //  将该worker的地址出队
            free (worker_queue [0]);
            DEQUEUE (worker_queue);
            available_workers--;
        }
    }
    zmq_close (frontend);
    zmq_close (backend);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这段程序有两个关键点：1、各个套接字是如何处理信封的；2、LRU算法。我们先来看信封的格式。</p>
<p>我们知道REQ套接字在发送消息时会向头部添加一个空帧，接收时又会自动移除。我们要做的就是在传输消息时满足REQ的要求，处理好空帧。另外还要注意，ROUTER会在所有收到的消息前添加消息来源的地址。</p>
<p>现在我们就将完整的请求-应答流程走一遍，我们将client套接字的标识设为“CLIENT”，worker的设为“WORKER”。以下是client发送的消息：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_13.png" alt="13"></p>
<p>代理从ROUTER中获取到的消息格式如下：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_14.png" alt="14"></p>
<p>代理会从LRU队列中获取一个空闲woker的地址，作为信封附加在消息之上，传送给ROUTER。注意要添加一个空帧。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_15.png" alt="15"></p>
<p>REQ（worker）收到消息时，会将信封和空帧移去：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_16.png" alt="16"></p>
<p>可以看到，worker收到的消息和client端ROUTER收到的消息是一致的。worker需要将该消息中的信封保存起来，只对消息内容做操作。</p>
<p>在返回的过程中：</p>
<ul>
<li>worker通过REQ传输给device消息[client地址][空帧][应答内容]；</li>
<li>device从worker端的ROUTER中获取到[worker地址][空帧][client地址][空帧][应答内容]；</li>
<li>device将worker地址保存起来，并发送[client地址][空帧][应答内容]给client端的ROUTER；</li>
<li>client从REQ中获得到[应答内容]。</li>
</ul>
<p>然后再看看LRU算法，它要求client和worker都使用REQ套接字，并正确的存储和返回消息信封，具体如下：</p>
<ul>
<li><p>创建一组poll，不断地从backend（worker端的ROUTER）获取消息；只有当有空闲的worker时才从frontend（client端的ROUTER）获取消息；</p>
</li>
<li><p>循环执行poll</p>
</li>
<li><p>如果backend有消息，只有两种情况：1）READY消息（该worker已准备好，等待分配）；2）应答消息（需要转发给client）。两种情况下我们都会保存worker的地址，放入LRU队列中，如果有应答内容，则转发给相应的client。</p>
</li>
<li><p>如果frontend有消息，我们从LRU队列中取出下一个worker，将该请求发送给它。这就需要发送[worker地址][空帧][client地址][空帧][请求内容]到worker端的ROUTER。</p>
</li>
</ul>
<p>我们可以对该算法进行扩展，如在worker启动时做一个自我测试，计算出自身的处理速度，并随READY消息发送给代理，这样代理在分配工作时就可以做相应的安排。</p>
<h3 id="OMQ上层API的封装"><a href="#OMQ上层API的封装" class="headerlink" title="ØMQ上层API的封装"></a>ØMQ上层API的封装</h3><p>使用ØMQ提供的API操作多段消息时是很麻烦的，如以下代码：</p>
<pre><code class="c">while (1) {
    //  将消息中空帧之前的所有内容（信封）保存起来，
    //  本例中空帧之前只有一帧，但可以有更多。
    char *address = s_recv (worker);
    char *empty = s_recv (worker);
    assert (*empty == 0);
    free (empty);

    //  获取请求，并发送回应
    char *request = s_recv (worker);
    printf (&quot;Worker: %s\n&quot;, request);
    free (request);
    s_sendmore (worker, address);
    s_sendmore (worker, &quot;&quot;);
    s_send     (worker, &quot;OK&quot;);
    free (address);
}
</code></pre>
<p>这段代码不满足重用的需求，因为它只能处理一个帧的信封。事实上，以上代码已经做了一些封装了，如果调用ØMQ底层的API的话，代码就会更加冗长：</p>
<pre><code class="c">while (1) {
    //  将消息中空帧之前的所有内容（信封）保存起来，
    //  本例中空帧之前只有一帧，但可以有更多。
    zmq_msg_t address;
    zmq_msg_init (&amp;address);
    zmq_recv (worker, &amp;address, 0);

    zmq_msg_t empty;
    zmq_msg_init (&amp;empty);
    zmq_recv (worker, &amp;empty, 0);

    //  获取请求，并发送回应
    zmq_msg_t payload;
    zmq_msg_init (&amp;payload);
    zmq_recv (worker, &amp;payload, 0);

    int char_nbr;
    printf (&quot;Worker: &quot;);
    for (char_nbr = 0; char_nbr &lt; zmq_msg_size (&amp;payload); char_nbr++)
        printf (&quot;%c&quot;, *(char *) (zmq_msg_data (&amp;payload) + char_nbr));
    printf (&quot;\n&quot;);

    zmq_msg_init_size (&amp;payload, 2);
    memcpy (zmq_msg_data (&amp;payload), &quot;OK&quot;, 2);

    zmq_send (worker, &amp;address, ZMQ_SNDMORE);
    zmq_close (&amp;address);
    zmq_send (worker, &amp;empty, ZMQ_SNDMORE);
    zmq_close (&amp;empty);
    zmq_send (worker, &amp;payload, 0);
    zmq_close (&amp;payload);
}
</code></pre>
<p>我们理想中的API是可以一步接收和处理完整的消息，包括信封。ØMQ底层的API并不是为此而涉及的，但我们可以在它上层做进一步的封装，这也是学习ØMQ的过程中很重要的内容。</p>
<p>想要编写这样一个API还是很有难度的，因为我们要避免过于频繁地复制数据。此外，ØMQ用“消息”来定义多段消息和多段消息中的一部分，同时，消息又可以是字符串消息或者二进制消息，这也给编写API增加的难度。</p>
<p>解决方法之一是使用新的命名方式：字符串（s_send()和s_recv()中已经在用了）、帧（消息的一部分）、消息（一个或多个帧）。以下是用新的API重写的worker：</p>
<pre><code class="c">while (1) {
    zmsg_t *zmsg = zmsg_recv (worker);
    zframe_print (zmsg_last (zmsg), &quot;Worker: &quot;);
    zframe_reset (zmsg_last (zmsg), &quot;OK&quot;, 2);
    zmsg_send (&amp;zmsg, worker);
}
</code></pre>
<p>用4行代码代替22行代码是个不错的选择，而且更容易读懂。我们可以用这种理念继续编写其他的API，希望可以实现以下功能：</p>
<ul>
<li><p>自动处理套接字。每次都要手动关闭套接字是很麻烦的事，手动定义过期时间也不是太有必要，所以，如果能在关闭上下文时自动关闭套接字就太好了。</p>
</li>
<li><p>便捷的线程管理。基本上所有的ØMQ应用都会用到多线程，但POSIX的多线程接口用起来并不是太方便，所以也可以封装一下。</p>
</li>
<li><p>便捷的时钟管理。想要获取毫秒数、或是暂停运行几毫秒都不太方便，我们的API应该提供这个接口。</p>
</li>
<li><p>一个能够替代zmq_poll()的反应器。poll循环很简单，但比较笨拙，会造成重复代码：计算时间、处理套接字中的信息等。若有一个简单的反应器来处理套接字的读写以及时间的控制，将会很方便。</p>
</li>
<li><p>恰当地处理Ctrl-C按键。我么已经看到如何处理中断了，最好这一机制可以用到所有的程序里。</p>
</li>
</ul>
<p>我们可以用czmq来实现以上的需求。这个扩展很早就有了，提供了很多ØMQ的上层封装，甚至是数据结构（哈希、链表等）。</p>
<p>以下是用czmq重写的LRU代理：</p>
<p><strong>lruqueue2.c</strong></p>
<pre><code class="c">//
//  LRU消息队列装置，使用czmq库实现
//
#include &quot;czmq.h&quot;

#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define LRU_READY   &quot;\001&quot;      //  worker准备就绪的信息

//  使用REQ套接字实现基本的请求-应答模式
//
static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, &quot;ipc://frontend.ipc&quot;);

    //  发送请求并接收应答
    while (1) {
        zstr_send (client, &quot;HELLO&quot;);
        char *reply = zstr_recv (client);
        if (!reply)
            break;
        printf (&quot;Client: %s\n&quot;, reply);
        free (reply);
        sleep (1);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  worker使用REQ套接字，实现LRU路由
//
static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, &quot;ipc://backend.ipc&quot;);

    //  告知代理worker已准备就绪
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  接收消息并处理
    while (1) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  终止
        //zframe_print (zmsg_last (msg), &quot;Worker: &quot;);
        zframe_reset (zmsg_last (msg), &quot;OK&quot;, 2);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

int main (void)
{
    zctx_t *ctx = zctx_new ();
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    void *backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, &quot;ipc://frontend.ipc&quot;);
    zsocket_bind (backend, &quot;ipc://backend.ipc&quot;);

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (ctx, client_task, NULL);
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (ctx, worker_task, NULL);

    //  LRU逻辑
    //  - 一直从backend中获取消息；当有超过一个worker空闲时才从frontend获取消息。
    //  - 当woker回应时，会将该worker标记为已准备好，并转发woker的回应给client
    //  - 如果client发送了请求，就将该请求转发给下一个worker

    //  存放可用worker的队列
    zlist_t *workers = zlist_new ();

    while (1) {
        //  初始化poll
        zmq_pollitem_t items [] = {
            { backend,  0, ZMQ_POLLIN, 0 },
            { frontend, 0, ZMQ_POLLIN, 0 }
        };
        //  当有可用的worker时，从frontend获取消息
        int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);
        if (rc == -1)
            break;              //  中断

        //  对backend发来的消息进行处理
        if (items [0].revents &amp; ZMQ_POLLIN) {
            //  使用worker的地址进行LRU路由
            zmsg_t *msg = zmsg_recv (backend);
            if (!msg)
                break;          //  中断
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);

            //  如果不是READY消息，则转发给client
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
            else
                zmsg_send (&amp;msg, frontend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            //  获取client发来的请求，转发给worker
            zmsg_t *msg = zmsg_recv (frontend);
            if (msg) {
                zmsg_wrap (msg, (zframe_t *) zlist_pop (workers));
                zmsg_send (&amp;msg, backend);
            }
        }
    }
    //  如果完成了，则进行一些清理工作
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>czmq提供了一个简单的中断机制，当按下Ctrl-C时程序会终止ØMQ的运行，并返回-1，errno设置为EINTR。程序中断时，czmq的recv方法会返回NULL，所以你可以用下面的代码来作判断：</p>
<pre><code class="c">while (1) {
    zstr_send (client, &quot;HELLO&quot;);
    char *reply = zstr_recv (client);
    if (!reply)
        break; // 中断
    printf (&quot;Client: %s\n&quot;, reply);
    free (reply);
    sleep (1);
}
</code></pre>
<p>如果使用zmq_poll()函数，则可以这样判断：</p>
<pre><code>int rc = zmq_poll (items, zlist_size (workers)? 2: 1, -1);
if (rc == -1)
    break; // 中断
</code></pre><p>上例中还是使用了原生的zmq_poll()方法，也可以使用czmq提供的zloop反应器来实现，它可以做到：</p>
<ul>
<li>从任意套接字上获取消息，也就是说只要套接字有消息就可以触发函数；</li>
<li>停止读取套接字上的消息；</li>
<li>设置一个时钟，定时地读取消息。</li>
</ul>
<p>zloop内部当然是使用zmq_poll()实现的，但它可以做到动态地增减套接字上的监听器，重构poll池，并根据poll的超时时间来计算下一个时钟触发事件。</p>
<p>使用这种反应器模式后，我们的代码就更简洁了：</p>
<pre><code class="c">zloop_t *reactor = zloop_new ();
zloop_reader (reactor, self-&gt;backend, s_handle_backend, self);
zloop_start (reactor);
zloop_destroy (&amp;reactor);
</code></pre>
<p>对消息的实际处理放在了程序的其他部分，并不是所有人都会喜欢这种风格，但zloop的确是将定时器和套接字的行为融合在了一起。在以后的例子中，我们会用zmq_poll()来处理简单的示例，使用zloop来处理复杂的。</p>
<p>下面我们用zloop来重写LRU队列装置</p>
<p><strong>lruqueue3.c</strong></p>
<pre><code class="c">//
//  LRU队列装置，使用czmq及其反应器模式实现
//
#include &quot;czmq.h&quot;

#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define LRU_READY   &quot;\001&quot;      //  woker已准备就绪的消息

//  使用REQ实现基本的请求-应答模式
//
static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, &quot;ipc://frontend.ipc&quot;);

    //  发送请求并接收应答
    while (1) {
        zstr_send (client, &quot;HELLO&quot;);
        char *reply = zstr_recv (client);
        if (!reply)
            break;
        printf (&quot;Client: %s\n&quot;, reply);
        free (reply);
        sleep (1);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  worker使用REQ套接字来实现路由
//
static void *
worker_task (void *arg_ptr)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, &quot;ipc://backend.ipc&quot;);

    //  告诉代理worker已经准备就绪
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  获取消息并处理
    while (1) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  中断
        //zframe_print (zmsg_last (msg), &quot;Worker: &quot;);
        zframe_reset (zmsg_last (msg), &quot;OK&quot;, 2);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  LRU队列处理器结构，将要传给反应器
typedef struct {
    void *frontend;             //  监听client
    void *backend;              //  监听worker
    zlist_t *workers;           //  可用的worker列表
} lruqueue_t;


//  处理frontend端的消息
int s_handle_frontend (zloop_t *loop, void *socket, void *arg)
{
    lruqueue_t *self = (lruqueue_t *) arg;
    zmsg_t *msg = zmsg_recv (self-&gt;frontend);
    if (msg) {
        zmsg_wrap (msg, (zframe_t *) zlist_pop (self-&gt;workers));
        zmsg_send (&amp;msg, self-&gt;backend);

        //  如果没有可用的worker，则停止监听frontend
        if (zlist_size (self-&gt;workers) == 0)
            zloop_cancel (loop, self-&gt;frontend);
    }
    return 0;
}

//  处理backend端的消息
int s_handle_backend (zloop_t *loop, void *socket, void *arg)
{
    //  使用worker的地址进行LRU路由
    lruqueue_t *self = (lruqueue_t *) arg;
    zmsg_t *msg = zmsg_recv (self-&gt;backend);
    if (msg) {
        zframe_t *address = zmsg_unwrap (msg);
        zlist_append (self-&gt;workers, address);

        //  当有可用worker时增加frontend端的监听
        if (zlist_size (self-&gt;workers) == 1)
            zloop_reader (loop, self-&gt;frontend, s_handle_frontend, self);

        //  如果是worker发送来的应答，则转发给client
        zframe_t *frame = zmsg_first (msg);
        if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
            zmsg_destroy (&amp;msg);
        else
            zmsg_send (&amp;msg, self-&gt;frontend);
    }
    return 0;
}

int main (void)
{
    zctx_t *ctx = zctx_new ();
    lruqueue_t *self = (lruqueue_t *) zmalloc (sizeof (lruqueue_t));
    self-&gt;frontend = zsocket_new (ctx, ZMQ_ROUTER);
    self-&gt;backend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (self-&gt;frontend, &quot;ipc://frontend.ipc&quot;);
    zsocket_bind (self-&gt;backend, &quot;ipc://backend.ipc&quot;);

    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (ctx, client_task, NULL);
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (ctx, worker_task, NULL);

    //  可用worker的列表
    self-&gt;workers = zlist_new ();

    //  准备并启动反应器
    zloop_t *reactor = zloop_new ();
    zloop_reader (reactor, self-&gt;backend, s_handle_backend, self);
    zloop_start (reactor);
    zloop_destroy (&amp;reactor);

    //  结束之后的清理工作
    while (zlist_size (self-&gt;workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (self-&gt;workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;self-&gt;workers);
    zctx_destroy (&amp;ctx);
    free (self);
    return 0;
}
</code></pre>
<p>要正确处理Ctrl-C还是有点困难的，如果你使用zctx类，那它会自动进行处理，不过也需要代码的配合。若zmq_poll()返回了-1，或者recv方法（zstr_recv, zframe_recv, zmsg_recv）返回了NULL，就必须退出所有的循环。另外，在最外层循环中增加!zctx_interrupted的判断也很有用。</p>
<h3 id="异步C-S结构"><a href="#异步C-S结构" class="headerlink" title="异步C/S结构"></a>异步C/S结构</h3><p>在之前的ROUTER-DEALER模型中，我们看到了client是如何异步地和多个worker进行通信的。我们可以将这个结构倒置过来，实现多个client异步地和单个server进行通信：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_17.png" alt="17"></p>
<ul>
<li>client连接至server并发送请求；</li>
<li>每一次收到请求，server会发送0至N个应答；</li>
<li>client可以同时发送多个请求而不需要等待应答；</li>
<li>server可以同时发送多个应答二不需要新的请求。</li>
</ul>
<p><strong>asyncsrd.c</strong></p>
<pre><code class="c">//
//  异步C/S模型（DEALER-ROUTER）
// 

#include &quot;czmq.h&quot;

//  ---------------------------------------------------------------------
//  这是client端任务，它会连接至server，每秒发送一次请求，同时收集和打印应答消息。
//  我们会运行多个client端任务，使用随机的标识。

static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_DEALER);

    //  设置随机标识，方便跟踪
    char identity [10];
    sprintf (identity, &quot;%04X-%04X&quot;, randof (0x10000), randof (0x10000));
    zsockopt_set_identity (client, identity);
    zsocket_connect (client, &quot;tcp://localhost:5570&quot;);

    zmq_pollitem_t items [] = { { client, 0, ZMQ_POLLIN, 0 } };
    int request_nbr = 0;
    while (1) {
        //  从poll中获取消息，每秒一次
        int centitick;
        for (centitick = 0; centitick &lt; 100; centitick++) {
            zmq_poll (items, 1, 10 * ZMQ_POLL_MSEC);
            if (items [0].revents &amp; ZMQ_POLLIN) {
                zmsg_t *msg = zmsg_recv (client);
                zframe_print (zmsg_last (msg), identity);
                zmsg_destroy (&amp;msg);
            }
        }
        zstr_sendf (client, &quot;request #%d&quot;, ++request_nbr);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  ---------------------------------------------------------------------
//  这是server端任务，它使用多线程机制将请求分发给多个worker，并正确返回应答信息。
//  一个worker只能处理一次请求，但client可以同时发送多个请求。

static void server_worker (void *args, zctx_t *ctx, void *pipe);

void *server_task (void *args)
{
    zctx_t *ctx = zctx_new ();

    //  frontend套接字使用TCP和client通信
    void *frontend = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (frontend, &quot;tcp://*:5570&quot;);

    //  backend套接字使用inproc和worker通信
    void *backend = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_bind (backend, &quot;inproc://backend&quot;);

    //  启动一个worker线程池，数量任意
    int thread_nbr;
    for (thread_nbr = 0; thread_nbr &lt; 5; thread_nbr++)
        zthread_fork (ctx, server_worker, NULL);

    //  使用队列装置连接backend和frontend，我们本来可以这样做：
    //      zmq_device (ZMQ_QUEUE, frontend, backend);
    //  但这里我们会自己完成这个任务，这样可以方便调试。

    //  在frontend和backend间搬运消息
    while (1) {
        zmq_pollitem_t items [] = {
            { frontend, 0, ZMQ_POLLIN, 0 },
            { backend,  0, ZMQ_POLLIN, 0 }
        };
        zmq_poll (items, 2, -1);
        if (items [0].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (frontend);
            //puts (&quot;Request from client:&quot;);
            //zmsg_dump (msg);
            zmsg_send (&amp;msg, backend);
        }
        if (items [1].revents &amp; ZMQ_POLLIN) {
            zmsg_t *msg = zmsg_recv (backend);
            //puts (&quot;Reply from worker:&quot;);
            //zmsg_dump (msg);
            zmsg_send (&amp;msg, frontend);
        }
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  接收一个请求，随机返回多条相同的文字，并在应答之间做随机的延迟。
//
static void
server_worker (void *args, zctx_t *ctx, void *pipe)
{
    void *worker = zsocket_new (ctx, ZMQ_DEALER);
    zsocket_connect (worker, &quot;inproc://backend&quot;);

    while (1) {
        //  DEALER套接字将信封和消息内容一起返回给我们
        zmsg_t *msg = zmsg_recv (worker);
        zframe_t *address = zmsg_pop (msg);
        zframe_t *content = zmsg_pop (msg);
        assert (content);
        zmsg_destroy (&amp;msg);

        //  随机返回0至4条应答
        int reply, replies = randof (5);
        for (reply = 0; reply &lt; replies; reply++) {
            //  暂停一段时间
            zclock_sleep (randof (1000) + 1);
            zframe_send (&amp;address, worker, ZFRAME_REUSE + ZFRAME_MORE);
            zframe_send (&amp;content, worker, ZFRAME_REUSE);
        }
        zframe_destroy (&amp;address);
        zframe_destroy (&amp;content);
    }
}


//  主程序用来启动多个client和一个server
//
int main (void)
{
    zctx_t *ctx = zctx_new ();
    zthread_new (ctx, client_task, NULL);
    zthread_new (ctx, client_task, NULL);
    zthread_new (ctx, client_task, NULL);
    zthread_new (ctx, server_task, NULL);

    //  运行5秒后退出
    zclock_sleep (5 * 1000);
    zctx_destroy (&amp;ctx);
    return 0;
}
</code></pre>
<p>运行上面的代码，可以看到三个客户端有各自的随机标识，每次请求会获得零到多条回复。</p>
<ul>
<li><p>client每秒会发送一次请求，并获得零到多条应答。这要通过zmq_poll()来实现，但我们不能只每秒poll一次，这样将不能及时处理应答。程序中我们每秒取100次，这样一来server端也可以以此作为一种心跳（heartbeat），用来检测client是否还在线。</p>
</li>
<li><p>server使用了一个worker池，每一个worker同步处理一条请求。我们可以使用内置的队列来搬运消息，但为了方便调试，在程序中我们自己实现了这一过程。你可以将注释的几行去掉，看看输出结果。</p>
</li>
</ul>
<p>这段代码的整体架构如下图所示：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_18.png" alt="18"></p>
<p>可以看到，client和server之间的连接我们使用的是DEALER-ROUTER，而server和worker的连接则用了DEALER-DEALER。如果worker是一个同步的线程，我们可以用REP。但是本例中worker需要能够发送多个应答，所以就需要使用DEALER这样的异步套接字。这里我们不需要对应答进行路由，因为所有的worker都是连接到一个server上的。</p>
<p>让我们看看路由用的信封，client发送了一条信息，server获取的信息中包含了client的地址，这样一来我们有两种可行的server-worker通信方案：</p>
<ul>
<li><p>worker收到未经标识的信息。我们使用显式声明的标识，配合ROUTER套接字来连接worker和server。这种设计需要worker提前告知ROUTER它的存在，这种LRU算法正是我们之前所讲述的。</p>
</li>
<li><p>worker收到含有标识的信息，并返回含有标识的应答。这就要求worker能够处理好信封。</p>
</li>
</ul>
<p>第二种涉及较为简单：</p>
<pre><code>     client          server       frontend       worker
   [ DEALER ]&lt;----&gt;[ ROUTER &lt;----&gt; DEALER &lt;----&gt; DEALER ]
             1 part         2 parts       2 parts
</code></pre><p>当我们需要在client和server之间维持一个对话时，就会碰到一个经典的问题：client是不固定的，如果给每个client都保存一些消息，那系统资源很快就会耗尽。即使是和同一个client保持连接，因为使用的是瞬时的套接字（没有显式声明标识），那每次连接也相当于是一个新的连接。</p>
<p>想要在异步的请求中保存好client的信息，有以下几点需要注意：</p>
<ul>
<li>client需要发送心跳给server。本例中client每秒都会发送一个请求给server，这就是一种很可靠的心跳机制。</li>
<li>使用client的套接字标识来存储信息，这对瞬时和持久的套接字都有效；</li>
<li>检测停止心跳的client，如两秒内没有收到某个client的心跳，就将保存的状态丢弃。</li>
</ul>
<h3 id="实战：跨代理路由"><a href="#实战：跨代理路由" class="headerlink" title="实战：跨代理路由"></a>实战：跨代理路由</h3><p>让我们把目前所学到的知识综合起来，应用到实战中去。我们的大客户今天打来一个紧急电话，说是要构建一个大型的云计算设施。它要求这个云架构可以跨越多个数据中心，每个数据中心包含一组client和worker，且能共同协作。</p>
<p>我们坚信实践高于理论，所以就提议使用ZMQ搭建这样一个系统。我们的客户同意了，可能是因为他的确也想降低开发的成本，或是在推特上看到了太多ZMQ的好处。</p>
<h4 id="细节详述"><a href="#细节详述" class="headerlink" title="细节详述"></a>细节详述</h4><p>喝完几杯特浓咖啡，我们准备着手干了，但脑中有个理智的声音提醒我们应该在事前将问题分析清楚，然后再开始思考解决方案。云到底要做什么？我们如是问，客户这样回答：</p>
<ul>
<li><p>worker在不同的硬件上运作，但可以处理所有类型的任务。每个集群都有成百个worker，再乘以集群的个数，因此数量众多。</p>
</li>
<li><p>client向worker指派任务，每个任务都是独立的，每个client都希望能找到对应的worker来处理任务，越快越好。client是不固定的，来去频繁。</p>
</li>
<li><p>真正的难点在于，这个架构需要能够自如地添加和删除集群，附带着集群中的client和worker。</p>
</li>
<li><p>如果集群中没有可用的worker，它便会将任务分派给其他集群中可以用的worker。</p>
</li>
<li><p>client每次发送一个请求，并等待应答。如果X秒后他们没有获得应答，他们会重新发送请求。这一点我们不需要多做考虑，client端的API已经写好了。</p>
</li>
<li><p>worker每次处理一个请求，他们的行为非常简单。如果worker崩溃了，会有另外的脚本启动他们。</p>
</li>
</ul>
<p>听了以上的回答，我们又进一步追问：</p>
<ul>
<li><p>集群之间会有一个更上层的网络来连接他们对吗？客户说是的。</p>
</li>
<li><p>我们需要处理多大的吞吐量？客户说，每个集群约有一千个client，单个client每秒会发送10次请求。请求包含的内容很少，应答也很少，每个不超过1KB。</p>
</li>
</ul>
<p>我们进行了简单的计算，2500个client x 10次/秒 x 1000字节 x 双向 = 50MB/秒，或400Mb/秒，这对1Gb网络来说不成问题，可以使用TCP协议。</p>
<p>这样需求就很清晰了，不需要额外的硬件或协议来完成这件事，只要提供一个高效的路由算法，设计得缜密一些。我们首先从一个集群（数据中心）开始，然后思考如何来连接他们。</p>
<h4 id="单个集群的架构"><a href="#单个集群的架构" class="headerlink" title="单个集群的架构"></a>单个集群的架构</h4><p>worker和client是同步的，我们使用LRU算法来给worker分配任务。每个worker都是等价的，所以我们不需要考虑服务的问题。worker是匿名的，client不会和某个特定的worker进行通信，因而我们不需要保证消息的送达以及失败后的重试等。</p>
<p>鉴于上文提过的原因，client和worker是不会直接通信的，这样一来就无法动态地添加和删除节点了。所以，我们的基础模型会使用一个请求-应答模式中使用过的代理结构。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_19.png" alt="19"></p>
<h4 id="多个集群的架构"><a href="#多个集群的架构" class="headerlink" title="多个集群的架构"></a>多个集群的架构</h4><p>下面我们将集群扩充到多个，每个集群有自己的一组client和worker，并使用代理相连接：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_20.png" alt="20"></p>
<p>问题在于：我们如何让一个集群的client和另一个集群的worker进行通信呢？有这样几种解决方案，我们来看看他们的优劣：</p>
<ul>
<li><p>client直接和多个代理相连接。优点在于我们可以不对代理和worker做改动，但client会变得复杂，并需要知悉整个架构的情况。如果我们想要添加第三或第四个集群，所有的client都会需要修改。我们相当于是将路由和容错功能写进client了，这并不是个好主意。</p>
</li>
<li><p>worker直接和多个代理相连接。可是REQ类型的worker不能做到这一点，它只能应答给某一个代理。如果改用REP套接字，这样就不能使用LRU算法的队列代理了。这点肯定不行，在我们的结构中必须用LRU算法来管理worker。还有个方法是使用ROUTER套接字，让我们暂且称之为方案1。</p>
</li>
<li><p>代理之间可以互相连接，这看上去不错，因为不需要增加过多的额外连接。虽然我们不能随意地添加代理，但这个问题可以暂不考虑。这种情况下，集群中的worker和client不必理会整体架构，当代理有剩余的工作能力时便会和其他代理通信。这是方案2。</p>
</li>
</ul>
<p>我们首先看看方案1，worker同时和多个代理进行通信：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_21.png" alt="21"></p>
<p>这看上去很灵活，但却没有提供我们所需要的特性：client只有当集群中的worker不可用时才会去请求异地的worker。此外，worker的“已就绪”信号会同时发送给两个代理，这样就有可能同时获得两份任务。这个方案的失败还有一个原因：我们又将路由逻辑放在了边缘地带。</p>
<p>那来看看方案2，我们为各个代理建立连接，不修改worker和client：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_22.png" alt="22"></p>
<p>这种设计的优势在于，我们只需要在一个地方解决问题就可以了，其他地方不需要修改。这就好像代理之间会秘密通信：伙计，我这儿有一些剩余的劳动力，如果你那儿忙不过来就跟我说，价钱好商量。</p>
<p>事实上，我们只不过是需要设计一种更为复杂的路由算法罢了：代理成为了其他代理的分包商。这种设计还有其他一些好处：</p>
<ul>
<li><p>在普通情况下（如只存在一个集群），这种设计的处理方式和原来没有区别，当有多个集群时再进行其他动作。</p>
</li>
<li><p>对于不同的工作我们可以使用不同的消息流模式，如使用不同的网络链接。</p>
</li>
<li><p>架构的扩充看起来也比较容易，如有必要我们还可以添加一个超级代理来完成调度工作。</p>
</li>
</ul>
<p>现在我们就开始编写代码。我们会将完整的集群写入一个进程，这样便于演示，而且稍作修改就能投入实际使用。这也是ZMQ的优美之处，你可以使用最小的开发模块来进行实验，最后方便地迁移到实际工程中。线程变成进程，消息模式和逻辑不需要改变。我们每个“集群”进程都包含client线程、worker线程、以及代理线程。</p>
<p>我们对基础模型应该已经很熟悉了：</p>
<ul>
<li>client线程使用REQ套接字，将请求发送给代理线程（ROUTER套接字）；</li>
<li>worker线程使用REQ套接字，处理并应答从代理线程（ROUTER套接字）收到的请求；</li>
<li>代理会使用LRU队列和路由机制来管理请求。</li>
</ul>
<h4 id="联邦模式和同伴模式"><a href="#联邦模式和同伴模式" class="headerlink" title="联邦模式和同伴模式"></a>联邦模式和同伴模式</h4><p>连接代理的方式有很多，我们需要斟酌一番。我们需要的功能是告诉其他代理“我这里还有空闲的worker”，然后开始接收并处理一些任务；我们还需要能够告诉其他代理“够了够了，我这边的工作量也满了”。这个过程不一定要十分完美，有时我们确实会接收超过承受能力的工作量，但仍能逐步地完成。</p>
<p>最简单的方式称为联邦，即代理充当其他代理的client和worker。我们可以将代理的前端套接字连接至其他代理的后端套接字，反之亦然。提示一下，ZMQ中是可以将一个套接字绑定到一个端点，同时又连接至另一个端点的。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_23.png" alt="23"></p>
<p>这种架构的逻辑会比较简单：当代理没有client时，它会告诉其他代理自己准备好了，并接收一个任务进行处理。但问题在于这种机制太简单了，联邦模式下的代理一次只能处理一个请求。如果client和worker是严格同步的，那么代理中的其他空闲worker将分配不到任务。我们需要的代理应该具备完全异步的特性。</p>
<p>但是，联邦模式对某些应用来说是非常好的，比如面向服务架构（SOA）。所以，先不要急着否定联邦模式，它只是不适用于LRU算法和集群负载均衡而已。</p>
<p>我们还有一种方式来连接代理：同伴模式。代理之间知道彼此的存在，并使用一个特殊的信道进行通信。我们逐步进行分析，假设有N个代理需要连接，每个代理则有N-1个同伴，所有代理都使用相同格式的消息进行通信。关于消息在代理之间的流通有两点需要注意：</p>
<ul>
<li><p>每个代理需要告知所有同伴自己有多少空闲的worker，这是一则简单的消息，只是一个不断更新的数字，很显然我们会使用PUB-SUB套接字。这样一来，每个代理都会打开一个PUB套接字，不断告知外界自身的信息；同时又会打开一个SUB套接字，获取其他代理的信息。</p>
</li>
<li><p>每个代理需要以某种方式将工作任务交给其他代理，并能获取应答，这个过程需要是异步的。我们会使用ROUTER-ROUTER套接字来实现，没有其他选择。每个代理会使用两个这样的ROUTER套接字，一个用于接收任务，另一个用于分发任务。如果不使用两个套接字，那就需要额外的逻辑来判别收到的是请求还是应答，这就需要在消息中加入更多的信息。</p>
</li>
</ul>
<p>另外还需要考虑的是代理和本地client和worker之间的通信。</p>
<h4 id="The-Naming-Ceremony"><a href="#The-Naming-Ceremony" class="headerlink" title="The Naming Ceremony"></a>The Naming Ceremony</h4><p>代理中有三个消息流，每个消息流使用两个套接字，因此一共需要使用六个套接字。为这些套接字取一组好名字很重要，这样我们就不会在来回切换的时候找不着北。套接字是有一定任务的，他们的所完成的工作可以是命名的一部分。这样，当我们日后再重新阅读这些代码时，就不会显得太过陌生了。</p>
<p>以下是我们使用的三个消息流：</p>
<ul>
<li>本地（local）的请求-应答消息流，实现代理和client、代理和worker之间的通信；</li>
<li>云端（cloud）的请求-应答消息流，实现代理和其同伴的通信；</li>
<li>状态（state）流，由代理和其同伴互相传递。</li>
</ul>
<p>能够找到一些有意义的、且长度相同的名字，会让我们的代码对得比较整齐。可能他们并没有太多关联，但久了自然会习惯。</p>
<p>每个消息流会有两个套接字，我们之前一直称为“前端（frontend）”和“后端（backend）”。这两个名字我们已经使用很多次了：前端会负责接受信息或任务；后端会发送信息或任务给同伴。从概念上说，消息流都是从前往后的，应答则是从后往前。</p>
<p>因此，我们决定使用以下的命名方式：</p>
<ul>
<li>localfe / localbe</li>
<li>cloudfe / cloudbe</li>
<li>statefe / statebe</li>
</ul>
<p>通信协议方面，我们全部使用ipc。使用这种协议的好处是，它能像tcp协议那样作为一种脱机通信协议来工作，而又不需要使用IP地址或DNS服务。对于ipc协议的端点，我们会命名为xxx-localfe/be、xxx-cloud、xxx-state，其中xxx代表集群的名称。</p>
<p>也许你会觉得这种命名方式太长了，还不如简单的叫s1、s2、s3……事实上，你的大脑并不是机器，阅读代码的时候不能立刻反应出变量的含义。而用上面这种“三个消息流，两个方向”的方式记忆，要比纯粹记忆“六个不同的套接字”来的方便。</p>
<p>以下是代理程序的套接字分布图：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_24.png" alt="24"></p>
<p>请注意，我们会将cloudbe连接至其他代理的cloudfe，也会将statebe连接至其他代理的statefe。</p>
<h4 id="状态流原型"><a href="#状态流原型" class="headerlink" title="状态流原型"></a>状态流原型</h4><p>由于每个消息流都有其巧妙之处，所以我们不会直接把所有的代码都写出来，而是分段编写和测试。当每个消息流都能正常工作了，我们再将其拼装成一个完整的应用程序。我们首先从状态流开始：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_25.png" alt="25"></p>
<p>代码如下：</p>
<p><strong>peering1: Prototype state flow in C</strong></p>
<pre><code class="c">//
//  代理同伴模拟（第一部分）
//  状态流原型
//
#include &quot;czmq.h&quot;

int main (int argc, char *argv [])
{
    //  第一个参数是代理的名称
    //  其他参数是各个同伴的名称
    //
    if (argc &lt; 2) {
        printf (&quot;syntax: peering1 me {you}...\n&quot;);
        exit (EXIT_FAILURE);
    }
    char *self = argv [1];
    printf (&quot;I: 正在准备代理程序 %s...\n&quot;, self);
    srandom ((unsigned) time (NULL));

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    void *statebe = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (statebe, &quot;ipc://%s-state.ipc&quot;, self);

    //  连接statefe套接字至所有同伴
    void *statefe = zsocket_new (ctx, ZMQ_SUB);
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf (&quot;I: 正在连接至同伴代理 &#39;%s&#39; 的状态流后端\n&quot;, peer);
        zsocket_connect (statefe, &quot;ipc://%s-state.ipc&quot;, peer);
    }
    //  发送并接受状态消息
    //  zmq_poll()函数使用的超时时间即心跳时间
    //
    while (1) {
        //  初始化poll对象列表
        zmq_pollitem_t items [] = {
            { statefe, 0, ZMQ_POLLIN, 0 }
        };
        //  轮询套接字活动，超时时间为1秒
        int rc = zmq_poll (items, 1, 1000 * ZMQ_POLL_MSEC);
        if (rc == -1)
            break;              //  中断

        //  处理接收到的状态消息
        if (items [0].revents &amp; ZMQ_POLLIN) {
            char *peer_name = zstr_recv (statefe);
            char *available = zstr_recv (statefe);
            printf (&quot;同伴代理 %s 有 %s 个worker空闲\n&quot;, peer_name, available);
            free (peer_name);
            free (available);
        }
        else {
            //  发送随机数表示空闲的worker数
            zstr_sendm (statebe, self);
            zstr_sendf (statebe, &quot;%d&quot;, randof (10));
        }
    }
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</code></pre>
<p>几点说明：</p>
<ul>
<li><p>每个代理都需要有各自的标识，用以生成相应的ipc端点名称。真实环境中，代理需要使用TCP协议连接，这就需要一个更为完备的配置机制，我们会在以后的章节中谈到。</p>
</li>
<li><p>程序的核心是一个zmq_poll()循环，它会处理接收到消息，并发送自身的状态。只有当zmq_poll()因无法获得同伴消息而超时时我们才会发送自身状态，如果我们每次收到消息都去发送自身状态，那消息就会过量了。</p>
</li>
<li><p>发送的状态消息包含两帧，第一帧是代理自身的地址，第二帧是空闲的worker数。我们必须要告知同伴代理自身的地址，这样才能接收到请求，唯一的方法就是在消息中显示注明。</p>
</li>
<li><p>我们没有在SUB套接字上设置标识，否则就会在连接到同伴代理时获得过期的状态信息。</p>
</li>
<li><p>我们没有在PUB套接字上设置阈值（HWM），因为订阅者是瞬时的。我们也可以将阈值设置为1，但其实是没有必要的。</p>
</li>
</ul>
<p>让我们编译这段程序，用它模拟三个集群，DC1、DC2、DC3。我们在不同的窗口中运行以下命令：</p>
<pre><code>peering1 DC1 DC2 DC3  #  Start DC1 and connect to DC2 and DC3
peering1 DC2 DC1 DC3  #  Start DC2 and connect to DC1 and DC3
peering1 DC3 DC1 DC2  #  Start DC3 and connect to DC1 and DC2
</code></pre><p>每个集群都会报告同伴代理的状态，之后每隔一秒都会打印出自己的状态。</p>
<p>在现实编程中，我们不会通过定时的方式来发送自身状态，而是在状态发生改变时就发送。这看起来会很占用带宽，但其实状态消息的内容很少，而且集群间的连接是非常快速的。</p>
<p>如果我们想要以较为精确的周期来发送状态信息，可以新建一个线程，将statebe套接字打开，然后由主线程将不规则的状态信息发送给子线程，再由子线程定时发布这些消息。不过这种机制就需要额外的编程了。</p>
<h4 id="本地流和云端流原型"><a href="#本地流和云端流原型" class="headerlink" title="本地流和云端流原型"></a>本地流和云端流原型</h4><p>下面让我们建立本地流和云端流的原型。这段代码会从client获取请求，并随机地分派给集群内的worker或其他集群。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter3_26.png" alt="26"></p>
<p>在编写代码之前，让我们先描绘一下核心的路由逻辑，整理出一份简单而健壮的设计。</p>
<p>我们需要两个队列，一个队列用于存放从本地集群client收到的请求，另一个存放其他集群发送来的请求。一种方法是从本地和云端的前端套接字中获取消息，分别存入两个队列。但是这么做似乎是没有必要的，因为ZMQ套接字本身就是队列。所以，我们直接使用ZMQ套接字提供的缓存来作为队列使用。</p>
<p>这项技术我们在LRU队列装置中使用过，且工作得很好。做法是，当代理下有空闲的worker或能接收请求的其他集群时，才从套接字中获取请求。我们可以不断地从后端获取应答，然后路由回去。如果后端没有任何响应，那也就没有必要去接收前端的请求了。</p>
<p>所以，我们的主循环会做以下几件事：</p>
<ul>
<li><p>轮询后端套接字，会从worker处获得“已就绪”的消息或是一个应答。如果是应答消息，则将其路由回集群client，或是其他集群。</p>
</li>
<li><p>worker应答后即可标记为可用，放入队列并计数；</p>
</li>
<li><p>如果有可用的worker，就获取一个请求，该请求可能来自集群内的client，也可能是其他集群。随后将请求转发给集群内的worker，或是随机转发给其他集群。</p>
</li>
</ul>
<p>这里我们只是随机地将请求发送给其他集群，而不是在代理中模拟出一个worker，进行集群间的任务分发。这看起来挺愚蠢的，不过目前尚可使用。</p>
<p>我们使用代理的标识来进行代理之前的消息路由。每个代理都有自己的名字，是在命令行中指定的。只要这些指定的名字和ZMQ为client自动生成的UUID不重复，那么我们就可以知道应答是要返回给client，还是返回给另一个集群。</p>
<p>下面是代码，有趣的部分已在程序中标注：</p>
<p><strong>peering2: Prototype local and cloud flow in C</strong></p>
<pre><code class="c">//
//  代理同伴模拟（第二部分）
//  请求-应答消息流原型
//
//  示例程序使用了一个进程，这样可以让程序变得简单，
//  每个线程都有自己的上下文对象，所以可以认为他们是多个进程。
//
#include &quot;czmq.h&quot;

#define NBR_CLIENTS 10
#define NBR_WORKERS 3
#define LRU_READY   &quot;\001&quot;      //  消息：worker已就绪

//  代理名称；现实中，这个名称应该由某种配置完成
static char *self;

//  请求-应答客户端使用REQ套接字
//
static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, &quot;ipc://%s-localfe.ipc&quot;, self);

    while (1) {
        //  发送请求，接收应答
        zstr_send (client, &quot;HELLO&quot;);
        char *reply = zstr_recv (client);
        if (!reply)
            break;              //  中断
        printf (&quot;Client: %s\n&quot;, reply);
        free (reply);
        sleep (1);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  worker使用REQ套接字，并进行LRU路由
//
static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, &quot;ipc://%s-localbe.ipc&quot;, self);

    //  告知代理worker已就绪
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    //  处理消息
    while (1) {
        zmsg_t *msg = zmsg_recv (worker);
        if (!msg)
            break;              //  中断

        zframe_print (zmsg_last (msg), &quot;Worker: &quot;);
        zframe_reset (zmsg_last (msg), &quot;OK&quot;, 2);
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}


int main (int argc, char *argv [])
{
    //  第一个参数是代理的名称
    //  其他参数是同伴代理的名称
    //
    if (argc &lt; 2) {
        printf (&quot;syntax: peering2 me {you}...\n&quot;);
        exit (EXIT_FAILURE);
    }
    self = argv [1];
    printf (&quot;I: 正在准备代理程序 %s...\n&quot;, self);
    srandom ((unsigned) time (NULL));

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    char endpoint [256];

    //  将cloudfe绑定至端点
    void *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudfe, self);
    zsocket_bind (cloudfe, &quot;ipc://%s-cloud.ipc&quot;, self);

    //  将cloudbe连接至同伴代理的端点
    void *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudbe, self);
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf (&quot;I: 正在连接至同伴代理 &#39;%s&#39; 的cloudfe端点\n&quot;, peer);
        zsocket_connect (cloudbe, &quot;ipc://%s-cloud.ipc&quot;, peer);
    }
    //  准备本地前端和后端
    void *localfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localfe, &quot;ipc://%s-localfe.ipc&quot;, self);
    void *localbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localbe, &quot;ipc://%s-localbe.ipc&quot;, self);

    //  让用户告诉我们何时开始
    printf (&quot;请确认所有代理已经启动，按任意键继续: &quot;);
    getchar ();

    //  启动本地worker
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (ctx, worker_task, NULL);

    //  启动本地client
    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (ctx, client_task, NULL);

    //  有趣的部分
    //  -------------------------------------------------------------
    //  请求-应答消息流
    //  - 若本地有可用worker，则轮询获取本地或云端的请求；
    //  - 将请求路由给本地worker或其他集群。

    //  可用worker队列
    int capacity = 0;
    zlist_t *workers = zlist_new ();

    while (1) {
        zmq_pollitem_t backends [] = {
            { localbe, 0, ZMQ_POLLIN, 0 },
            { cloudbe, 0, ZMQ_POLLIN, 0 }
        };
        //  如果没有可用worker，则继续等待
        int rc = zmq_poll (backends, 2,
            capacity? 1000 * ZMQ_POLL_MSEC: -1);
        if (rc == -1)
            break;              //  中断

        //  处理本地worker的应答
        zmsg_t *msg = NULL;
        if (backends [0].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (localbe);
            if (!msg)
                break;          //  中断
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);
            capacity++;

            //  如果是“已就绪”的信号，则不再进行路由
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
        }
        //  处理来自同伴代理的应答
        else
        if (backends [1].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (cloudbe);
            if (!msg)
                break;          //  中断
            //  我们不需要使用同伴代理的地址
            zframe_t *address = zmsg_unwrap (msg);
            zframe_destroy (&amp;address);
        }
        //  如果应答消息中的地址是同伴代理的，则发送给它
        for (argn = 2; msg &amp;&amp; argn &lt; argc; argn++) {
            char *data = (char *) zframe_data (zmsg_first (msg));
            size_t size = zframe_size (zmsg_first (msg));
            if (size == strlen (argv [argn])
            &amp;&amp;  memcmp (data, argv [argn], size) == 0)
                zmsg_send (&amp;msg, cloudfe);
        }
        //  将应答路由给本地client
        if (msg)
            zmsg_send (&amp;msg, localfe);

        //  开始处理客户端请求
        //
        while (capacity) {
            zmq_pollitem_t frontends [] = {
                { localfe, 0, ZMQ_POLLIN, 0 },
                { cloudfe, 0, ZMQ_POLLIN, 0 }
            };
            rc = zmq_poll (frontends, 2, 0);
            assert (rc &gt;= 0);
            int reroutable = 0;
            //  优先处理同伴代理的请求，避免资源耗尽
            if (frontends [1].revents &amp; ZMQ_POLLIN) {
                msg = zmsg_recv (cloudfe);
                reroutable = 0;
            }
            else
            if (frontends [0].revents &amp; ZMQ_POLLIN) {
                msg = zmsg_recv (localfe);
                reroutable = 1;
            }
            else
                break;      //  没有请求

            //  将20%的请求发送给其他集群
            //
            if (reroutable &amp;&amp; argc &gt; 2 &amp;&amp; randof (5) == 0) {
                //  随地地路由给同伴代理
                int random_peer = randof (argc - 2) + 2;
                zmsg_pushmem (msg, argv [random_peer], strlen (argv [random_peer]));
                zmsg_send (&amp;msg, cloudbe);
            }
            else {
                zframe_t *frame = (zframe_t *) zlist_pop (workers);
                zmsg_wrap (msg, frame);
                zmsg_send (&amp;msg, localbe);
                capacity--;
            }
        }
    }
    //  程序结束后的清理工作
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</code></pre>
<p>在两个窗口中运行以上代码：</p>
<pre><code>peering2 me you
peering2 you me
</code></pre><p>几点说明：</p>
<ul>
<li><p>zmsg类库让程序变得简单多了，这类程序显然应该成为我们ZMQ程序员必备的工具；<br>由于我们没有在程序中实现获取同伴代理状态的功能，所以先暂且认为他们都是有空闲worker的。现实中，我们不会将请求发送个一个不存在的同伴代理。</p>
</li>
<li><p>你可以让这段程序长时间地运行下去，看看会不会出现路由错误的消息，因为一旦错误，client就会阻塞。你可以试着将一个代理关闭，就能看到代理无法将请求路由给云端中的其他代理，client逐个阻塞，程序也停止打印跟踪信息。</p>
</li>
</ul>
<h4 id="组装"><a href="#组装" class="headerlink" title="组装"></a>组装</h4><p>让我们将所有这些放到一段代码里。和之前一样，我们会在一个进程中完成所有工作。我们会将上文中的两个示例程序结合起来，编写出一个可以模拟任意多个集群的程序。</p>
<p>代码共有270行，非常适合用来模拟一组完整的集群程序，包括client、worker、代理、以及云端任务分发机制。</p>
<p><strong>peering3: Full cluster simulation in C</strong></p>
<pre><code class="c">//
//  同伴代理模拟（第三部分）
//  状态和任务消息流原型
//
//  示例程序使用了一个进程，这样可以让程序变得简单，
//  每个线程都有自己的上下文对象，所以可以认为他们是多个进程。
//
#include &quot;czmq.h&quot;

#define NBR_CLIENTS 10
#define NBR_WORKERS 5
#define LRU_READY   &quot;\001&quot;      //  消息：worker已就绪

//  代理名称；现实中，这个名称应该由某种配置完成
static char *self;

//  请求-应答客户端使用REQ套接字
//  为模拟压力测试，客户端会一次性发送大量请求
//
static void *
client_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *client = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (client, &quot;ipc://%s-localfe.ipc&quot;, self);
    void *monitor = zsocket_new (ctx, ZMQ_PUSH);
    zsocket_connect (monitor, &quot;ipc://%s-monitor.ipc&quot;, self);

    while (1) {
        sleep (randof (5));
        int burst = randof (15);
        while (burst--) {
            char task_id [5];
            sprintf (task_id, &quot;%04X&quot;, randof (0x10000));

            //  使用随机的十六进制ID来标注任务
            zstr_send (client, task_id);

            //  最多等待10秒
            zmq_pollitem_t pollset [1] = { { client, 0, ZMQ_POLLIN, 0 } };
            int rc = zmq_poll (pollset, 1, 10 * 1000 * ZMQ_POLL_MSEC);
            if (rc == -1)
                break;          //  中断

            if (pollset [0].revents &amp; ZMQ_POLLIN) {
                char *reply = zstr_recv (client);
                if (!reply)
                    break;              //  中断
                //  worker的应答中应包含任务ID
                puts (reply);
                assert (streq (reply, task_id));
                free (reply);
            }
            else {
                zstr_sendf (monitor,
                    &quot;E: 客户端退出，丢失的任务为： %s&quot;, task_id);
                return NULL;
            }
        }
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

//  worker使用REQ套接字，并进行LRU路由
//
static void *
worker_task (void *args)
{
    zctx_t *ctx = zctx_new ();
    void *worker = zsocket_new (ctx, ZMQ_REQ);
    zsocket_connect (worker, &quot;ipc://%s-localbe.ipc&quot;, self);

    //  告知代理worker已就绪
    zframe_t *frame = zframe_new (LRU_READY, 1);
    zframe_send (&amp;frame, worker, 0);

    while (1) {
        //  worker会随机延迟几秒
        zmsg_t *msg = zmsg_recv (worker);
        sleep (randof (2));
        zmsg_send (&amp;msg, worker);
    }
    zctx_destroy (&amp;ctx);
    return NULL;
}

int main (int argc, char *argv [])
{
    //  第一个参数是代理的名称
    //  其他参数是同伴代理的名称
    //
    if (argc &lt; 2) {
        printf (&quot;syntax: peering3 me {you}...\n&quot;);
        exit (EXIT_FAILURE);
    }
    self = argv [1];
    printf (&quot;I: 正在准备代理程序 %s...\n&quot;, self);
    srandom ((unsigned) time (NULL));

    //  准备上下文和套接字
    zctx_t *ctx = zctx_new ();
    char endpoint [256];

    //  将cloudfe绑定至端点
    void *cloudfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudfe, self);
    zsocket_bind (cloudfe, &quot;ipc://%s-cloud.ipc&quot;, self);

    //  将statebe绑定至端点
    void *statebe = zsocket_new (ctx, ZMQ_PUB);
    zsocket_bind (statebe, &quot;ipc://%s-state.ipc&quot;, self);

    //  将cloudbe连接至同伴代理的端点
    void *cloudbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsockopt_set_identity (cloudbe, self);
    int argn;
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf (&quot;I: 正在连接至同伴代理 &#39;%s&#39; 的cloudfe端点\n&quot;, peer);
        zsocket_connect (cloudbe, &quot;ipc://%s-cloud.ipc&quot;, peer);
    }

    //  将statefe连接至同伴代理的端点
    void *statefe = zsocket_new (ctx, ZMQ_SUB);
    for (argn = 2; argn &lt; argc; argn++) {
        char *peer = argv [argn];
        printf (&quot;I: 正在连接至同伴代理 &#39;%s&#39; 的statebe端点\n&quot;, peer);
        zsocket_connect (statefe, &quot;ipc://%s-state.ipc&quot;, peer);
    }
    //  准备本地前端和后端
    void *localfe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localfe, &quot;ipc://%s-localfe.ipc&quot;, self);

    void *localbe = zsocket_new (ctx, ZMQ_ROUTER);
    zsocket_bind (localbe, &quot;ipc://%s-localbe.ipc&quot;, self);

    //  准备监控套接字
    void *monitor = zsocket_new (ctx, ZMQ_PULL);
    zsocket_bind (monitor, &quot;ipc://%s-monitor.ipc&quot;, self);

    //  启动本地worker
    int worker_nbr;
    for (worker_nbr = 0; worker_nbr &lt; NBR_WORKERS; worker_nbr++)
        zthread_new (ctx, worker_task, NULL);

    //  启动本地client
    int client_nbr;
    for (client_nbr = 0; client_nbr &lt; NBR_CLIENTS; client_nbr++)
        zthread_new (ctx, client_task, NULL);

    //  有趣的部分
    //  -------------------------------------------------------------
    //  发布-订阅消息流
    //  - 轮询同伴代理的状态信息；
    //  - 当自身状态改变时，对外广播消息。
    //  请求-应答消息流
    //  - 若本地有可用worker，则轮询获取本地或云端的请求；
    //  - 将请求路由给本地worker或其他集群。

    //  可用worker队列
    int local_capacity = 0;
    int cloud_capacity = 0;
    zlist_t *workers = zlist_new ();

    while (1) {
        zmq_pollitem_t primary [] = {
            { localbe, 0, ZMQ_POLLIN, 0 },
            { cloudbe, 0, ZMQ_POLLIN, 0 },
            { statefe, 0, ZMQ_POLLIN, 0 },
            { monitor, 0, ZMQ_POLLIN, 0 }
        };
        //  如果没有可用的worker，则一直等待
        int rc = zmq_poll (primary, 4,
            local_capacity? 1000 * ZMQ_POLL_MSEC: -1);
        if (rc == -1)
            break;              //  中断

        //  跟踪自身状态信息是否改变
        int previous = local_capacity;

        //  处理本地worker的应答
        zmsg_t *msg = NULL;

        if (primary [0].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (localbe);
            if (!msg)
                break;          //  中断
            zframe_t *address = zmsg_unwrap (msg);
            zlist_append (workers, address);
            local_capacity++;

            //  如果是“已就绪”的信号，则不再进行路由
            zframe_t *frame = zmsg_first (msg);
            if (memcmp (zframe_data (frame), LRU_READY, 1) == 0)
                zmsg_destroy (&amp;msg);
        }
        //  处理来自同伴代理的应答
        else
        if (primary [1].revents &amp; ZMQ_POLLIN) {
            msg = zmsg_recv (cloudbe);
            if (!msg)
                break;          //  Interrupted
            //  我们不需要使用同伴代理的地址
            zframe_t *address = zmsg_unwrap (msg);
            zframe_destroy (&amp;address);
        }
        //  如果应答消息中的地址是同伴代理的，则发送给它
        for (argn = 2; msg &amp;&amp; argn &lt; argc; argn++) {
            char *data = (char *) zframe_data (zmsg_first (msg));
            size_t size = zframe_size (zmsg_first (msg));
            if (size == strlen (argv [argn])
            &amp;&amp;  memcmp (data, argv [argn], size) == 0)
                zmsg_send (&amp;msg, cloudfe);
        }
        //  将应答路由给本地client
        if (msg)
            zmsg_send (&amp;msg, localfe);

        //  处理同伴代理的状态更新
        if (primary [2].revents &amp; ZMQ_POLLIN) {
            char *status = zstr_recv (statefe);
            cloud_capacity = atoi (status);
            free (status);
        }
        //  处理监控消息
        if (primary [3].revents &amp; ZMQ_POLLIN) {
            char *status = zstr_recv (monitor);
            printf (&quot;%s\n&quot;, status);
            free (status);
        }

        //  开始处理客户端请求
        //  - 如果本地有空闲worker，则总本地client和云端接收请求；
        //  - 如果我们只有空闲的同伴代理，则只轮询本地client的请求；
        //  - 将请求路由给本地worker，或者同伴代理。
        //
        while (local_capacity + cloud_capacity) {
            zmq_pollitem_t secondary [] = {
                { localfe, 0, ZMQ_POLLIN, 0 },
                { cloudfe, 0, ZMQ_POLLIN, 0 }
            };
            if (local_capacity)
                rc = zmq_poll (secondary, 2, 0);
            else
                rc = zmq_poll (secondary, 1, 0);
            assert (rc &gt;= 0);

            if (secondary [0].revents &amp; ZMQ_POLLIN)
                msg = zmsg_recv (localfe);
            else
            if (secondary [1].revents &amp; ZMQ_POLLIN)
                msg = zmsg_recv (cloudfe);
            else
                break;      //  没有任务

            if (local_capacity) {
                zframe_t *frame = (zframe_t *) zlist_pop (workers);
                zmsg_wrap (msg, frame);
                zmsg_send (&amp;msg, localbe);
                local_capacity--;
            }
            else {
                //  随机路由给同伴代理
                int random_peer = randof (argc - 2) + 2;
                zmsg_pushmem (msg, argv [random_peer], strlen (argv [random_peer]));
                zmsg_send (&amp;msg, cloudbe);
            }
        }
        if (local_capacity != previous) {
            //  将自身代理的地址附加到消息中
            zstr_sendm (statebe, self);
            //  广播新的状态信息
            zstr_sendf (statebe, &quot;%d&quot;, local_capacity);
        }
    }
    //  程序结束后的清理工作
    while (zlist_size (workers)) {
        zframe_t *frame = (zframe_t *) zlist_pop (workers);
        zframe_destroy (&amp;frame);
    }
    zlist_destroy (&amp;workers);
    zctx_destroy (&amp;ctx);
    return EXIT_SUCCESS;
}
</code></pre>
<p>这段代码并不长，但花费了大约一天的时间去调通。以下是一些说明：</p>
<ul>
<li><p>client线程会检测并报告失败的请求，它们会轮询代理套接字，查看是否有应答，超时时间为10秒。</p>
</li>
<li><p>client线程不会自己打印信息，而是将消息PUSH给一个监控线程，由它打印消息。这是我们第一次使用ZMQ进行监控和记录日志，我们以后会见得更多。</p>
</li>
<li><p>clinet会模拟多种负载情况，让集群在不同的压力下工作，因此请求可能会在本地处理，也有可能会发送至云端。集群中的client和worker数量、其他集群的数量，以及延迟时间，会左右这个结果。你可以设置不同的参数来测试它们。</p>
</li>
<li><p>主循环中有两组轮询集合，事实上我们可以使用三个：信息流、后端、前端。因为在前面的例子中，如果后端没有空闲的worker，就没有必要轮询前端请求了。</p>
</li>
</ul>
<p>以下是几个在编写过程中遇到的问题：</p>
<ul>
<li><p>如果请求或应答在某处丢失，client会因此阻塞。回忆以下，ROUTER-ROUTER套接字会在消息如法路由的情况下直接丢弃。这里的一个策略就是改变client线程，检测并报告这种错误。此外，我还在每次recv()之后以及send()之前使用zmsg_dump()来打印套接字内容，用来更快地定位消息。</p>
</li>
<li><p>主循环会错误地从多个已就绪的套接字中获取消息，造成第一条消息的丢失。解决方法是只从第一个已就绪的套接字中获取消息。</p>
</li>
<li><p>zmsg类库没有很好地将UUID编码为C语言字符串，导致包含字节0的UUID会崩溃。解决方法是将UUID转换成可打印的十六进制字符串。</p>
</li>
</ul>
<p>这段模拟程序没有检测同伴代理是否存在。如果你开启了某个代理，它已向其他代理发送过状态信息，然后关闭了，那其他代理仍会向它发送请求。这样一来，其他代理的client就会报告很多错误。解决时有两点：一、为状态信息设置有效期，当同伴代理消失一段时间后就不再发送请求；二、提高请求-应答的可靠性，这在下一章中会讲到。</p>
]]></content>
      
        <categories>
            
            <category> 网络编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zmq,网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zmq学习第一章]]></title>
      <url>/2017/12/20/zmq_chapter1/</url>
      <content type="html"><![CDATA[<h1 id="ZMQ-指南"><a href="#ZMQ-指南" class="headerlink" title="ZMQ 指南"></a>ZMQ 指南</h1><p><strong>作者: Pieter Hintjens <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#58;&#x70;&#104;&#x40;&#105;&#109;&#x61;&#x74;&#x69;&#x78;&#x2e;&#x63;&#111;&#109;">&#x70;&#104;&#x40;&#105;&#109;&#x61;&#x74;&#x69;&#x78;&#x2e;&#x63;&#111;&#109;</a>, CEO iMatix Corporation.</strong><br><strong>翻译: 张吉 <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#106;&#x69;&#x7a;&#104;&#x61;&#x6e;&#103;&#64;&#97;&#x6e;&#106;&#117;&#107;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#106;&#x69;&#x7a;&#104;&#x61;&#x6e;&#103;&#64;&#97;&#x6e;&#106;&#117;&#107;&#x65;&#x2e;&#99;&#x6f;&#x6d;</a>, 安居客集团 好租网工程师</strong></p>
<p>With thanks to Bill Desmarais, Brian Dorsey, CAF, Daniel Lin, Eric Desgranges, Gonzalo Diethelm, Guido Goldstein, Hunter Ford, Kamil Shakirov, Martin Sustrik, Mike Castleman, Naveen Chawla, Nicola Peduzzi, Oliver Smith, Olivier Chamoux, Peter Alexander, Pierre Rouleau, Randy Dryburgh, John Unwin, Alex Thomas, Mihail Minkov, Jeremy Avnet, Michael Compton, Kamil Kisiel, Mark Kharitonov, Guillaume Aubert, Ian Barber, Mike Sheridan, Faruk Akgul, Oleg Sidorov, Lev Givon, Allister MacLeod, Alexander D’Archangel, Andreas Hoelzlwimmer, Han Holl, Robert G. Jakabosky, Felipe Cruz, Marcus McCurdy, Mikhail Kulemin, Dr. Gergő Érdi, Pavel Zhukov, Alexander Else, Giovanni Ruggiero, Rick “Technoweenie”, Daniel Lundin, Dave Hoover, Simon Jefford, Benjamin Peterson, Justin Case, Devon Weller, Richard Smith, Alexander Morland, Wadim Grasza, Michael Jakl, and Zed Shaw for their contributions, and to Stathis Sideris for <a href="http://www.ditaa.org" target="_blank" rel="external">Ditaa</a>.</p>
<p>Please use the <a href="https://github.com/imatix/zguide/issues" target="_blank" rel="external">issue tracker</a> for all comments and errata. This version covers the latest stable release of 0MQ and was published on Mon 10 October, 2011.</p>
<p>The Guide is mainly <a href="http://zguide.zeromq.org/page:all" target="_blank" rel="external">in C</a>, but also in <a href="http://zguide.zeromq.org/php:all" target="_blank" rel="external">PHP</a> and <a href="http://zguide.zeromq.org/lua:all" target="_blank" rel="external">Lua</a>.</p>
<hr>
<a id="more"></a>
<p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank" rel="external">Creative Commons Attribution-ShareAlike 3.0 License</a>.</p>
<h2 id="第一章-ZeroMQ基础"><a href="#第一章-ZeroMQ基础" class="headerlink" title="第一章 ZeroMQ基础"></a>第一章 ZeroMQ基础</h2><h3 id="拯救世界"><a href="#拯救世界" class="headerlink" title="拯救世界"></a>拯救世界</h3><p>如何解释ZMQ？有些人会先说一堆ZMQ的好：它是一套用于快速构建的套接字组件；它的信箱系统有超强的路由能力；它太快了！而有些人则喜欢分享他们被ZMQ点悟的时刻，那些被灵感击中的瞬间：所有的事情突然变得简单明了，让人大开眼界。另一些人则会拿ZMQ同其他产品做个比较：它更小，更简单，但却让人觉得如此熟悉。对于我个人而言，我则更倾向于和别人分享ZMQ的诞生史，相信会和各位读者有所共鸣。</p>
<p>编程是一门科学，但往往会乔装成一门艺术。我们从不去了解软件最底层的机理，或者说根本没有人在乎这些。软件并不只是算法、数据结构、编程语言、或者抽象云云，这些不过是一些工具而已，被我们创造、使用、最后抛弃。软件真正的本质，其实是人的本质。</p>
<p>举例来说，当我们遇到一个高度复杂的问题时，我们会群策群力，分工合作，将问题拆分为若干个部分，一起解决。这里就体现了编程的科学：创建一组小型的构建模块，让人们易于理解和使用，那么大家就会一起用它来解决问题。</p>
<p>我们生活在一个普遍联系的世界里，需要现代的编程软件为我们做指引。所以，未来我们所需要的用于处理大规模计算的构建模块，必须是普遍联系的，而且能够并行运作。那时，程序代码不能再只关注自己，它们需要互相交流，变得足够健谈。程序代码需要像人脑一样，数以兆计的神经元高速地传输信号，在一个没有中央控制的环境下，没有单点故障的环境下，解决问题。这一点其实并不意外，因为就当今的网络来讲，每个节点其实就像是连接了一个人脑一样。</p>
<p>如果你曾和线程、协议、或网络打过交道，你会觉得我上面的话像是天方夜谭。因为在实际应用过程中，只是连接几个程序或网络就已经非常困难和麻烦了。数以兆计的节点？那真是无法想象的。现今只有资金雄厚的企业才能负担得起这种软件和服务。</p>
<p>当今世界的网络结构已经远远超越了我们自身的驾驭能力。十九世纪八十年代的软件危机，弗莱德•布鲁克斯曾说过，这个世上<a href="http://en.wikipedia.org/wiki/No_Silver_Bullet" target="_blank" rel="external">没有银弹</a>。后来，免费和开源解决了这次软件危机，让我们能够高效地分享知识。如今，我们又面临一次新的软件危机，只不过我们谈论得不多。只有那些大型的、富足的企业才有财力建立高度联系的应用程序。那里有云的存在，但它是私有的。我们的数据和知识正在从我们的个人电脑中消失，流入云端，无法获得或与其竞争。是谁坐拥我们的社交网络？这真像一次巨型主机的革命。</p>
<p>我们暂且不谈其中的政治因素，光那些就可以另外出本书了。目前的现状是，虽然互联网能够让千万个程序相连，但我们之中的大多数却无法做到这些。这样一来，那些真正有趣的大型问题（如健康、教育、经济、交通等领域），仍然无法解决。我们没有能力将代码连接起来，也就不能像大脑中的神经元一样处理那些大规模的问题。</p>
<p>已经有人尝试用各种方法来连接应用程序，如数以千计的IETF规范，每种规范解决一个特定问题。对于开发人员来说，HTTP协议是比较简单和易用的，但这也往往让问题变得更糟，因为它鼓励人们形成一种重服务端、轻客户端的思想。</p>
<p>所以迄今为止人们还在使用原始的TCP/UDP协议、私有协议、HTTP协议、网络套接字等形式连接应用程序。这种做法依旧让人痛苦，速度慢又不易扩展，需要集中化管理。而分布式的P2P协议又仅仅适用于娱乐，而非真正的应用。有谁会使用Skype或者Bittorrent来交换数据呢？</p>
<p>这就让我们回归到编程科学的问题上来。想要拯救这个世界，我们需要做两件事情：一，如何在任何地点连接任何两个应用程序；二、将这个解决方案用最为简单的方式包装起来，供程序员使用。</p>
<p>也许这听起来太简单了，但事实确实如此。</p>
<h3 id="ZMQ简介"><a href="#ZMQ简介" class="headerlink" title="ZMQ简介"></a>ZMQ简介</h3><p>ZMQ（ØMQ、ZeroMQ, 0MQ）看起来像是一套嵌入式的网络链接库，但工作起来更像是一个并发式的框架。它提供的套接字可以在多种协议中传输消息，如线程间、进程间、TCP、广播等。你可以使用套接字构建多对多的连接模式，如扇出、发布-订阅、任务分发、请求-应答等。ZMQ的快速足以胜任集群应用产品。它的异步I/O机制让你能够构建多核应用程序，完成异步消息处理任务。ZMQ有着多语言支持，并能在几乎所有的操作系统上运行。ZMQ是<a href="http://www.imatix.com/" target="_blank" rel="external">iMatix</a>公司的产品，以LGPL开源协议发布。</p>
<h3 id="需要具备的知识"><a href="#需要具备的知识" class="headerlink" title="需要具备的知识"></a>需要具备的知识</h3><ul>
<li>使用最新的ZMQ稳定版本；</li>
<li>使用Linux系统或其他相似的操作系统；</li>
<li>能够阅读C语言代码，这是本指南示例程序的默认语言；</li>
<li>当我们书写诸如PUSH或SUBSCRIBE等常量时，你能够找到相应语言的实现，如ZMQ_PUSH、ZMQ_SUBSCRIBE。</li>
</ul>
<h3 id="获取示例"><a href="#获取示例" class="headerlink" title="获取示例"></a>获取示例</h3><p>本指南的所有示例都存放于<a href="https://github.com/imatix/zguide" target="_blank" rel="external">github仓库</a>中，最简单的获取方式是运行以下代码：</p>
<pre><code>git clone git://github.com/imatix/zguide.git
</code></pre><p>浏览examples目录，你可以看到多种语言的实现。如果其中缺少了某种你正在使用的语言，我们很希望你可以<a href="http://zguide.zeromq.org/main:translate" target="_blank" rel="external">提交一份补充</a>。这也是本指南实用的原因，要感谢所有做出过贡献的人。</p>
<p>所有的示例代码都以MIT/X11协议发布，若在源代码中有其他限定的除外。</p>
<h3 id="提问-回答"><a href="#提问-回答" class="headerlink" title="提问-回答"></a>提问-回答</h3><p>让我们从简单的代码开始，一段传统的Hello World程序。我们会创建一个客户端和一个服务端，客户端发送Hello给服务端，服务端返回World。下文是C语言编写的服务端，它在5555端口打开一个ZMQ套接字，等待请求，收到后应答World。</p>
<p><strong>hwserver.c: Hello World server</strong></p>
<pre><code class="c">//
//  Hello World 服务端
//  绑定一个REP套接字至tcp://*:5555
//  从客户端接收Hello，并应答World
//
#include &lt;zmq.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main (void)
{
    void *context = zmq_init (1);

    //  与客户端通信的套接字
    void *responder = zmq_socket (context, ZMQ_REP);
    zmq_bind (responder, &quot;tcp://*:5555&quot;);

    while (1) {
        //  等待客户端请求
        zmq_msg_t request;
        zmq_msg_init (&amp;request);
        zmq_recv (responder, &amp;request, 0);
        printf (&quot;收到 Hello\n&quot;);
        zmq_msg_close (&amp;request);

        //  做些“处理”
        sleep (1);

        //  返回应答
        zmq_msg_t reply;
        zmq_msg_init_size (&amp;reply, 5);
        memcpy (zmq_msg_data (&amp;reply), &quot;World&quot;, 5);
        zmq_send (responder, &amp;reply, 0);
        zmq_msg_close (&amp;reply);
    }
    //  程序不会运行到这里，以下只是演示我们应该如何结束
    zmq_close (responder);
    zmq_term (context);
    return 0;
}
</code></pre>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_1.png" alt="1"></p>
<p>使用REQ-REP套接字发送和接受消息是需要遵循一定规律的。客户端首先使用zmq_send()发送消息，再用zmq_recv()接收，如此循环。如果打乱了这个顺序（如连续发送两次）则会报错。类似地，服务端必须先进行接收，后进行发送。</p>
<p>ZMQ使用C语言作为它参考手册的语言，本指南也以它作为示例程序的语言。如果你正在阅读本指南的在线版本，你可以看到示例代码的下方有其他语言的实现。如以下是C++语言：</p>
<p><strong>hwserver.cpp: Hello World server</strong></p>
<pre><code class="cpp">//
// Hello World 服务端 C++语言版
// 绑定一个REP套接字至tcp://*:5555
// 从客户端接收Hello，并应答World
//
#include &lt;zmq.hpp&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

int main () {
    // 准备上下文和套接字
    zmq::context_t context (1);
    zmq::socket_t socket (context, ZMQ_REP);
    socket.bind (&quot;tcp://*:5555&quot;);

    while (true) {
        zmq::message_t request;

        // 等待客户端请求
        socket.recv (&amp;request);
        std::cout &lt;&lt; &quot;收到 Hello&quot; &lt;&lt; std::endl;

        // 做一些“处理”
        sleep (1);

        // 应答World
        zmq::message_t reply (5);
        memcpy ((void *) reply.data (), &quot;World&quot;, 5);
        socket.send (reply);
    }
    return 0;
}
</code></pre>
<p>可以看到C语言和C++语言的API代码差不多，而在PHP这样的语言中，代码就会更为简洁：</p>
<p><strong>hwserver.php: Hello World server</strong></p>
<pre><code class="php">&lt;?php
/**
 * Hello World 服务端
 * 绑定REP套接字至 tcp://*:5555
 * 从客户端接收Hello，并应答World
 * @author Ian Barber &lt;ian(dot)barber(at)gmail(dot)com&gt;
 */

$context = new ZMQContext(1);

// 与客户端通信的套接字
$responder = new ZMQSocket($context, ZMQ::SOCKET_REP);
$responder-&gt;bind(&quot;tcp://*:5555&quot;);

while(true) {
    // 等待客户端请求
    $request = $responder-&gt;recv();
    printf (&quot;Received request: [%s]\n&quot;, $request);

    // 做一些“处理”
    sleep (1);

    // 应答World
    $responder-&gt;send(&quot;World&quot;);
}
</code></pre>
<p>下面是客户端的代码：</p>
<p><strong>hwclient: Hello World client in C</strong></p>
<pre><code class="c">//
//  Hello World 客户端
//  连接REQ套接字至 tcp://localhost:5555
//  发送Hello给服务端，并接收World
//
#include &lt;zmq.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main (void)
{
    void *context = zmq_init (1);

    //  连接至服务端的套接字
    printf (&quot;正在连接至hello world服务端...\n&quot;);
    void *requester = zmq_socket (context, ZMQ_REQ);
    zmq_connect (requester, &quot;tcp://localhost:5555&quot;);

    int request_nbr;
    for (request_nbr = 0; request_nbr != 10; request_nbr++) {
        zmq_msg_t request;
        zmq_msg_init_size (&amp;request, 5);
        memcpy (zmq_msg_data (&amp;request), &quot;Hello&quot;, 5);
        printf (&quot;正在发送 Hello %d...\n&quot;, request_nbr);
        zmq_send (requester, &amp;request, 0);
        zmq_msg_close (&amp;request);

        zmq_msg_t reply;
        zmq_msg_init (&amp;reply);
        zmq_recv (requester, &amp;reply, 0);
        printf (&quot;接收到 World %d\n&quot;, request_nbr);
        zmq_msg_close (&amp;reply);
    }
    zmq_close (requester);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这看起来是否太简单了？ZMQ就是这样一个东西，你往里加点儿料就能制作出一枚无穷能量的原子弹，用它来拯救世界吧！</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_2.png" alt="2"></p>
<p>理论上你可以连接千万个客户端到这个服务端上，同时连接都没问题，程序仍会运作得很好。你可以尝试一下先打开客户端，再打开服务端，可以看到程序仍然会正常工作，想想这意味着什么。</p>
<p>让我简单介绍一下这两段程序到底做了什么。首先，他们创建了一个ZMQ上下文，然后是一个套接字。不要被这些陌生的名词吓到，后面我们都会讲到。服务端将REP套接字绑定到5555端口上，并开始等待请求，发出应答，如此循环。客户端则是发送请求并等待服务端的应答。</p>
<p>这些代码背后其实发生了很多很多事情，但是程序员完全不必理会这些，只要知道这些代码短小精悍，极少出错，耐高压。这种通信模式我们称之为请求-应答模式，是ZMQ最直接的一种应用。你可以拿它和RPC及经典的C/S模型做类比。</p>
<h3 id="关于字符串"><a href="#关于字符串" class="headerlink" title="关于字符串"></a>关于字符串</h3><p>ZMQ不会关心发送消息的内容，只要知道它所包含的字节数。所以，程序员需要做一些工作，保证对方节点能够正确读取这些消息。如何将一个对象或复杂数据类型转换成ZMQ可以发送的消息，这有类似Protocol Buffers的序列化软件可以做到。但对于字符串，你也是需要有所注意的。</p>
<p>在C语言中，字符串都以一个空字符结尾，你可以像这样发送一个完整的字符串：</p>
<pre><code class="c">zmq_msg_init_data (&amp;request, &quot;Hello&quot;, 6, NULL, NULL);
</code></pre>
<p>但是，如果你用其他语言发送这个字符串，很可能不会包含这个空字节，如你使用Python发送：</p>
<pre><code class="python">socket.send (&quot;Hello&quot;)
</code></pre>
<p>实际发送的消息是：</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_3.png" alt="3"></p>
<p>如果你从C语言中读取该消息，你会读到一个类似于字符串的内容，甚至它可能就是一个字符串（第六位在内存中正好是一个空字符），但是这并不合适。这样一来，客户端和服务端对字符串的定义就不统一了，你会得到一些奇怪的结果。</p>
<p>当你用C语言从ZMQ中获取字符串，你不能够相信该字符串有一个正确的结尾。因此，当你在接受字符串时，应该建立多一个字节的缓冲区，将字符串放进去，并添加结尾。</p>
<p>所以，让我们做如下假设：<strong>ZMQ的字符串是有长度的，且传送时不加结束符</strong>。在最简单的情况下，ZMQ字符串和ZMQ消息中的一帧是等价的，就如上图所展现的，由一个长度属性和一串字节表示。</p>
<p>下面这个功能函数会帮助我们在C语言中正确的接受字符串消息：</p>
<pre><code class="c">// 从ZMQ套接字中接收字符串，并转换为C语言的字符串
static char *
s_recv (void *socket) {
    zmq_msg_t message;
    zmq_msg_init (&amp;message);
    zmq_recv (socket, &amp;message, 0);
    int size = zmq_msg_size (&amp;message);
    char *string = malloc (size + 1);
    memcpy (string, zmq_msg_data (&amp;message), size);
    zmq_msg_close (&amp;message);
    string [size] = 0;
    return (string);
}
</code></pre>
<p>这段代码我们会在日后的示例中使用，我们可以顺手写一个s_send()方法，并打包成一个.h文件供我们使用。</p>
<p>这就诞生了zhelpers.h，一个供C语言使用的ZMQ功能函数库。它的源代码比较长，而且只对C语言程序员有用，你可以在闲暇时<a href="https://github.com/imatix/zguide/blob/master/examples/C/zhelpers.h" target="_blank" rel="external">看一看</a>。</p>
<h3 id="获取版本号"><a href="#获取版本号" class="headerlink" title="获取版本号"></a>获取版本号</h3><p>ZMQ目前有多个版本，而且仍在持续更新。如果你遇到了问题，也许这在下一个版本中已经解决了。想知道目前的ZMQ版本，你可以在程序中运行如下：</p>
<p><strong>version: ØMQ version reporting in C</strong></p>
<pre><code class="c">//
// 返回当前ZMQ的版本号
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    int major, minor, patch;
    zmq_version (&amp;major, &amp;minor, &amp;patch);
    printf (&quot;当前ZMQ版本号为 %d.%d.%d\n&quot;, major, minor, patch);

    return EXIT_SUCCESS;
}
</code></pre>
<h3 id="让消息流动起来"><a href="#让消息流动起来" class="headerlink" title="让消息流动起来"></a>让消息流动起来</h3><p>第二种经典的消息模式是单向数据分发：服务端将更新事件发送给一组客户端。让我们看一个天气信息发布的例子，包括邮编、温度、相对湿度。我们生成这些随机信息，用来模拟气象站所做的那样。</p>
<p>下面是服务端的代码，使用5556端口：</p>
<p><strong>wuserver: Weather update server in C</strong></p>
<pre><code class="c">//
//  气象信息更新服务
//  绑定PUB套接字至tcp://*:5556端点
//  发布随机气象信息
//
#include &quot;zhelpers.h&quot;

int main (void)
{
    //  准备上下文和PUB套接字
    void *context = zmq_init (1);
    void *publisher = zmq_socket (context, ZMQ_PUB);
    zmq_bind (publisher, &quot;tcp://*:5556&quot;);
    zmq_bind (publisher, &quot;ipc://weather.ipc&quot;);

    //  初始化随机数生成器
    srandom ((unsigned) time (NULL));
    while (1) {
        //  生成数据
        int zipcode, temperature, relhumidity;
        zipcode     = randof (100000);
        temperature = randof (215) - 80;
        relhumidity = randof (50) + 10;

        //  向所有订阅者发送消息
        char update [20];
        sprintf (update, &quot;%05d %d %d&quot;, zipcode, temperature, relhumidity);
        s_send (publisher, update);
    }
    zmq_close (publisher);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>这项更新服务没有开始、没有结束，就像永不消失的电波一样。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_4.png" alt="4"></p>
<p>下面是客户端程序，它会接受发布者的消息，只处理特定邮编标注的信息，如纽约的邮编是10001:</p>
<p><strong>wuclient: Weather update client in C</strong></p>
<pre><code class="c">//
//  气象信息客户端
//  连接SUB套接字至tcp://*:5556端点
//  收集指定邮编的气象信息，并计算平均温度
//
#include &quot;zhelpers.h&quot;

int main (int argc, char *argv [])
{
    void *context = zmq_init (1);

    //  创建连接至服务端的套接字
    printf (&quot;正在收集气象信息...\n&quot;);
    void *subscriber = zmq_socket (context, ZMQ_SUB);
    zmq_connect (subscriber, &quot;tcp://localhost:5556&quot;);

    //  设置订阅信息，默认为纽约，邮编10001
    char *filter = (argc &gt; 1)? argv [1]: &quot;10001 &quot;;
    zmq_setsockopt (subscriber, ZMQ_SUBSCRIBE, filter, strlen (filter));

    //  处理100条更新信息
    int update_nbr;
    long total_temp = 0;
    for (update_nbr = 0; update_nbr &lt; 100; update_nbr++) {
        char *string = s_recv (subscriber);
        int zipcode, temperature, relhumidity;
        sscanf (string, &quot;%d %d %d&quot;,
            &amp;zipcode, &amp;temperature, &amp;relhumidity);
        total_temp += temperature;
        free (string);
    }
    printf (&quot;地区邮编 &#39;%s&#39; 的平均温度为 %dF\n&quot;,
        filter, (int) (total_temp / update_nbr));

    zmq_close (subscriber);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>需要注意的是，在使用SUB套接字时，必须使用zmq_setsockopt()方法来设置订阅的内容。如果你不设置订阅内容，那将什么消息都收不到，新手很容易犯这个错误。订阅信息可以是任何字符串，可以设置多次。只要消息满足其中一条订阅信息，SUB套接字就会收到。订阅者可以选择不接收某类消息，也是通过zmq_setsockopt()方法实现的。</p>
<p>PUB-SUB套接字组合是异步的。客户端在一个循环体中使用zmq_recv()接收消息，如果向SUB套接字发送消息则会报错；类似地，服务端可以不断地使用zmq_send()发送消息，但不能在PUB套接字上使用zmq_recv()。</p>
<p>关于PUB-SUB套接字，还有一点需要注意：你无法得知SUB是何时开始接收消息的。就算你先打开了SUB套接字，后打开PUB发送消息，这时SUB还是会丢失一些消息的，因为建立连接是需要一些时间的。很少，但并不是零。</p>
<p>这种“慢连接”的症状一开始会让很多人困惑，所以这里我要详细解释一下。还记得ZMQ是在后台进行异步的I/O传输的，如果你有两个节点用以下顺序相连：</p>
<ul>
<li>订阅者连接至端点接收消息并计数；</li>
<li>发布者绑定至端点并立刻发送1000条消息。</li>
</ul>
<p>运行的结果很可能是订阅者一条消息都收不到。这时你可能会傻眼，忙于检查有没有设置订阅信息，并重新尝试，但结果还是一样。</p>
<p>我们知道在建立TCP连接时需要进行三次握手，会耗费几毫秒的时间，而当节点数增加时这个数字也会上升。在这么短的时间里，ZMQ就可以发送很多很多消息了。举例来说，如果建立连接需要耗时5毫秒，而ZMQ只需要1毫秒就可以发送完这1000条消息。</p>
<p>第二章中我会解释如何使发布者和订阅者同步，只有当订阅者准备好时发布者才会开始发送消息。有一种简单的方法来同步PUB和SUB，就是让PUB延迟一段时间再发送消息。现实编程中我不建议使用这种方式，因为它太脆弱了，而且不好控制。不过这里我们先暂且使用sleep的方式来解决，等到第二章的时候再讲述正确的处理方式。</p>
<p>另一种同步的方式则是认为发布者的消息流是无穷无尽的，因此丢失了前面一部分信息也没有关系。我们的气象信息客户端就是这么做的。</p>
<p>示例中的气象信息客户端会收集指定邮编的一千条信息，其间大约有1000万条信息被发布。你可以先打开客户端，再打开服务端，工作一段时间后重启服务端，这时客户端仍会正常工作。当客户端收集完所需信息后，会计算并输出平均温度。</p>
<p>关于发布-订阅模式的几点说明：</p>
<ul>
<li>订阅者可以连接多个发布者，轮流接收消息；</li>
<li>如果发布者没有订阅者与之相连，那它发送的消息将直接被丢弃；</li>
<li>如果你使用TCP协议，那当订阅者处理速度过慢时，消息会在发布者处堆积。以后我们会讨论如何使用阈值（HWM）来保护发布者。</li>
<li>在目前版本的ZMQ中，消息的过滤是在订阅者处进行的。也就是说，发布者会向订阅者发送所有的消息，订阅者会将未订阅的消息丢弃。</li>
</ul>
<p>我在自己的四核计算机上尝试发布1000万条消息，速度很快，但没什么特别的：</p>
<pre><code>ph@ws200901:~/work/git/0MQGuide/examples/c$ time wuclient
Collecting updates from weather server...
Average temperature for zipcode &#39;10001 &#39; was 18F

real    0m5.939s
user    0m1.590s
sys     0m2.290s
</code></pre><h3 id="分布式处理"><a href="#分布式处理" class="headerlink" title="分布式处理"></a>分布式处理</h3><p>下面一个示例程序中，我们将使用ZMQ进行超级计算，也就是并行处理模型：</p>
<ul>
<li>任务分发器会生成大量可以并行计算的任务；</li>
<li>有一组worker会处理这些任务；</li>
<li>结果收集器会在末端接收所有worker的处理结果，进行汇总。</li>
</ul>
<p>现实中，worker可能散落在不同的计算机中，利用GPU（图像处理单元）进行复杂计算。下面是任务分发器的代码，它会生成100个任务，任务内容是让收到的worker延迟若干毫秒。</p>
<p><strong>taskvent: Parallel task ventilator in C</strong></p>
<pre><code class="c">//
//  任务分发器
//  绑定PUSH套接字至tcp://localhost:5557端点
//  发送一组任务给已建立连接的worker
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  用于发送消息的套接字
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_bind (sender, &quot;tcp://*:5557&quot;);

    //  用于发送开始信号的套接字
    void *sink = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sink, &quot;tcp://localhost:5558&quot;);

    printf (&quot;准备好worker后按任意键开始: &quot;);
    getchar ();
    printf (&quot;正在向worker分配任务...\n&quot;);

    //  发送开始信号
    s_send (sink, &quot;0&quot;);

    //  初始化随机数生成器
    srandom ((unsigned) time (NULL));

    //  发送100个任务
    int task_nbr;
    int total_msec = 0;     //  预计执行时间（毫秒）
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        int workload;
        //  随机产生1-100毫秒的工作量
        workload = randof (100) + 1;
        total_msec += workload;
        char string [10];
        sprintf (string, &quot;%d&quot;, workload);
        s_send (sender, string);
    }
    printf (&quot;预计执行时间: %d 毫秒\n&quot;, total_msec);
    sleep (1);              //  延迟一段时间，让任务分发完成

    zmq_close (sink);
    zmq_close (sender);
    zmq_term (context);
    return 0;
}
</code></pre>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_5.png" alt="5"></p>
<p>下面是worker的代码，它接受信息并延迟指定的毫秒数，并发送执行完毕的信号：</p>
<p><strong>taskwork: Parallel task worker in C</strong></p>
<pre><code class="c">//
//  任务执行器
//  连接PULL套接字至tcp://localhost:5557端点
//  从任务分发器处获取任务
//  连接PUSH套接字至tcp://localhost:5558端点
//  向结果采集器发送结果
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    void *context = zmq_init (1);

    //  获取任务的套接字
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_connect (receiver, &quot;tcp://localhost:5557&quot;);

    //  发送结果的套接字
    void *sender = zmq_socket (context, ZMQ_PUSH);
    zmq_connect (sender, &quot;tcp://localhost:5558&quot;);

    //  循环处理任务
    while (1) {
        char *string = s_recv (receiver);
        //  输出处理进度
        fflush (stdout);
        printf (&quot;%s.&quot;, string);

        //  开始处理
        s_sleep (atoi (string));
        free (string);

        //  发送结果
        s_send (sender, &quot;&quot;);
    }
    zmq_close (receiver);
    zmq_close (sender);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>下面是结果收集器的代码。它会收集100个处理结果，并计算总的执行时间，让我们由此判别任务是否是并行计算的。</p>
<p><strong>tasksink: Parallel task sink in C</strong></p>
<pre><code class="c">//
//  任务收集器
//  绑定PULL套接字至tcp://localhost:5558端点
//  从worker处收集处理结果
//
#include &quot;zhelpers.h&quot;

int main (void) 
{
    //  准备上下文和套接字
    void *context = zmq_init (1);
    void *receiver = zmq_socket (context, ZMQ_PULL);
    zmq_bind (receiver, &quot;tcp://*:5558&quot;);

    //  等待开始信号
    char *string = s_recv (receiver);
    free (string);

    //  开始计时
    int64_t start_time = s_clock ();

    //  确定100个任务均已处理
    int task_nbr;
    for (task_nbr = 0; task_nbr &lt; 100; task_nbr++) {
        char *string = s_recv (receiver);
        free (string);
        if ((task_nbr / 10) * 10 == task_nbr)
            printf (&quot;:&quot;);
        else
            printf (&quot;.&quot;);
        fflush (stdout);
    }
    //  计算并输出总执行时间
    printf (&quot;执行时间: %d 毫秒\n&quot;, 
        (int) (s_clock () - start_time));

    zmq_close (receiver);
    zmq_term (context);
    return 0;
}
</code></pre>
<p>一组任务的平均执行时间在5秒左右，以下是分别开始1个、2个、4个worker时的执行结果：</p>
<pre><code>#   1 worker
Total elapsed time: 5034 msec
#   2 workers
Total elapsed time: 2421 msec
#   4 workers
Total elapsed time: 1018 msec
</code></pre><p>关于这段代码的几个细节：</p>
<ul>
<li><p>worker上游和任务分发器相连，下游和结果收集器相连，这就意味着你可以开启任意多个worker。但若worker是绑定至端点的，而非连接至端点，那我们就需要准备更多的端点，并配置任务分发器和结果收集器。所以说，任务分发器和结果收集器是这个网络结构中较为稳定的部分，因此应该由它们绑定至端点，而非worker，因为它们较为动态。</p>
</li>
<li><p>我们需要做一些同步的工作，等待worker全部启动之后再分发任务。这点在ZMQ中很重要，且不易解决。连接套接字的动作会耗费一定的时间，因此当第一个worker连接成功时，它会一下收到很多任务。所以说，如果我们不进行同步，那这些任务根本就不会被并行地执行。你可以自己试验一下。</p>
</li>
<li><p>任务分发器使用PUSH套接字向worker均匀地分发任务（假设所有的worker都已经连接上了），这种机制称为<em>负载均衡</em>，以后我们会见得更多。</p>
</li>
<li><p>结果收集器的PULL套接字会均匀地从worker处收集消息，这种机制称为<em>公平队列</em>：</p>
</li>
</ul>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_6.png" alt="6"></p>
<p>管道模式也会出现慢连接的情况，让人误以为PUSH套接字没有进行负载均衡。如果你的程序中某个worker接收到了更多的请求，那是因为它的PULL套接字连接得比较快，从而在别的worker连接之前获取了额外的消息。</p>
<h3 id="使用ZMQ编程"><a href="#使用ZMQ编程" class="headerlink" title="使用ZMQ编程"></a>使用ZMQ编程</h3><p>看着这些示例程序后，你一定迫不及待想要用ZMQ进行编程了。不过在开始之前，我还有几条建议想给到你，这样可以省去未来的一些麻烦：</p>
<ul>
<li><p>学习ZMQ要循序渐进，虽然它只是一套API，但却提供了无尽的可能。一步一步学习它提供的功能，并完全掌握。</p>
</li>
<li><p>编写漂亮的代码。丑陋的代码会隐藏问题，让想要帮助你的人无从下手。比如，你会习惯于使用无意义的变量名，但读你代码的人并不知道。应使用有意义的变量名称，而不是随意起一个。代码的缩进要统一，布局清晰。漂亮的代码可以让你的世界变得更美好。</p>
</li>
<li><p>边写边测试，当代码出现问题，你就可以快速定位到某些行。这一点在编写ZMQ应用程序时尤为重要，因为很多时候你无法第一次就编写出正确的代码。</p>
</li>
<li><p>当你发现自己编写的代码无法正常工作时，你可以将其拆分成一些代码片段，看看哪段没有正确地执行。ZMQ可以让你构建非常模块化的代码，所以应该好好利用这一点。</p>
</li>
<li><p>需要时应使用抽象的方法来编写程序（类、成员函数等等），不要随意拷贝代码，因为拷贝代码的同时也是在拷贝错误。</p>
</li>
</ul>
<p>我们看看下面这段代码，是某位同仁让我帮忙修改的：</p>
<pre><code class="c">//  注意：不要使用这段代码！
static char *topic_str = &quot;msg.x|&quot;;

void* pub_worker(void* arg){
    void *ctx = arg;
    assert(ctx);

    void *qskt = zmq_socket(ctx, ZMQ_REP);
    assert(qskt);

    int rc = zmq_connect(qskt, &quot;inproc://querys&quot;);
    assert(rc == 0);

    void *pubskt = zmq_socket(ctx, ZMQ_PUB);
    assert(pubskt);

    rc = zmq_bind(pubskt, &quot;inproc://publish&quot;);
    assert(rc == 0);

    uint8_t cmd;
    uint32_t nb;
    zmq_msg_t topic_msg, cmd_msg, nb_msg, resp_msg;

    zmq_msg_init_data(&amp;topic_msg, topic_str, strlen(topic_str) , NULL, NULL);

    fprintf(stdout,&quot;WORKER: ready to recieve messages\n&quot;);
    //  注意：不要使用这段代码，它不能工作！
    //  e.g. topic_msg will be invalid the second time through
    while (1){
    zmq_send(pubskt, &amp;topic_msg, ZMQ_SNDMORE);

    zmq_msg_init(&amp;cmd_msg);
    zmq_recv(qskt, &amp;cmd_msg, 0);
    memcpy(&amp;cmd, zmq_msg_data(&amp;cmd_msg), sizeof(uint8_t));
    zmq_send(pubskt, &amp;cmd_msg, ZMQ_SNDMORE);
    zmq_msg_close(&amp;cmd_msg);

    fprintf(stdout, &quot;recieved cmd %u\n&quot;, cmd);

    zmq_msg_init(&amp;nb_msg);
    zmq_recv(qskt, &amp;nb_msg, 0);
    memcpy(&amp;nb, zmq_msg_data(&amp;nb_msg), sizeof(uint32_t));
    zmq_send(pubskt, &amp;nb_msg, 0);
    zmq_msg_close(&amp;nb_msg);

    fprintf(stdout, &quot;recieved nb %u\n&quot;, nb);

    zmq_msg_init_size(&amp;resp_msg, sizeof(uint8_t));
    memset(zmq_msg_data(&amp;resp_msg), 0, sizeof(uint8_t));
    zmq_send(qskt, &amp;resp_msg, 0);
    zmq_msg_close(&amp;resp_msg);

    }
    return NULL;
}
</code></pre>
<p>下面是我为他重写的代码，顺便修复了一些BUG：</p>
<pre><code class="c">static void *
worker_thread (void *arg) {
    void *context = arg;
    void *worker = zmq_socket (context, ZMQ_REP);
    assert (worker);
    int rc;
    rc = zmq_connect (worker, &quot;ipc://worker&quot;);
    assert (rc == 0);

    void *broadcast = zmq_socket (context, ZMQ_PUB);
    assert (broadcast);
    rc = zmq_bind (broadcast, &quot;ipc://publish&quot;);
    assert (rc == 0);

    while (1) {
        char *part1 = s_recv (worker);
        char *part2 = s_recv (worker);
        printf (&quot;Worker got [%s][%s]\n&quot;, part1, part2);
        s_sendmore (broadcast, &quot;msg&quot;);
        s_sendmore (broadcast, part1);
        s_send (broadcast, part2);
        free (part1);
        free (part2);

        s_send (worker, &quot;OK&quot;);
    }
    return NULL;
}
</code></pre>
<p>上段程序的最后，它将套接字在两个线程之间传递，这会导致莫名其妙的问题。这种行为在ZMQ 2.1中虽然是合法的，但是不提倡使用。</p>
<h3 id="ZMQ-2-1版"><a href="#ZMQ-2-1版" class="headerlink" title="ZMQ 2.1版"></a>ZMQ 2.1版</h3><p>历史告诉我们，ZMQ 2.0是一个低延迟的分布式消息系统，它从众多同类软件中脱颖而出，摆脱了各种奢华的名目，向世界宣告“无极限”的口号。这是我们一直在使用的稳定发行版。</p>
<p>时过境迁，2010年流行的东西在2011年就不一定了。当ZMQ的开发者和社区开发者在激烈地讨论ZMQ的种种问题时，ZMQ 2.1横空出世了，成为新的稳定发行版。</p>
<p>本指南主要针对ZMQ 2.1进行描述，因此对于从ZMQ 2.0迁移过来的开发者来说有一些需要注意的地方：</p>
<ul>
<li><p>在2.0中，调用zmq_close()和zmq_term()时会丢弃所有尚未发送的消息，所以在发送完消息后不能直接关闭程序，2.0的示例中往往使用sleep(1)来规避这个问题。但是在2.1中就不需要这样做了，程序会等待消息全部发送完毕后再退出。</p>
</li>
<li><p>相反地，2.0中可以在尚有套接字打开的情况下调用zmq<em>term()，这在2.1中会变得不安全，会造成程序的阻塞。所以，在2.1程序中我们</em>会先关闭所有的套接字<em>，然后才退出程序。如果套接字中有尚未发送的消息，程序就会一直处于等待状态，</em>除非手工设置了套接字的LINGER选项_（如设置为零），那么套接字会在相应的时间后关闭。</p>
</li>
</ul>
<pre><code class="c">int zero = 0;
zmq_setsockopt (mysocket, ZMQ_LINGER, &amp;zero, sizeof (zero));
</code></pre>
<ul>
<li><p>2.0中，zmq_poll()函数没有定时功能，它会在满足条件时立刻返回，我们需要在循环体中检查还有多少剩余。但在2.1中，zmq_poll()会在指定时间后返回，因此可以作为定时器使用。</p>
</li>
<li><p>2.0中，ZMQ会忽略系统的中断消息，这就意味着对libzmq的调用是不会收到EINTR消息的，这样就无法对SIGINT（Ctrl-C）等消息进行处理了。在2.1中，这个问题得以解决，像类似zmq_recv()的方法都会接收并返回系统的EINTR消息。</p>
</li>
</ul>
<h3 id="正确地使用上下文"><a href="#正确地使用上下文" class="headerlink" title="正确地使用上下文"></a>正确地使用上下文</h3><p>ZMQ应用程序的一开始总是会先创建一个上下文，并用它来创建套接字。在C语言中，创建上下文的函数是zmq_init()。一个进程中只应该创建一个上下文。从技术的角度来说，上下文是一个容器，包含了该进程下所有的套接字，并为inproc协议提供实现，用以高速连接进程内不同的线程。如果一个进程中创建了两个上下文，那就相当于启动了两个ZMQ实例。如果这正是你需要的，那没有问题，但一般情况下：</p>
<p><strong>在一个进程中使用zmq_init()函数创建一个上下文，并在结束时使用zmq_term()函数关闭它</strong></p>
<p>如果你使用了fork()系统调用，那每个进程需要自己的上下文对象。如果在调用fork()之前调用了zmq_init()函数，那每个子进程都会有自己的上下文对象。通常情况下，你会需要在子进程中做些有趣的事，而让父进程来管理它们。</p>
<h3 id="正确地退出和清理"><a href="#正确地退出和清理" class="headerlink" title="正确地退出和清理"></a>正确地退出和清理</h3><p>程序员的一个良好习惯是：总是在结束时进行清理工作。当你使用像Python那样的语言编写ZMQ应用程序时，系统会自动帮你完成清理。但如果使用的是C语言，那就需要小心地处理了，否则可能发生内存泄露、应用程序不稳定等问题。</p>
<p>内存泄露只是问题之一，其实ZMQ是很在意程序的退出方式的。个中原因比较复杂，但简单的来说，如果仍有套接字处于打开状态，调用zmq_term()时会导致程序挂起；就算关闭了所有的套接字，如果仍有消息处于待发送状态，zmq_term()也会造成程序的等待。只有当套接字的LINGER选项设为0时才能避免。</p>
<p>我们需要关注的ZMQ对象包括：消息、套接字、上下文。好在内容并不多，至少在一般的应用程序中是这样：</p>
<ul>
<li>处理完消息后，记得用zmq_msg_close()函数关闭消息；</li>
<li>如果你同时打开或关闭了很多套接字，那可能需要重新规划一下程序的结构了；</li>
<li>退出程序时，应该先关闭所有的套接字，最后调用zmq_term()函数，销毁上下文对象。</li>
</ul>
<p>如果要用ZMQ进行多线程的编程，需要考虑的问题就更多了。我们会在下一章中详述多线程编程，但如果你耐不住性子想要尝试一下，以下是在退出时的一些建议：</p>
<ul>
<li>不要在多个线程中使用同一个套接字。不要去想为什么，反正别这么干就是了。</li>
<li>关闭所有的套接字，并在主程序中关闭上下文对象。</li>
<li>如果仍有处于阻塞状态的recv或poll调用，应该在主程序中捕捉这些错误，并在相应的线程中关闭套接字。不要重复关闭上下文，zmq_term()函数会等待所有的套接字安全地关闭后才结束。</li>
</ul>
<p>看吧，过程是复杂的，所以不同语言的API实现者可能会将这些步骤封装起来，让结束程序变得不那么复杂。</p>
<h3 id="我们为什么需要ZMQ"><a href="#我们为什么需要ZMQ" class="headerlink" title="我们为什么需要ZMQ"></a>我们为什么需要ZMQ</h3><p>现在我们已经将ZMQ运行起来了，让我们回顾一下为什么我们需要ZMQ：</p>
<p>目前的应用程序很多都会包含跨网络的组件，无论是局域网还是因特网。这些程序的开发者都会用到某种消息通信机制。有些人会使用某种消息队列产品，而大多数人则会自己手工来做这些事，使用TCP或UDP协议。这些协议使用起来并不困难，但是，简单地将消息从A发给B，和在任何情况下都能进行可靠的消息传输，这两种情况显然是不同的。</p>
<p>让我们看看在使用纯TCP协议进行消息传输时会遇到的一些典型问题。任何可复用的消息传输层肯定或多或少地会要解决以下问题：</p>
<ul>
<li><p>如何处理I/O？是让程序阻塞等待响应，还是在后台处理这些事？这是软件设计的关键因素。阻塞式的I/O操作会让程序架构难以扩展，而后台处理I/O也是比较困难的。</p>
</li>
<li><p>如何处理那些临时的、来去自由的组件？我们是否要将组件分为客户端和服务端两种，并要求服务端永不消失？那如果我们想要将服务端相连怎么办？我们要每隔几秒就进行重连吗？</p>
</li>
<li><p>我们如何表示一条消息？我们怎样通过拆分消息，让其变得易读易写，不用担心缓存溢出，既能高效地传输小消息，又能胜任视频等大型文件的传输？</p>
</li>
<li><p>如何处理那些不能立刻发送出去的消息？比如我们需要等待一个网络组件重新连接的时候？我们是直接丢弃该条消息，还是将它存入数据库，或是内存中的一个队列？</p>
</li>
<li><p>要在哪里保存消息队列？如果某个组件读取消息队列的速度很慢，造成消息的堆积怎么办？我们要采取什么样的策略？</p>
</li>
<li><p>如何处理丢失的消息？我们是等待新的数据，请求重发，还是需要建立一套新的可靠性机制以保证消息不会丢失？如果这个机制自身崩溃了呢？</p>
</li>
<li><p>如果我们想换一种网络连接协议，如用广播代替TCP单播？或者改用IPv6？我们是否需要重写所有的应用程序，或者将这种协议抽象到一个单独的层中？</p>
</li>
<li><p>我们如何对消息进行路由？我们可以将消息同时发送给多个节点吗？是否能将应答消息返回给请求的发送方？</p>
</li>
<li><p>我们如何为另一种语言写一个API？我们是否需要完全重写某项协议，还是重新打包一个类库？</p>
</li>
<li><p>怎样才能做到在不同的架构之间传送消息？是否需要为消息规定一种编码？</p>
</li>
<li><p>我们如何处理网络通信错误？等待并重试，还是直接忽略或取消？</p>
</li>
</ul>
<p>我们可以找一个开源软件来做例子，如<a href="http://hadoop.apache.org/zookeeper/" target="_blank" rel="external">Hadoop Zookeeper</a>，看一下它的C语言API源码，<a href="[http://github.com/apache/zookeeper/blob/trunk/src/c/src/zookeeper.c src/c/src/zookeeper.c">src/c/src/zookeeper.c</a>。这段代码大约有3200行，没有注释，实现了一个C/S网络通信协议。它工作起来很高效，因为使用了poll()来代替select()。但是，Zookeeper应该被抽象出来，作为一种通用的消息通信层，并加以详细的注释。像这样的模块应该得到最大程度上的复用，而不是重复地制造轮子。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_7.png" alt="7"></p>
<p>但是，如何编写这样一个可复用的消息层呢？为什么长久以来人们宁愿在自己的代码中重复书写控制原始TCP套接字的代码，而不愿编写这样一个公共库呢？</p>
<p>其实，要编写一个通用的消息层是件非常困难的事，这也是为什么FOSS项目不断在尝试，一些商业化的消息产品如此之复杂、昂贵、僵硬、脆弱。2006年，iMatix设计了AMQP协议，为FOSS项目的开发者提供了可能是当时第一个可复用的消息系统。<a href="http://www.amqp.org/" target="_blank" rel="external">AMQP</a>比其他同类产品要来得好，但<a href="http://www.imatix.com/articles:whats-wrong-with-amqp" target="_blank" rel="external">仍然是复杂、昂贵和脆弱的</a>。它需要花费几周的时间去学习，花费数月的时间去创建一个真正能用的架构，到那时可能为时已晚了。</p>
<p>大多数消息系统项目，如AMQP，为了解决上面提到的种种问题，发明了一些新的概念，如“代理”的概念，将寻址、路由、队列等功能都包含了进来。结果就是在一个没有任何注释的协议之上，又构建了一个C/S协议和相应的API，让应用程序和代理相互通信。代理的确是一个不错的解决方案，帮助降低大型网络结构的复杂度。但是，在Zookeeper这样的项目中应用代理机制的消息系统，可能是件更加糟糕的事，因为这意味了需要添加一台新的计算机，并构成一个新的单点故障。代理会逐渐成为新的瓶颈，管理起来更具风险。如果软件支持，我们可以添加第二个、第三个、第四个代理，构成某种冗余容错的模式。有人就是这么做的，这让系统架构变得更为复杂，增加了隐患。</p>
<p>在这种以代理为中心的架构下，需要一支专门的运维团队。你需要昼夜不停地观察代理的状态，不时地用棍棒调教他们。你需要添加计算机，以及更多的备份机，你需要有专人管理这些机器。这样做只对那些大型的网络应用程序才有意义，因为他们有更多可移动的模块，有多个团队进行开发和维护，而且已经经过了多年的建设。</p>
<p>这样一来，中小应用程序的开发者们就无计可施了。他们只能设法避免编写网络应用程序，转而编写那些不需要扩展的程序；或者可以使用原始的方式进行网络编程，但编写的软件会非常脆弱和复杂，难以维护；亦或者他们选择一种消息通信产品，虽然能够开发出扩展性强的应用程序，但需要支付高昂的代价。似乎没有一种选择是合理的，这也是为什么在上个世纪消息系统会成为一个广泛的问题。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_8.png" alt="8"></p>
<p>我们真正需要的是这样一种消息软件，它能够做大型消息软件所能做的一切，但使用起来又非常简单，成本很低，可以用到所有的应用程序中，没有任何依赖条件。因为没有了额外的模块，就降低了出错的概率。这种软件需要能够在所有的操作系统上运行，并能支持所有的编程语言。</p>
<p>ZMQ就是这样一种软件：它高效，提供了嵌入式的类库，使应用程序能够很好地在网络中扩展，成本低廉。</p>
<p>ZMQ的主要特点有：</p>
<ul>
<li>ZMQ会在后台线程异步地处理I/O操作，它使用一种不会死锁的数据结构来存储消息。</li>
<li>网络组件可以来去自如，ZMQ会负责自动重连，这就意味着你可以以任何顺序启动组件；用它创建的面向服务架构（SOA）中，服务端可以随意地加入或退出网络。</li>
<li>ZMQ会在有必要的情况下自动将消息放入队列中保存，一旦建立了连接就开始发送。</li>
<li>ZMQ有阈值（HWM）的机制，可以避免消息溢出。当队列已满，ZMQ会自动阻塞发送者，或丢弃部分消息，这些行为取决于你所使用的消息模式。</li>
<li>ZMQ可以让你用不同的通信协议进行连接，如TCP、广播、进程内、进程间。改变通信协议时你不需要去修改代码。</li>
<li>ZMQ会恰当地处理速度较慢的节点，会根据消息模式使用不同的策略。</li>
<li>ZMQ提供了多种模式进行消息路由，如请求-应答模式、发布-订阅模式等。这些模式可以用来搭建网络拓扑结构。</li>
<li>ZMQ中可以根据消息模式建立起一些中间装置（很小巧），可以用来降低网络的复杂程度。</li>
<li>ZMQ会发送整个消息，使用消息帧的机制来传递。如果你发送了10KB大小的消息，你就会收到10KB大小的消息。</li>
<li>ZMQ不强制使用某种消息格式，消息可以是0字节的，或是大到GB级的数据。当你表示这些消息时，可以选用诸如谷歌的protocol buffers，XDR等序列化产品。</li>
<li>ZMQ能够智能地处理网络错误，有时它会进行重试，有时会告知你某项操作发生了错误。</li>
<li>ZMQ甚至可以降低对环境的污染，因为节省了CPU时间意味着节省了电能。</li>
</ul>
<p>其实ZMQ可以做的还不止这些，它会颠覆人们编写网络应用程序的模式。虽然从表面上看，它不过是提供了一套处理套接字的API，能够用zmq_recv()和zmq_send()进行消息的收发，但是，消息处理将成为应用程序的核心部分，很快你的程序就会变成一个个消息处理模块，这既美观又自然。它的扩展性还很强，每项任务由一个节点（节点是一个线程）、同一台机器上的两个节点（节点是一个进程）、同一网络上的两台机器（节点是一台机器）来处理，而不需要改动应用程序。</p>
<h3 id="套接字的扩展性"><a href="#套接字的扩展性" class="headerlink" title="套接字的扩展性"></a>套接字的扩展性</h3><p>我们来用实例看看ZMQ套接字的扩展性。这个脚本会启动气象信息服务及多个客户端：</p>
<pre><code>wuserver &amp;
wuclient 12345 &amp;
wuclient 23456 &amp;
wuclient 34567 &amp;
wuclient 45678 &amp;
wuclient 56789 &amp;
</code></pre><p>执行过程中，我们可以通过top命令查看进程状态（以下是一台四核机器的情况）：</p>
<pre><code>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 7136 ph        20   0 1040m 959m 1156 R  157 12.0  16:25.47 wuserver
 7966 ph        20   0 98608 1804 1372 S   33  0.0   0:03.94 wuclient
 7963 ph        20   0 33116 1748 1372 S   14  0.0   0:00.76 wuclient
 7965 ph        20   0 33116 1784 1372 S    6  0.0   0:00.47 wuclient
 7964 ph        20   0 33116 1788 1372 S    5  0.0   0:00.25 wuclient
 7967 ph        20   0 33072 1740 1372 S    5  0.0   0:00.35 wuclient
</code></pre><p>我们想想现在发生了什么：气象信息服务程序有一个单独的套接字，却能同时向五个客户端并行地发送消息。我们可以有成百上千个客户端并行地运作，服务端看不到这些客户端，不能操纵它们。</p>
<h3 id="如果解决丢失消息的问题"><a href="#如果解决丢失消息的问题" class="headerlink" title="如果解决丢失消息的问题"></a>如果解决丢失消息的问题</h3><p>在编写ZMQ应用程序时，你遇到最多的问题可能是无法获得消息。下面有一个问题解决路线图，列举了最基本的出错原因。不用担心其中的某些术语你没有见过，在后面的几章里都会讲到。</p>
<p><img src="https://github.com/anjuke/zguide-cn/raw/master/images/chapter1_9.png" alt="9"></p>
<p>如果ZMQ在你的应用程序中扮演非常重要的角色，那你可能就需要好好计划一下了。首先，创建一个原型，用以测试设计方案的可行性。采取一些压力测试的手段，确保它足够的健壮。其次，主攻测试代码，也就是编写测试框架，保证有足够的电力供应和时间，来进行高强度的测试。理想状态下，应该由一个团队编写程序，另一个团队负责击垮它。最后，让你的公司及时<a href="http://www.imatix.com/contact" target="_blank" rel="external">联系iMatix</a>，获得技术上的支持。</p>
<p>简而言之，如果你没有足够理由说明设计出来的架构能够在现实环境中运行，那么很有可能它就会在最紧要的关头崩溃。</p>
<h3 id="警告：你的想法可能会被颠覆！"><a href="#警告：你的想法可能会被颠覆！" class="headerlink" title="警告：你的想法可能会被颠覆！"></a>警告：你的想法可能会被颠覆！</h3><p>传统网络编程的一个规则是套接字只能和一个节点建立连接。虽然也有广播的协议，但毕竟是第三方的。当我们认定“一个套接字 = 一个连接”的时候，我们会用一些特定的方式来扩展应用程序架构：我们为每一块逻辑创建线程，该线程独立地维护一个套接字。</p>
<p>但在ZMQ的世界里，套接字是智能的、多线程的，能够自动地维护一组完整的连接。你无法看到它们，甚至不能直接操纵这些连接。当你进行消息的收发、轮询等操作时，只能和ZMQ套接字打交道，而不是连接本身。所以说，ZMQ世界里的连接是私有的，不对外部开放，这也是ZMQ易于扩展的原因之一。</p>
<p>由于你的代码只会和某个套接字进行通信，这样就可以处理任意多个连接，使用任意一种网络协议。而ZMQ的消息模式又可以进行更为廉价和便捷的扩展。</p>
<p>这样一来，传统的思维就无法在ZMQ的世界里应用了。在你阅读示例程序代码的时候，也许你脑子里会想方设法地将这些代码和传统的网络编程相关联：当你读到“套接字”的时候，会认为它就表示与另一个节点的连接——这种想法是错误的；当你读到“线程”时，会认为它是与另一个节点的连接——这也是错误的。</p>
<p>如果你是第一次阅读本指南，使用ZMQ进行了一两天的开发（或者更长），可能会觉得疑惑，ZMQ怎么会让事情便得如此简单。你再次尝试用以往的思维去理解ZMQ，但又无功而返。最后，你会被ZMQ的理念所折服，拨云见雾，开始享受ZMQ带来的乐趣。</p>
]]></content>
      
        <categories>
            
            <category> 网络编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zmq,网络编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[各大公司git地址]]></title>
      <url>/2017/12/13/%E5%90%84%E5%A4%A7%E5%85%AC%E5%8F%B8git%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<blockquote>
<p>github,一个神奇的网址<br>gitbook，另一个神奇的网址，.com,.net,.cn都可以逛一下</p>
</blockquote>
<a id="more"></a>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p><a href="https://github.com/baidu" target="_blank" rel="external">https://github.com/baidu</a><br><a href="https://github.com/baidufe" target="_blank" rel="external">https://github.com/baidufe</a><br><a href="https://github.com/ecomfe" target="_blank" rel="external">https://github.com/ecomfe</a></p>
<h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p><a href="https://github.com/alibaba" target="_blank" rel="external">https://github.com/alibaba</a></p>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p><a href="https://github.com/tencent" target="_blank" rel="external">https://github.com/tencent</a><br><a href="https://github.com/AlloyTeam" target="_blank" rel="external">https://github.com/AlloyTeam</a><br><a href="https://github.com/TencentOpen" target="_blank" rel="external">https://github.com/TencentOpen</a></p>
<h2 id="360"><a href="#360" class="headerlink" title="360"></a>360</h2><p><a href="https://github.com/Qihoo360" target="_blank" rel="external">https://github.com/Qihoo360</a></p>
<h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><p><a href="https://github.com/netease" target="_blank" rel="external">https://github.com/netease</a></p>
<h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><p><a href="https://github.com/jcloudpub" target="_blank" rel="external">https://github.com/jcloudpub</a></p>
<h2 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h2><p><a href="https://github.com/huawei-openlab" target="_blank" rel="external">https://github.com/huawei-openlab</a><br><a href="https://github.com/Huawei-Hadoop" target="_blank" rel="external">https://github.com/Huawei-Hadoop</a></p>
<h2 id="唯品会"><a href="#唯品会" class="headerlink" title="唯品会"></a>唯品会</h2><p><a href="https://github.com/vipshop" target="_blank" rel="external">https://github.com/vipshop</a></p>
<h2 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h2><p><a href="https://github.com/douban" target="_blank" rel="external">https://github.com/douban</a></p>
<h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><p><a href="https://github.com/xiaomi" target="_blank" rel="external">https://github.com/xiaomi</a></p>
<h2 id="美团，大众点评"><a href="#美团，大众点评" class="headerlink" title="美团，大众点评"></a>美团，大众点评</h2><p><a href="https://github.com/meituan" target="_blank" rel="external">https://github.com/meituan</a><br><a href="https://github.com/meituan-dianping" target="_blank" rel="external">https://github.com/meituan-dianping</a><br><a href="https://github.com/dianping" target="_blank" rel="external">https://github.com/dianping</a></p>
<h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><p><a href="https://github.com/58code" target="_blank" rel="external">https://github.com/58code</a></p>
<h2 id="当当"><a href="#当当" class="headerlink" title="当当"></a>当当</h2><p><a href="https://github.com/dangdangdotcom" target="_blank" rel="external">https://github.com/dangdangdotcom</a></p>
<h2 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h2><p><a href="https://github.com/linuxdeepin" target="_blank" rel="external">https://github.com/linuxdeepin</a></p>
<h2 id="新浪"><a href="#新浪" class="headerlink" title="新浪"></a>新浪</h2><p><a href="https://github.com/fastos" target="_blank" rel="external">https://github.com/fastos</a><br><a href="https://github.com/CNSRE" target="_blank" rel="external">https://github.com/CNSRE</a><br><a href="https://github.com/weibocom" target="_blank" rel="external">https://github.com/weibocom</a></p>
<h2 id="搜狐"><a href="#搜狐" class="headerlink" title="搜狐"></a>搜狐</h2><p><a href="https://github.com/SOHUDBA" target="_blank" rel="external">https://github.com/SOHUDBA</a></p>
<h2 id="豌豆荚"><a href="#豌豆荚" class="headerlink" title="豌豆荚"></a>豌豆荚</h2><p><a href="https://github.com/CodisLabs" target="_blank" rel="external">https://github.com/CodisLabs</a></p>
<h2 id="谷歌"><a href="#谷歌" class="headerlink" title="谷歌"></a>谷歌</h2><p><a href="https://github.com/google" target="_blank" rel="external">https://github.com/google</a></p>
<h2 id="微软"><a href="#微软" class="headerlink" title="微软"></a>微软</h2><p><a href="https://github.com/Microsoft" target="_blank" rel="external">https://github.com/Microsoft</a></p>
<h2 id="苹果"><a href="#苹果" class="headerlink" title="苹果"></a>苹果</h2><p><a href="https://github.com/apple" target="_blank" rel="external">https://github.com/apple</a></p>
<h2 id="亚马逊"><a href="#亚马逊" class="headerlink" title="亚马逊"></a>亚马逊</h2><p><a href="https://github.com/aws" target="_blank" rel="external">https://github.com/aws</a></p>
<h2 id="facebook"><a href="#facebook" class="headerlink" title="facebook"></a>facebook</h2><p><a href="https://github.com/facebook" target="_blank" rel="external">https://github.com/facebook</a></p>
<h2 id="雅虎"><a href="#雅虎" class="headerlink" title="雅虎"></a>雅虎</h2><p><a href="https://github.com/yahoo" target="_blank" rel="external">https://github.com/yahoo</a></p>
]]></content>
      
        <categories>
            
            <category> 项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pthread常用接口]]></title>
      <url>/2017/12/08/pthread%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<h2 id="pthread-equal函数"><a href="#pthread-equal函数" class="headerlink" title="pthread_equal函数"></a>pthread_equal函数</h2><p>判断两个线程ID是否相等<br><code>int pthread_equal(pthread_t tid1,pthread tid2);</code></p>
<ul>
<li>参数：<ul>
<li>tid1：第一个线程ID</li>
<li>tid2：第二个线程ID</li>
</ul>
</li>
<li>返回值：<br>  -相等：返回非0数值<ul>
<li>不等：返回 0</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="pthread-self-void-函数"><a href="#pthread-self-void-函数" class="headerlink" title="pthread_self(void)函数"></a>pthread_self(void)函数</h2><p>返回本线程自身的线程ID<br><code>pthread_t pthread_self(void);</code></p>
<ul>
<li>返回值：调用线程的线程ID</li>
</ul>
<h2 id="pthread-create函数"><a href="#pthread-create函数" class="headerlink" title="pthread_create函数"></a>pthread_create函数</h2><p>创建新线程<br><code>int pthread_create(pthread_t *restrict tidp,</code><br><code>const pthread_attr_t *restrict attr,</code><br><code>void *(*start_rtn)(void*),</code><br><code>void *restrict arg);</code></p>
<ul>
<li>参数：<ul>
<li>tidp：成功创建时，新线程的线程ID存放在tidp指向的内存单元</li>
<li>attr：用于定制不同的线程属性。如果为NULL，则是默认属性</li>
<li>start_rtn：线程例程地址。新创建的线程从start_rtn函数的地址处开始运行，该函数的参数为void <em>，返回值为void </em></li>
<li>arg：作为start_rtn函数的参数</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回错误编号</li>
</ul>
</li>
</ul>
<h2 id="pthread-exit函数"><a href="#pthread-exit函数" class="headerlink" title="pthread_exit函数"></a>pthread_exit函数</h2><p>线程主动退出<br>void pthread_exit(void *rval_ptr);<br>    参数：<br>        rval_ptr：一个无类型指针，用于给pthread_join函数传递参数（即线程间消息传递）</p>
<h2 id="pthread-join函数"><a href="#pthread-join函数" class="headerlink" title="pthread_join函数"></a>pthread_join函数</h2><p>等待指定的线程结束（类似于waitpid）<br><code>int pthread_join(pthread_t tid,void **rval_pptr);</code></p>
<ul>
<li>参数：<ul>
<li>tid：要等待的线程的线程ID</li>
<li>rval_pptr：一个指针，指向无类型指针（该无类型指针用于线程返回值）</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回错误编号</li>
<li>当调用线程调用pthread_join之后，调用线程将会一直阻塞，直到:<ul>
<li>指定的线程tid调用pthread_exit。此时rval_pptr指向的内存区就包含pthread_exit的rval_ptr的值</li>
<li>指定的线程tid从启动例程返回。此时rval_pptr指向的内存区就包含返回码</li>
<li>指定的线程tid被取消。此时rval_pptr指向的内存单元就设置为PTHREAD_CANCELED</li>
</ul>
</li>
<li>如果不关注线程的返回值，则可以将rval_pptr设置为NULL。此时pthread_join函数可以等待指定的线程终止，但是并不获取线程的终止状态。</li>
<li>可以通过调用pthread_join自动把线程置于分离状态，此时资源可以恢复。如果线程已经处理分离状态，pthread_join调用就会失败，返回EINVAL</li>
</ul>
</li>
</ul>
<h2 id="pthread-cancel函数"><a href="#pthread-cancel函数" class="headerlink" title="pthread_cancel函数"></a>pthread_cancel函数</h2><p>请求取消同一个进程中的其他某个线程<br><code>int pthread_cancel(pthread_t tid);</code></p>
<ul>
<li>参数：<ul>
<li>tid：期望取消的线程的ID</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回错误码</li>
</ul>
</li>
<li>默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现得如同调用了pthread_exit(PTHREAD_CANCELD)函数。但是，tid标识的线程可以选择忽略取消或者控制如何被取消。</li>
<li>pthread_cancel并不等待线程tid终止，也不保证线程tid终止，它仅仅提出了请求</li>
</ul>
<h2 id="pthread-clearnup-push-pthread-cleanup-pop函数"><a href="#pthread-clearnup-push-pthread-cleanup-pop函数" class="headerlink" title="pthread_clearnup_push/pthread_cleanup_pop函数"></a>pthread_clearnup_push/pthread_cleanup_pop函数</h2><p>注册与注销清理处理程序<br>一个线程可以建立多个清理处理程序<br>处理程序记录在栈中。即它们的执行顺序与它们注册时相反</p>
<p><code>void pthread_cleanup_push(void (*rtn)(void*),void *arg);</code><br><code>void pthread_cleanup_pop(int execute);</code></p>
<ul>
<li>对于 pthread_cleanup_push函数：<ul>
<li>rtn：清理处理程序的指针。rtn函数的参数是void *，返回void</li>
<li>arg：作为清理处理程序rtn的参数</li>
</ul>
</li>
<li>对于pthread_cleanup_pop函数：<ul>
<li>execute：如果为0，则线程退出时，清理函数不被调用（哪个清理函数？见后面说明）</li>
<li>execute：如果非零，则线程退出时，对应的清理函数被调用</li>
</ul>
</li>
</ul>
<h2 id="pthread-detach函数"><a href="#pthread-detach函数" class="headerlink" title="pthread_detach函数"></a>pthread_detach函数</h2><p>将指定线程设置为分离状态<br><code>int pthread_detach(pthread_t tid);</code></p>
<ul>
<li>参数：<ul>
<li>tid：被分离的线程的ID</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回错误码</li>
</ul>
</li>
</ul>
<h2 id="pthread-mutex-t-pthread-mutex-init-pthread-mutex-destroy"><a href="#pthread-mutex-t-pthread-mutex-init-pthread-mutex-destroy" class="headerlink" title="pthread_mutex_t/pthread_mutex_init/pthread_mutex_destroy"></a>pthread_mutex_t/pthread_mutex_init/pthread_mutex_destroy</h2><p>互斥量用pthread_mutex_t数据类型表示</p>
<ul>
<li>使用互斥量之前必须初始化。<ul>
<li>如果是动态分配的互斥量（如通过malloc函数），则必须调用pthread_mutex_init函数进行初始化</li>
<li>如果是静态分配的互斥量，那么除了调用pthread_mutex_init函数来初始化，也可以将它设置为常量PTHREAD_MUTEX_INITALIZER来初始化</li>
</ul>
</li>
<li>如果是动态分配的互斥量，那么在free释放内存之前必须调用pthread_mutex_destroy函数来销毁互斥量。该函数会释放在动态初始化互斥量时动态分配的资源<pre><code class="C">#include&lt;pthread.h&gt;
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
  const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
</code></pre>
</li>
<li>参数：<ul>
<li>mutex：待初始化/释放的互斥量的地址</li>
<li>attr：互斥量的属性。如果为NULL，那么互斥量设置为默认属性</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号</li>
</ul>
</li>
</ul>
<h2 id="pthread-mutex-lock-pthread-mutex-trylock-pthread-mutex-unlock函数"><a href="#pthread-mutex-lock-pthread-mutex-trylock-pthread-mutex-unlock函数" class="headerlink" title="pthread_mutex_lock/pthread_mutex_trylock/pthread_mutex_unlock函数"></a>pthread_mutex_lock/pthread_mutex_trylock/pthread_mutex_unlock函数</h2><p>对互斥量加锁/解锁操作</p>
<pre><code class="C">#include&lt;pthread.h&gt;
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
</code></pre>
<ul>
<li>参数：<ul>
<li>mutex：待加锁/解锁的互斥量的地址</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号</li>
</ul>
</li>
<li>用法：<ul>
<li>pthread_mutex_lock用于对互斥量进行加锁。如果互斥量已经上锁，则调用线程将阻塞直到互斥量解锁</li>
<li>pthread_mutex_unlock用于对互斥量进行解锁</li>
<li>pthread_mutex_trylock也用于对互斥量进行加锁<ul>
<li>如果它被调用时，互斥量处于未锁定状态，那么函数将锁住互斥量并返回0</li>
<li>如果它被调用时，互斥量处于锁定状态，则函数调用失败，立即返回EBUSY而不是阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pthread-mutex-timedlock函数"><a href="#pthread-mutex-timedlock函数" class="headerlink" title="pthread_mutex_timedlock函数"></a>pthread_mutex_timedlock函数</h2><p>对互斥量加锁或等待指定时间</p>
<pre><code class="C">#include&lt;pthread.h&gt;
#include&lt;time.h&gt;
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
    const struct timespec *restrict tsptr);
</code></pre>
<ul>
<li>参数：<ul>
<li>mutex：待加锁的互斥量的地址</li>
<li>tsptr(超时时间)：指向一个timespec的指针，该timepsec指定了一个绝对时间（并不是相对时间，比如10秒）</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号</li>
</ul>
</li>
<li>pthread_mutex_timedlock被调用时：<ul>
<li>如果互斥量处于未锁定状态，那么函数将锁住互斥量并返回0</li>
<li>如果互斥量处于锁定状态，那么函数将阻塞到tsptr指定的时刻。在到达超时时刻时，pthread_mutex_timedlock不再试图对互斥量进行加锁，而是返回错误码ETIMEOUT</li>
<li>可以使用clock_gettime函数获取timespec结构表示的当前时间。但是目前并不是所有平台都支持这个函数。因此也可以用gettimeofday函数获取timeval结构表示的当前时间，然后将这个时间转换为timespec结构。</li>
</ul>
</li>
</ul>
<h2 id="pthread-rwlock-t、pthread-rwlock-init、pthread-rwlock-destroy"><a href="#pthread-rwlock-t、pthread-rwlock-init、pthread-rwlock-destroy" class="headerlink" title="pthread_rwlock_t、pthread_rwlock_init、pthread_rwlock_destroy"></a>pthread_rwlock_t、pthread_rwlock_init、pthread_rwlock_destroy</h2><ul>
<li>当读写锁是写锁定状态时，在该锁被解锁之前，所有试图对这个锁加锁（无论是加读锁还是价写锁）的线程都会被阻塞</li>
<li><p>当读写锁是读锁定状态时，所有试图对它加读锁的线程都可以获得访问权，但是所有试图对它加写锁的线程都会被阻塞</p>
</li>
<li><p>使用读写锁之前必须初始化。</p>
<ul>
<li>如果是动态分配的读写锁（如通过malloc函数），则必须调用pthread_rwlock_init函数进行初始化</li>
<li>如果是静态分配的读写锁，那么除了调用pthread_rwlock_init函数来初始化，也可以将它设置为常量PTHREAD_RWLOCK_INITALIZER来初始化</li>
</ul>
</li>
<li>如果是动态分配的读写锁，那么在free释放内存之前必须调用pthread_rwlock_destroy函数来销毁读写锁。该函数会释放在动态初始化读写锁时动态分配的资源<pre><code class="C">#include&lt;pthread.h&gt;
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
  const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
</code></pre>
</li>
<li>参数：<ul>
<li>rwlock：待初始化/销毁的读写锁的地址</li>
<li>attr：读写锁的属性。如果为NULL，那么读写锁设置为默认属性</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号</li>
</ul>
</li>
</ul>
<h2 id="pthread-rwlock-rdlock-pthread-rwlock-wrlock-pthread-rwlock-unlock函数"><a href="#pthread-rwlock-rdlock-pthread-rwlock-wrlock-pthread-rwlock-unlock函数" class="headerlink" title="pthread_rwlock_rdlock/pthread_rwlock_wrlock/pthread_rwlock_unlock函数"></a>pthread_rwlock_rdlock/pthread_rwlock_wrlock/pthread_rwlock_unlock函数</h2><p>对读写锁加锁/解锁操作</p>
<pre><code class="C">#include&lt;pthread.h&gt;
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
</code></pre>
<ul>
<li>参数：<ul>
<li>rwlock：待加锁/解锁的读写锁的地址</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号</li>
</ul>
</li>
<li><p>用法：</p>
<ul>
<li>pthread_rwlock_rdlock用于对读写锁加读锁。如果读写锁当前是未加锁的，或者是读锁定的，则加锁成功；如果读写锁当前是写锁定的，则阻塞线程。</li>
<li>pthread_rwlock_wrlock用于对读写锁加写锁。如果读写锁当前是未加锁的，则加锁成功；如果读写锁当前是读锁定或者写锁定的，则阻塞线程。</li>
<li>pthread_rwlock_unlock用于对读写锁进行解锁，无论读写锁当前状态是处于读锁定还是写锁定。<blockquote>
<p>注意：有的实现对读写锁同时加读锁的数量有限制。并不是无限制的加读锁。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="pthread-rwlock-tryrdlock-pthread-rwlock-trywrlock函数"><a href="#pthread-rwlock-tryrdlock-pthread-rwlock-trywrlock函数" class="headerlink" title="pthread_rwlock_tryrdlock/pthread_rwlock_trywrlock函数"></a>pthread_rwlock_tryrdlock/pthread_rwlock_trywrlock函数</h2><p>对读写锁加锁的条件版本</p>
<pre><code>#include&lt;pthread.h&gt;
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
</code></pre><ul>
<li>参数：<ul>
<li>rwlock：待加锁的读写锁的地址</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号<blockquote>
<p>当可以加锁时，这两个函数返回0。否则它们返回错误EBUSY而不是阻塞线程。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="pthread-rwlock-timedrdlock-pthread-rwlock-timedwrlock函数"><a href="#pthread-rwlock-timedrdlock-pthread-rwlock-timedwrlock函数" class="headerlink" title="pthread_rwlock_timedrdlock/pthread_rwlock_timedwrlock函数"></a>pthread_rwlock_timedrdlock/pthread_rwlock_timedwrlock函数</h2><p>对读写锁加锁的超时版本</p>
<pre><code>#include&lt;pthread.h&gt;
#include&lt;time.h&gt;
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock,
    const struct timespect*restrict tsptr);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock,
    const struct timespect*restrict tsptr);
</code></pre><ul>
<li>参数：<ul>
<li>rwlock：待加锁的读写锁的地址</li>
<li>tsptr：指向一个timespec的指针，该timepsec指定了一个绝对时间（并不是相对时间，比如10秒）</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回0</li>
<li>失败： 返回错误编号<br>这两个函数被调用时：</li>
</ul>
</li>
<li>如果允许加锁，那么函数将对读写锁加锁并返回0</li>
<li>如果不允许加锁，那么函数将阻塞到tsptr指定的时刻。在到达超时时刻时，pthread_mutex_timedlock不再试图对读写锁进行加锁，而是返回错误码ETIMEOUT<blockquote>
<p>可以使用clock_gettime函数获取timespec结构表示的当前时间。但是目前并不是所有平台都支持这个函数。因此也可以用gettimeofday函数获取timeval结构表示的当前时间，然后将这个时间转换为timespec结构。</p>
</blockquote>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pthread,多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[标准IO库]]></title>
      <url>/2017/12/04/%E6%A0%87%E5%87%86IO%E5%BA%93/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="流和-FILE对象"><a href="#流和-FILE对象" class="headerlink" title="流和 FILE对象"></a>流和 FILE对象</h2><ol>
<li><p>标准IO库与文件IO区别：</p>
<ul>
<li>标准IO库处理很多细节，如缓冲区分片、以优化的块长度执行IO等。</li>
<li>文件IO函数都是围绕文件描述符进行。首先打开一个文件，返回一个文件描述符；后续的文件IO操作都使用该文件描述符</li>
<li>标准IO库是围绕流进行的。当用标准IO库打开或者创建一个文件时，就有一个内建的流与之相关联<blockquote>
<p>标准IO库的函数很多都是以 <code>f</code>开头，如<code>fopen</code>、<code>fclose</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p>对于ASCII字符集，一个字符用一个字节表示；对于国际字符集，一个字符可以用多个字节表示。</p>
<ul>
<li>标准IO文件流可用于单字节或者多字节字符集。流的定向决定了所处理的字符是单字节还是多字节的。</li>
<li>当一个流最初被创建时，它并没有定向。<ul>
<li>若在未定向的流上使用一个多字节IO函数，则将该流的定向设置为宽定向的（即处理多字节）</li>
<li>若在未定向的流上使用一个单字节IO函数，则将该流的定向设置为字节定向的（即处理单字节）</li>
</ul>
</li>
<li>只有两个函数可以改变流的定向<ul>
<li><code>freopen</code>函数清除一个流的定向</li>
<li><code>fwide</code>函数设置流的定向</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fwide</code>函数：设置流的定向</p>
<pre><code> #include&lt;stdio.h&gt;
 #include&lt;wchar.h&gt;
 int fwide(FILE *fp,int mode);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：<code>FILE</code>文件对象的指针</li>
<li><code>mode</code>：流的定向模式。<ul>
<li>如果<code>mode</code>是负数，则函数试图使指定的流为字节定向（并不保证修改成功，因为<code>fwide</code>并不改变已定向流的定向）</li>
<li>如果<code>mode</code>是正数，则函数试图使指定的流为宽定向的（并不保证修改成功，因为<code>fwide</code>并不改变已定向流的定向）</li>
<li>如果<code>mode</code>为0，则函数不试图设置流的定向，而直接返回该流定向的值</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>若流是宽定向的，返回正值</li>
<li>若流是字节定向的，返回负值</li>
<li>若流是未定向的，返回0<blockquote>
<p>这里并没有函数失败的情况</p>
</blockquote>
</li>
</ul>
<p>注意：</p>
</li>
<li><code>fwide</code>并不改变已定向流的定向。</li>
<li>如果<code>fp</code>是无效流，由于<code>fwide</code>从返回值无法得知函数执行成功还是失败。那么我们必须采用这个方法：首先在调用<code>fwide</code>之前清除<code>errno</code>。然后在<code>fwide</code>之后检查<code>errno</code>的值。通过<code>errno</code>来检测<code>fwide</code>执行成功还是失败。</li>
</ul>
</li>
<li><p><code>FILE</code>指针：当使用<code>fopen</code>函数打开一个流时，它返回一个执行<code>FILE</code>对象的指针。该对象通常是一个结构，包含了标准IO库为管理该流所需要的所有信息，包括：</p>
<ul>
<li>用于实际IO的文件描述符</li>
<li>指向用于该流缓冲区的指针</li>
<li>该流缓冲区的长度</li>
<li>当前在缓冲区中的字符数</li>
<li><p>出错标志</p>
<p>应用程序没必要检验<code>FILE</code>对象，只需要将<code>FILE</code>指针作为参数传递给每个标准IO函数。</p>
<p><img src="../imgs/std_IO/FILE_IO.JPG" alt="FILE"> </p>
</li>
</ul>
</li>
<li><p>操作系统对每个进程与定义了3个流，并且这3个流可以自动地被进程使用，他们都是定义在<code>&lt;stdio.h&gt;</code>中：</p>
<ul>
<li>标准输入：预定义的文件指针为<code>stdin</code>，它内部的文件描述符就是<code>STDIN_FILENO</code></li>
<li>标准输出：预定义的文件指针为<code>stdout</code>，它内部的文件描述符就是<code>STDOUT_FILENO</code></li>
<li>标准错误：预定义的文件指针为<code>stderr</code>，它内部的文件描述符就是<code>STDERR_FILENO</code></li>
</ul>
</li>
<li><p>标准IO库提供缓冲的目的是：尽量减少使用<code>read</code>和<code>write</code>调用的次数。标准IO库对每个IO流自动地进行缓冲管理，从而避免了程序员需要手动管理这一点带来的麻烦。</p>
<p> 标准IO库提供了三种类型的缓冲：</p>
<ul>
<li>全缓冲：此时在标准IO缓冲区被填满后，标准IO库才进行实际的IO操作。</li>
<li>行缓冲：此时当输入和输出中遇到换行符时，标准IO库执行实际的IO操作。但是注意：<ul>
<li>只要填满了缓冲区，即使还没有写一个换行符，也立即进行IO操作</li>
<li>任何时候只要通过标准IO库，从一个不带缓冲的流或者一个行缓冲的流得到输入数据，则会冲洗所有行缓冲输出流。(<font color="red">即要缓冲输入，先冲洗输出缓冲</font>)</li>
</ul>
</li>
<li><p>不带缓冲：标准IO库不对字符进行缓冲存储。此时任何IO都立即执行实际的IO操作。</p>
<p>另外：</p>
</li>
<li>在一个流上执行第一次IO操作时，相关标准的IO函数通常调用 <code>malloc</code>获取使用的缓冲区</li>
<li>缓冲区可以由标准的IO操作自动地冲洗（如，当填满一个缓冲区时），也可以手动调用<code>fflush</code>函数冲洗一个流。</li>
</ul>
</li>
<li><p>ISO C 要求下来缓冲特征：</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互式设备时，他们才是全缓冲的</li>
<li><p>标准错误绝不会是全缓冲的。</p>
<p>很多操作系统默认使用下列类型的缓冲：</p>
</li>
<li>标准错误<code>stderr</code>时不带缓冲的</li>
<li>标准输入<code>stdin</code>和输出<code>stdout</code>：若是指向终端设备的流，则是行缓冲的；否则是全缓冲的</li>
</ul>
</li>
<li><p><code>setbuf/setvbuf</code>函数：设置流的缓冲类型</p>
<pre><code> #include&lt;stdio.h&gt;
 void setbuf(FILE *restrict fp,char *restrict buf);
 int setvbuf(FILE *restrict fp,char* restrict buf,int mode,size_t size);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：被打开的文件对象的指针</li>
<li><p><code>buf</code>：一个缓冲区的指针。缓冲区长度必须为<code>BUFSIZ</code>常量（该常量定义在<code>&lt;stdio.h&gt;</code>中）。</p>
<ul>
<li>如果<code>buf</code>为<code>NULL</code>，则是关闭缓冲</li>
<li>如果<code>buf</code>非<code>NULL</code>，则通常设定该流为全缓冲的。但若该流与一个设备终端相关，则设为行缓冲的</li>
</ul>
<p>对于<code>setvbuf</code>函数：</p>
</li>
<li><code>buf</code>：一个缓冲区的指针。缓冲区长度为<code>size</code>。<ul>
<li>若<code>buf</code>为<code>NULL</code>，且<code>mode</code>为<code>_IONBF</code>：则该流为不带缓冲的。因为此时忽略<code>buf</code>和<code>size</code>参数</li>
<li>若<code>buf</code>为<code>NULL</code>，且<code>mode</code>不是<code>_IONBF</code>：则标准IO库将自动为该流分片合适长度的缓冲区（即<code>BUFSIZE</code>长度），然后设定该流为指定的<code>mode</code></li>
</ul>
</li>
<li><code>mode</code>：指定缓冲类型。可以为：<ul>
<li><code>_IOFBF</code>：全缓冲。</li>
<li><code>_IOLBF</code>：行缓冲</li>
<li><code>_IONBF</code>：不带缓冲。此时忽略<code>buf</code>和<code>size</code>参数</li>
</ul>
</li>
<li><code>size</code>：缓冲的长度</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回非0(<font color="red">并不是-1</font>)</li>
</ul>
<p>注意：</p>
</li>
<li>如果在一个函数内分配一个自动变量类型的标准IO缓冲区，则从该函数返回之前，必须关闭流。因此自动变量是栈上分配，函数返回之后自动变量被销毁</li>
<li>某些操作系统将缓冲区的一部分存放它自己的管理操作信息，因此可以存放在缓冲区中的实际数据字节数将少于<code>size</code></li>
<li>通常推荐利用操作系统自动选择缓冲区长度并自动分配缓冲区。在这种情况下若关闭此流，则标准IO库会自动释放缓冲区</li>
</ul>
</li>
<li><p><code>fflush</code>函数：手动冲洗一个流</p>
<pre><code> #include&lt;stdio.h&gt;
 int fflush(FILE *fp);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：被打开的文件对象的指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>失败：返回<code>EOF</code> (<font color="red">并不是-1</font>)</li>
</ul>
<p>该函数会使得该流所有未写的数据都被传送至内核。当<code>fp</code>为<code>NULL</code>时，此函数将导致所有输出流被冲洗。</p>
<blockquote>
<ul>
<li>冲洗是双向的：输出流 —&gt; 内核 —&gt; 磁盘或者终端； 输入流—&gt; 用户缓冲区</li>
<li>冲洗并不是立即写到磁盘文件中。冲洗只是负责数据传到内核</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="打开关闭流"><a href="#打开关闭流" class="headerlink" title="打开关闭流"></a>打开关闭流</h2><ol>
<li><p><code>fopen/freopen/fdopen</code>函数：打开标准IO流</p>
<pre><code> #include&lt;stdio.h&gt;
 FILE *fopen(const char*restrict pathname,const char*restrict type);
 FILE *freopen(const char*restrict pathname,const char*restrict type,\
     FILE *restrict fp);
 FILE *fdopen(int fd,const char*type);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>type</code>：指定对该IO流的读写方式：</p>
<ul>
<li><code>&quot;r&quot;</code>或者<code>&quot;rb&quot;</code>：为读打开</li>
<li><code>&quot;w&quot;</code>或者<code>&quot;wb&quot;</code>：写打开。若文件存在则把文件截断为0长；若文件不存在则创建然后写</li>
<li><code>&quot;a&quot;</code>或者<code>&quot;ab&quot;</code>：追加写打开；若文件存在每次都定位到文件末尾；若文件不存在则创建然后写</li>
<li><code>&quot;r+&quot;</code>或者<code>&quot;r+b&quot;</code>或者<code>&quot;rb+&quot;</code>：为读和写打开</li>
<li><code>&quot;w+&quot;</code>或者<code>&quot;w+b&quot;</code>或者<code>&quot;wb+&quot;</code>：若文件存在则文件截断为0然后读写；若文件不存在则创建然后读写</li>
<li><code>&quot;a+&quot;</code>或者<code>&quot;a+b&quot;</code>或者<code>&quot;ab+&quot;</code>：若文件存在则每次都定位到文件末尾然后读写；若文件不存在则创建然后读写<blockquote>
<ul>
<li>其中<code>b</code>用于区分二进制文件和文本文件。但是由于<code>UNIX</code>内核并不区分这两种文件，所以在UNIX环境中指定<code>b</code>并没有什么卵用</li>
<li>创建文件时，无法指定文件访问权限位。POSIX默认要求为：<code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH</code></li>
</ul>
</blockquote>
</li>
</ul>
<p>对于 <code>fopen</code>函数：</p>
</li>
<li><code>pathname</code>：待打开文件的路径名<br>对于 <code>freopen</code>函数：</li>
<li><code>pathname</code>：待打开文件的路径名</li>
<li><p><code>fp</code>：在指定的流上打开文件。若<code>fp</code>已经打开，则先关闭该流；若<code>fp</code>已经定向，则清除该定向。</p>
<p>对于 <code>fdopen</code>函数：</p>
</li>
<li><code>fd</code>：打开文件的文件描述符</li>
<li>对于<code>fopen</code>，<code>type</code>意义稍微有点区别。因为该描述符已经被打开，所以<code>fdopen</code>为写而打开并不截断该文件。另外该文件既然被打开并返回一个文件描述符，则它一定存在。因此标准 IO追加写方式也不能创建文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回文件指针</li>
<li>失败： 返回<code>NULL</code></li>
</ul>
<p>这几个函数的常见用途：</p>
</li>
<li><code>fopen</code>常用于打开一个指定的文件，返回一个文件指针</li>
<li><code>freopen</code>常用于将一个指定的文件打开为一个预定义的流（标准输入、标准输出或者标准错误）</li>
<li><p><code>fdopen</code>常用于将文件描述符包装成一个标准IO流。因为某些特殊类型的文件（如管道、<code>socket</code>文件）不能用<code>fopen</code>打开，必须先获取文件描述符，然后对文件描述符调用<code>fdopen</code>。</p>
<p>注意：当以读和写类型打开一个文件时(<code>type</code>中带<code>+</code>号的类型)，有下列限制：</p>
</li>
<li>如果写操作后面没有<code>fflush,fseek,fsetpos,rewind</code>操作之一，则写操作后面不能紧跟读操作</li>
<li><p>如果读操作后面没有<code>fseek,fsetpos,rewind</code>操作之一，也没有到达文件末尾，则在读操作之后不能紧跟写操作</p>
<p>注意：按照系统默认，流被打开时是全缓冲的。但是如果流引用的是终端设备，则安装系统默认，流被打开时是行缓冲的。</p>
</li>
</ul>
</li>
<li><p><code>fclose</code>：关闭一个打开的流</p>
<pre><code> #include&lt;stdio.h&gt;
 int fclose(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：待关闭的文件指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>在该文件被关闭之前：</p>
</li>
<li><code>fclose</code>会自动冲洗缓冲中的输出数据</li>
<li>缓冲区中的输入数据被丢弃</li>
<li><p>若该缓冲区是标准IO库自动分配的，则释放此缓冲区</p>
<p>当一个进程正常终止时（直接调用<code>exit</code>函数，或者从<code>main</code>函数返回）：</p>
</li>
<li>所有带未写缓存数据的标准IO流都被冲洗</li>
<li>所有打开的标准IO流都被关闭</li>
</ul>
</li>
<li><p>示例:在 <code>main</code>函数中调用 <code>test_fopen_fwide_setvbuf</code>函数：</p>
<pre><code>void test_fopen_fwide_setvbuf()
{
 M_TRACE(&quot;---------  Begin test_fopen_fwide_setvbuf()  ---------\n&quot;);
 assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0);

 My_fwide(stdin,0); //打印 stdin 的流向
 My_fwide(stdout,0); //打印 stdout 的流向
 My_fwide(stderr,0); //打印 stderr 的流向
 print_FILE(stdin); //打印 stdin 结构
 print_FILE(stdout); //打印 stdout 结构
 print_FILE(stderr); //打印 stderr 结构

 FILE *fp=My_fopen(&quot;test&quot;,&quot;r+&quot;);
 if(NULL!=fp)
 {
     My_fwide(fp,0); //打印 fp 的流向
     My_fwide(fp,-1); //设置 fp 为字节流 然后打印 fp 的流向
     My_fwide(fp,1); //无法修改已定向的流
     print_FILE(fp);
     //**** 设置不同的缓冲 ****//
     set_full_buf(fp);
     print_FILE(fp);
     set_line_buf(fp);
     print_FILE(fp);
     set_no_buf(fp);
     print_FILE(fp);

     fclose(fp); //关闭流
 }
 un_prepare_file(&quot;test&quot;);
 M_TRACE(&quot;---------  End test_fopen_fwide_setvbuf()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/FILE_struct.JPG" alt="FILE_struct"></p>
<p> 可以看到：</p>
<ul>
<li>三个标准IO流的文件描述符依次为 0、1、2</li>
<li>未被使用的流不会分配缓冲，因此<code>stdin</code>、<code>stderr</code>的缓冲区地址是 <code>NULL</code>。刚被创建的流的缓冲区地址也是<code>NULL</code>。</li>
<li>未被使用的流是为定向的。因此<code>stdin</code>、<code>stderr</code>是未定向的。刚被创建的流的也是未定向的</li>
<li>对已经定向的流设置流向，并不会改变流的方向。但是也不报告失败。</li>
<li>未分配缓冲区的流，与非缓冲流不是一个概念。非缓冲流是分配了缓冲区的，它的缓冲区长度为1。而未分配缓冲区的流，其缓冲区是无效待分配的。</li>
</ul>
</li>
</ol>
<h2 id="读写流"><a href="#读写流" class="headerlink" title="读写流"></a>读写流</h2><ol>
<li><p>一旦打开了流，可以在3中不同类型的非格式化IO中选择，对流进行读、写操作：</p>
<ul>
<li>每次一个字符的IO。一次读、写一个字符。若流是带缓冲的，则标准IO函数处理所有缓冲</li>
<li>每次一行的IO。一次读、写一行。每一行都以一个换行符终止</li>
<li>二进制IO。每次IO读、写某种数量的对象。<blockquote>
<p>格式化IO由<code>printf</code>族函数完成</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>getc/fgetc/getchar</code>函数：一次读一个字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 int getc(FILE*fp);
 int fgetc(FILE*fp);
 int getchar(void);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回下一个字符</li>
<li>到达文件尾端：返回<code>EOF</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>getchar()</code>等价于<code>getc(stdin)</code>。它从标准输入中读取一个字符</li>
<li><code>getc</code>和<code>fgetc</code>的区别在于：<code>getc</code>可能通过宏定义来实现，而<code>fgetc</code>不能实现为宏。因此：<ul>
<li><code>getc</code>的参数不应该是具有副作用的表达式，因为它可能被计算多次</li>
<li><code>fgetc</code>可以得到其地址，这就允许将<code>fgetc</code>的地址作为参数传递。而<code>getc</code>不行</li>
<li>调用<code>fgetc</code>所需的时间可能比调用<code>getc</code>长，因为函数调用所需时间通常比调用宏长</li>
</ul>
</li>
<li>这三个函数在返回下一个字符时，将<code>unsigned char</code>类型转换成了<code>int</code>类型。<blockquote>
<p>因为需要通过返回<code>EOF</code>来标记到达末尾或者出错。而<code>EOF</code>通常是常量 -1 。所以需要返回 <code>int</code></p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>ferror/feof</code>函数：查看是读文件出错，还是到达读文件遇到尾端</p>
<pre><code> #include&lt;stdio.h&gt;
 int ferror(FILE *fp);
 int feof(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>若条件为真：则返回非 0</li>
<li>若条件为假： 则返回 0</li>
</ul>
<p>当读流返回<code>EOF</code>时，我们可能不清楚到底是遇到错误，还是读到了文件尾端。此时必须调用<code>ferror</code>或者<code>feof</code>来区别这两种情况。</p>
</li>
</ul>
</li>
<li><p><code>clearerr</code>函数：清除文件出错标志和文件结束标志</p>
<pre><code> #include&lt;stdio.h&gt;
 void clearerr(FILE *fp)
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
<p>在大多数操作系统中，每个流在<code>FILE</code>对象中维护了两个标志：</p>
</li>
<li>出错标志</li>
<li><p>文件结束标志</p>
<p>调用<code>clearerr</code>函数可以清除这两个标志</p>
</li>
</ul>
</li>
<li><p><code>ungetc</code>函数：将字符压回流中</p>
<pre><code> #include&lt;stdio.h&gt;
 int ungetc(int c,FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>c</code>：待压入字符转换成的整数值</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回 <code>c</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li>若根据某个序列向流中压入一串字符，则再从该流中读取的字符序列是逆序的。即最后压入的字符最先读出</li>
<li>可以执行任意次数的压入单个字符，但是不支持一次压入多个字符</li>
<li><p>不能压入 <code>EOF</code>。但是当已经读到文件尾端时，支持压入一个字符，此时<code>ungetc</code>会清除该流的文件结束标志</p>
<p><code>ungetc</code>通常用于这样的情形：正在读取一个输入流，然后需要根据某个字符串（标记字符串）来对输入进行切分。那么我们就需要先看一看下一个字符，来决定如何处理当前字符。此时需要方便的将刚查看的字符回送。</p>
<blockquote>
<p><code>ungetc</code>只是将字符压入流缓冲区中，并没有压入底层的磁盘文件或者操作系统内核中</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>putc/fputc/putchar</code>函数：一次写一个字符</p>
<pre><code> #include&lt;stdio.h&gt;
 int putc(int c,FILE*fp);
 int fputc(int c,FILE*fp);
 int putchar(int c);
</code></pre><ul>
<li>参数：<ul>
<li><code>c</code>：待写字符转换成的整数值</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回 <code>c</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>putchar(c)</code>等价于<code>putc(c,stdout)</code>。它向标准输出中写一个字符</li>
<li><code>putc</code>和<code>fputc</code>的区别在于：<code>putc</code>可能通过宏定义来实现，而<code>fputc</code>不能实现为宏</li>
</ul>
</li>
<li><p><code>fgets/gets</code>函数：一次读一行字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 char *fgets(char *restrict buf,int n, FILE* restrict fp);
 char *gets(char *buf);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>buf</code>：存放读取到的字符的缓冲区地址</p>
<p>对于 <code>fgets</code>函数：</p>
</li>
<li><code>n</code>：缓冲区长度</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回<code>buf</code></li>
<li>到达文件尾端：返回<code>NULL</code></li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p>注意：</p>
</li>
<li>对于<code>fgets</code>函数，必须指定缓冲区的长度<code>n</code>。该函数一直读到下一个换行符为止，但是不超过<code>n-1</code>个字符。<ul>
<li>无论读到多少个字符，缓冲区一定以<code>null</code>字节结尾</li>
<li>若某一行包括换行符超过 <code>n-1</code>个字节，则<code>fgets</code>只返回一个不完整的行；下次调用<code>fgets</code>会继续读该行</li>
</ul>
</li>
<li>对于<code>gets</code>函数，从标准输入总读取字符。由于无法指定缓冲区的长度，因此很可能造成缓冲区溢出漏洞。故该函数不推荐使用</li>
<li>对于发生错误和读到末尾，都是返回<code>NULL</code>    </li>
</ul>
</li>
</ol>
<ol>
<li><p><code>fputs/puts</code>函数：一次写一行字符：</p>
<pre><code> #include&lt;stdio.h&gt;
 int fputs(const char* restrict str,FILE*restrict fp);
 int puts(const char*str);
</code></pre><ul>
<li>参数：<ul>
<li><code>str</code>：待写的字符串</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：则返回非负值</li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p>注意：</p>
</li>
<li><code>fputs</code>和<code>puts</code>都是将一个以<code>null</code>字节终止的字符串写到流中，末尾的<code>null</code>字符不写出！。<font color="red">字符串不要求以换行符结尾！</font></li>
<li><code>puts</code>将字符串写到标准输出，末尾的<code>null</code>字符不写出！<font color="red">但是<code>puts</code>随后又将一个换行符写到标准输出中！</font>。而<code>fputs</code>不会自动添加换行符。<blockquote>
<p>虽然<code>puts</code>是安全的，但是我们也是要避免使用它，以免要记住它在最后是否添加了一个换行符。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>fread/fwrite</code>函数：执行二进制读写IO</p>
<pre><code> #include&lt;stdio.h&gt;
 size_t fread(void *restrict ptr,size_t size,size_t nobj,FILE *restrict fp);
 size_t fwrite(const void*restrict ptr,size_t size,size_t nobj,FILE *restrict fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>ptr</code>:存放二进制数据对象的缓冲区地址</li>
<li><code>size</code>：单个二进制数据对象的字节数（比如一个<code>struct</code>的大小）</li>
<li><code>nobj</code>：二进制数据对象的数量</li>
<li><code>fp</code>：打开的文件对象指针</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功或失败： 读/写的对象数<ul>
<li>对于读：如果出错或者到达文件尾端，则此数字可以少于<code>nobj</code>。此时应调用<code>ferror</code>或者<code>feof</code>来判断究竟是那种情况</li>
<li>对于写：如果返回值少于<code>nobj</code>，则出错</li>
</ul>
</li>
</ul>
<p>使用二进制IO的基本问题是：它只能用在读取同一个操作系统上已写的数据。如果跨操作系统读写，则很可能工作异常。因为：</p>
</li>
<li>同一个<code>struct</code>，可能在不同操作系统或者不同编译系统中，成员的偏移量不同</li>
<li>存储多字节整数和浮点数的二进制格式在不同的操作系统中可能不同</li>
</ul>
</li>
</ol>
<ol>
<li><p>有三种方法定位标准IO流</p>
<ul>
<li><p>通过 <code>ftell/fseek</code>函数：</p>
<pre><code>  #include&lt;stdio.h&gt;
  long ftell(FILE *fp);
</code></pre><ul>
<li>参数：<code>fp</code>：打开的文件对象指针</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回当前文件位置指示</li>
<li><p>失败：返回 -1L</p>
<p>若是二进制文件，则文件指示器是从文件开始位置度量的，并以字节为度量单位。<code>ftell</code>就是返回这种字节位置。</p>
</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
int fseek(FILE *fp,long offset,int whence);
</code></pre></li>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>offset</code>：偏移量。其解释依赖于<code>whence</code></li>
<li><code>whence</code>：偏移量的解释方式：<ul>
<li><code>SEEK_SET</code>常量：表示从文件的起始位置开始</li>
<li><code>SEEK_CUR</code>常量：表示从文件的当前位置开始</li>
<li><code>SEEK_END</code>常量：表示从文件的尾端开始</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回 0</li>
<li><p>失败：返回 -1</p>
<blockquote>
<p>原书说，对文本文件和二进制文件，<code>fseek</code>定位有某些限制。但是经过在<code>ubuntu 16.04</code>上测试，可以任意定位。并没有要求说不能定位到文件尾端，以及必须用<code>SEEK_SET</code>等诸多限制。</p>
</blockquote>
</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
void rewind(FILE *fp);
</code></pre></li>
<li><p>参数：</p>
<ul>
<li><p><code>fp</code>：打开的文件对象指针</p>
<p><code>rewind</code>函数将一个流设置到文件的起始位置</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过 <code>ftello/fseeko</code>函数：除了偏移量类型为<code>off_t</code>而不是<code>long</code>以外，<code>ftello/fseeko</code>与<code>ftell/fseek</code>相同</p>
<pre><code>  #include&lt;stdio.h&gt;
  off_t ftello(FILE *fp);
</code></pre><ul>
<li>参数：<code>fp</code>：打开的文件对象指针</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回当前文件位置指示</li>
<li>失败：返回 (off_t)-1</li>
</ul>
<pre><code>#include&lt;stdio.h&gt;
int fseeko(FILE *fp,off_t offset,int whence);
</code></pre></li>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>offset</code>：偏移量。其解释依赖于<code>whence</code></li>
<li><code>whence</code>：偏移量的解释方式：<ul>
<li><code>SEEK_SET</code>常量：表示从文件的起始位置开始</li>
<li><code>SEEK_CUR</code>常量：表示从文件的当前位置开始</li>
<li><code>SEEK_END</code>常量：表示从文件的尾端开始</li>
</ul>
</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功：返回 0</li>
<li>失败：返回 -1</li>
</ul>
</li>
</ul>
</li>
<li><p><code>fgetpos/fsetpos</code>函数：由 ISO C 引入</p>
<pre><code>  #include&lt;stdio.h&gt;
  int fgetpos(FILE *restrict fp,fpos_t *restrict pos);
  int fsetpos(FILE * fp,const fpos_t * pos);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象指针</li>
<li><code>pos</code>：存放偏移量的缓冲区</li>
</ul>
</li>
<li>返回值：<ul>
<li>成功： 返回 0</li>
<li>失败： 返回非 0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>示例:在<code>main</code>函数中调用<code>test_get_put_seek</code> 函数：</p>
<pre><code>void test_get_put_seek()
{
M_TRACE(&quot;---------  Begin test_get_put_seek()  ---------\n&quot;);
assert(prepare_file(&quot;test_char&quot;,NULL,0,S_IRWXU)==0);
assert(prepare_file(&quot;test_line&quot;,NULL,0,S_IRWXU)==0);
assert(prepare_file(&quot;test_binary&quot;,NULL,0,S_IRWXU)==0);

FILE *file_char=My_fopen(&quot;test_char&quot;,&quot;r+&quot;);
FILE *file_line=My_fopen(&quot;test_line&quot;,&quot;r+&quot;);
FILE *file_binary=My_fopen(&quot;test_binary&quot;,&quot;rb+&quot;);

if((file_char!=NULL) &amp;&amp; (file_line!=NULL) &amp;&amp; (file_binary!=NULL))
{
    printf(&quot;***** test read write char*****\n&quot;);
    _test_read_write_char(file_char);
    printf(&quot;\n\n***** test read write str*****\n&quot;);
    _test_read_write_line(file_line);
    printf(&quot;\n\n***** test read write binary*****\n&quot;);
    _test_read_write_binary(file_binary);
}

//*** 关闭文件  ***//
if(file_char!=NULL) fclose(file_char);
if(file_line!=NULL) fclose(file_line);
if(file_binary!=NULL) fclose(file_binary);

un_prepare_file(&quot;test_char&quot;);
un_prepare_file(&quot;test_line&quot;);
un_prepare_file(&quot;test_binary&quot;);
M_TRACE(&quot;---------  End test_get_put_seek()  ---------\n\n&quot;);
}
</code></pre><p><img src="../imgs/std_IO/FILE_read_write_seek.JPG" alt="FILE_read_write_seek"></p>
</li>
</ol>
<h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><ol>
<li><p>格式化输出函数：</p>
<pre><code> #include&lt;stdio.h&gt;
 int printf(const char *restrict format,...);
 int fprintf(FILE *restrict fp,const char*restrict format,...);
 int dprintf(int fd,const char *restrict format,...);
 int sprintf(char *restrict buf,const char*restrict format,...);
 int snprintf(char *restrict buf,size_t n,const char *restrict format,...);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>format,...</code>：输出的格式化字符串</p>
<p>对于<code>fprintf</code>：</p>
</li>
<li><p><code>fp</code>：打开的文件对象指针。格式化输出到该文件中</p>
<p>对于<code>dprintf</code>：</p>
</li>
<li><p><code>fd</code>：打开文件的文件描述符。格式化输出到该文件中</p>
<p>对于<code>sprintf</code>:</p>
</li>
<li><p><code>buf</code>：一个缓冲区的指针。格式化输出到该缓冲区中</p>
<p>对于<code>snprintf</code>:</p>
</li>
<li><code>buf</code>：一个缓冲区的指针。格式化输出到该缓冲区中</li>
<li><code>n</code>：缓冲区的长度。格式化输出到该缓冲区中</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回输出字符数（不包含<code>null</code>字节）</li>
<li>失败：返回负数</li>
</ul>
<p><code>printf</code>将格式化输出写到标准输出；<code>fprintf</code>写到指定的流；<code>dprintf</code>写到指定的文件描述符；<code>sprintf</code>写到数组<code>buf</code>中；<code>snprintf</code>也是写到数组<code>buf</code>中，但是在该数组的尾端自动添加一个<code>null</code>字节（该字节不包含在返回值中）。    </p>
</li>
<li>通常不推荐使用<code>sprintf</code>，因为它可能引起缓冲区溢出流动</li>
<li>如果格式化输出一共 s 个字节，那么<code>snprintf</code>的数组缓冲区至少为<code>s+1</code>个字节，否则发生截断</li>
</ul>
</li>
<li><p>格式说明：<code>%[flags][fldwidth][precision][lenmodifier]convtype</code></p>
<ul>
<li>标志<code>flags</code>有：<ul>
<li><code>&#39;</code> : 撇号，将整数按照千位分组字符</li>
<li><code>-</code> ： 在字段内左对齐输出</li>
<li><code>+</code>： 总是显示带符号转换的正负号</li>
<li><code> </code>：空格。如果第一个字符不是正负号，则在其前面加一个空格</li>
<li><code>#</code>：指定另一种转换形式（如，对于十六进制格式，加 0x 前缀）</li>
<li><code>0</code>：添加前导0（而非空格） 进行填充</li>
</ul>
</li>
<li><code>fldwidth</code>：说明最小字段宽度。转换后参数字符如果小于宽度，则多余字符位置用空格填充。<ul>
<li>字段宽度是一个非负十进制数，或者是一个星号 <code>*</code></li>
</ul>
</li>
<li><code>precision</code>：说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后最大字节数。<ul>
<li>精度是一个点<code>.</code>后跟随一个可选的非负十进制数或者一个星号<code>*</code><blockquote>
<p>宽度和精度可以为<code>*</code>，此时一个整型参数指定宽度或者精度的值。该整型参数正好位于被转换的参数之前</p>
</blockquote>
</li>
</ul>
</li>
<li><code>lenmodifier</code>：说明参数长度。可以为：<ul>
<li><code>hh</code>：将相应的参数按照<code>signed char</code>或者<code>unsigned char</code>类型输出</li>
<li><code>h</code>：将相应的参数按照<code>signed short</code>或者<code>unsigned short</code>类型输出</li>
<li><code>l</code>：将相应的参数按照<code>signed long</code>或者<code>unsigned long</code>或者宽字符类型输出</li>
<li><code>ll</code>：将相应的参数按照<code>signed longlong</code>或者<code>unsigned longlong</code>类型输出</li>
<li><code>j</code>：<code>intmax_t</code>或者<code>uintmax_t</code></li>
<li><code>z</code>：<code>size_t</code></li>
<li><code>t</code>：<code>ptrdiff_t</code></li>
<li><code>L</code>：<code>long double</code></li>
</ul>
</li>
<li><code>convtype</code>：控制如何解释参数<ul>
<li><code>d</code>或者<code>i</code>：有符号十进制</li>
<li><code>o</code>：无符号八进制</li>
<li><code>u</code>：无符号十进制</li>
<li><code>x</code>或者<code>X</code>：无符号十六进制</li>
<li><code>f</code>或者<code>F</code>：双精度浮点数</li>
<li><code>e</code>或者<code>E</code>：指数格式双精度浮点数</li>
<li><code>g</code>或者<code>G</code>：根据转换后的值解释为<code>f、F、e、E</code></li>
<li><code>a</code>或者<code>A</code>：十六进制指数格式双精度浮点数</li>
<li><code>c</code>：字符（若带上长度修饰符<code>l</code>,则为宽字符）</li>
<li><code>s</code>：字符串（若带上长度修饰符<code>l</code>,则为宽字符）</li>
<li><code>p</code>：指向<code>void</code>的指针</li>
<li><code>n</code>：到目前位置，此<code>printf</code>调用输出的字符的数目将被写入到指针所指向的带符号整型中</li>
<li><code>%</code>：一个<code>%</code>字符</li>
<li><code>C</code>：宽字符，等效于<code>lc</code></li>
<li><code>S</code>：宽字符串，等效于<code>ls</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>printf</code>族的变体：将可变参数<code>(...)</code>替换成了<code>va_list arg</code>:</p>
<pre><code> #include&lt;stdarg.h&gt;
 #include&lt;stdio.h&gt;
 int vprintf(const char *restrict format,va_list arg);
 int vfprintf(FILE *restrict fp,const char*restrict format,va_list arg);
 int vdprintf(int fd,const char *restrict format,va_list arg);
 int vsprintf(char *restrict buf,const char*restrict format,va_list arg);
 int vsnprintf(char *restrict buf,size_t n,const char *restrict format,va_list arg);
</code></pre><p> 其参数与返回值与前面的<code>printf</code>族完全相同</p>
</li>
</ol>
<ol>
<li><p>格式化输入函数：</p>
<pre><code> #include&lt;stdio.h&gt;
 int scanf(const char*restrict format,...);
 int fscanf(FILE *restrict fp,const char *restrict format,...);
 int sscanf(const char *restrict buf,const char *restrict format,...);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>format,...</code>：格式化字符串</p>
<p>对于<code>fscanf</code>：</p>
</li>
<li><p><code>fp</code>：打开的文件对象指针。从流中读取输入</p>
<p>对于<code>sscanf</code>：</p>
</li>
<li><code>buf</code>：一个缓冲区指针。从该缓冲区中读取输入</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回赋值的输入项数</li>
<li>提前到达文件尾端：返回<code>EOF</code></li>
<li>失败：返回<code>EOF</code></li>
</ul>
<p><code>scanf</code>族用于分析输入字符串，将字符序列转换成指定类型的变量。在格式之后的各参数中包含了变量的地址，用转换结果对这些变量赋值。</p>
</li>
<li>除了转换说明和空白字符以外，格式字符串中的其他字符必须与输入匹配。如有一个字符不匹配，则停止后续处理，不再读输入的其余部分。</li>
<li>转换说明的格式为：<code>%[*][fldwidth][m][lenmodifier]convtype</code>：<ul>
<li><code>*</code>：用于抑制转换。按照转换说明的其余部分对输入进行转换，但是转换结果不存放在参数中而是抛弃</li>
<li><code>fldwidth</code>：说明最大宽度，即最大字符数</li>
<li><code>lenmodifier</code>：说明要转换结果赋值的参数大小。见前述说明</li>
<li><code>convtype</code>：类似前述说明。但是稍有区别：输入中的带符号的数值可以赋给无符号类型的变量</li>
<li><code>m</code>：用于强迫内存分配。当<code>%c,%s</code>时，如果指定了<code>m</code>，则会自动分配内存来容纳转换的字符串。同时该内存的地址会赋给指针类型的变量（即要求对应的参数必须是指针的地址）。同时要求程序员负责释放该缓冲区（通过<code>free</code>函数）</li>
</ul>
</li>
</ul>
</li>
<li><p><code>scanf</code>族也有一类变体：将可变参数<code>(...)</code>替换成了<code>va_list arg</code>:</p>
<pre><code> #include&lt;stdarg.h&gt;
 #include&lt;stdio.h&gt;
 int vscanf(const char*restrict format,va_list arg);
 int vfscanf(FILE *restrict fp,const char *restrict format,va_list arg);
 int vsscanf(const char *restrict buf,const char *restrict format,va_list arg);
</code></pre></li>
<li><p>示例： 在 <code>main</code>函数中调用<code>test_printf_scanf</code>函数：</p>
</li>
</ol>
<pre><code>```
</code></pre><p>void test_printf_scanf()<br>{<br>    M_TRACE(“———  Begin test_printf_scanf()  ———\n”);<br>    printf(“<strong><strong> test printf  <em>*</em></strong></strong>\n”);<br>    _test_printf();<br>    printf(“\n\n<strong><strong> test snprintf  <em>*</em></strong></strong>\n”);<br>    _test_snprintf();<br>    printf(“\n\n<strong><strong> test scanf  <em>*</em></strong></strong>\n”);<br>    _test_scanf();<br>    printf(“\n\n<strong><strong> test sscanf  <em>*</em></strong></strong>\n”);<br>    _test_sscanf();<br>    M_TRACE(“———  End test_printf_scanf()  ———\n\n”);<br>}</p>
<pre><code>```    
![print_scan](../imgs/std_IO/print_scan.JPG) 
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><p><code>fileno</code>函数：获取文件对象的文件描述符</p>
<pre><code> #include&lt;stdio.h&gt;
 int fileno(FILE *fp);
</code></pre><ul>
<li>参数：<ul>
<li><code>fp</code>：打开的文件对象的指针</li>
</ul>
</li>
<li>返回值： 返回与该流相关联的文件描述符</li>
</ul>
</li>
<li><p><code>tmpnam/tmpfile</code>函数：创建临时文件    </p>
<pre><code> #include&lt;stdio.h&gt;
 char *tmpnam(char *ptr);
 FILE *tmpfile(void);
</code></pre><ul>
<li><code>tmpnam</code>参数：<ul>
<li><code>ptr</code>：指向存放临时文件名的缓冲区的指针<ul>
<li>若为<code>NULL</code>，则产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回<blockquote>
<p>下次再调用<code>tmpnam</code>时，会重写该静态区</p>
</blockquote>
</li>
<li>如果为非<code>NULL</code>，则认为它指向长度至少为<code>L_tmpnam</code>个字符的数组，产生的路径名存放在该缓冲区中，返回<code>ptr</code>。<code>L_tmpnam</code>常量定义在<code>&lt;stdio.h&gt;</code>头文件中</li>
</ul>
</li>
</ul>
</li>
<li><code>tmpnam</code>返回值：返回指向唯一路径名的指针</li>
<li><p><code>tmpfile</code>返回值：</p>
<ul>
<li>成功：返回文件指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p><code>tmpnam</code>函数产生一个与现有文件名不同的有效路径名字符串。每次调用它时，都产生一个不同路径名。最多调用次数是<code>TMP_MAX</code>次（定义在<code>&lt;stdio.h&gt;</code>中）</p>
<blockquote>
<p>它只创建独一无二的文件名，但是并不创建临时文件</p>
</blockquote>
<p><code>tmpfile</code>是创建一个临时二进制文件（类型<code>wb+</code>），在关闭该文件或者程序结束时将自动删除这种文件</p>
<blockquote>
<p><code>UNIX</code>对二进制文件、文本文件并不进行特殊区分</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>mkdtemp/mkstemp</code>函数：创建临时文件（由SUS 标准给出）</p>
<pre><code> #include&lt;stdlib.h&gt;
 char *mkdtemp(char *template);
 int mkstemp(char *template);
</code></pre><ul>
<li>参数：<ul>
<li><code>template</code>：一个字符串。这个字符是最末6个字符设置为<code>XXXXXX</code>的路径名。函数将这些占位符替代成不同的字符来构建一个唯一的路径名。若成功的话，这两个函数将修改<code>template</code>字符串来反映临时文件的名字<blockquote>
<p>因为函数会修改<code>template</code>,因此一定不能用常量字符串来赋值！</p>
</blockquote>
</li>
</ul>
</li>
<li><code>mkdtemp</code>返回值：<ul>
<li>成功：返回指向目录名的指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
</li>
<li><p><code>mkstemp</code>返回值：</p>
<ul>
<li>成功： 返回文件描述符</li>
<li>失败： 返回 -1</li>
</ul>
<p><code>mkdtemp</code>函数创建了一个目录，该目录有一个唯一的名字；<code>mkstemp</code>函数创建了一个文件，该文件有一个唯一的名字。名字是通过<code>template</code>字符串进程构建的。</p>
</li>
<li><code>mkdtemp</code>函数创建的目录具有权限位集： <code>S_IRUSR|S_IWUSR|S_IXUSR</code>。调用进程的文件模式创建屏蔽字可以进一步限制这些权限</li>
<li><code>mkstemp</code>函数返回的文件描述符以读写方式打开。它创建的文件用访问权限位：<code>S_IRUSR|S_IWUSR</code></li>
<li><code>mkstemp</code>创建的临时文件并不会自动删除</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_tmpnam_mkdtemp</code>函数：</p>
<pre><code>void test_tmpnam_mkdtemp()
{
 M_TRACE(&quot;---------  Begin test_printf_scanf()  ---------\n&quot;);
 printf(&quot;******** test tmpnam ********\n&quot;);
 _test_tmpnam();
 printf(&quot;\n\n******** test mkdtemp ********\n&quot;);
 _test_mkdtemp();
 M_TRACE(&quot;---------  End test_printf_scanf()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/make_temp_file.JPG" alt="make_temp_file"> </p>
</li>
<li><p>内存流：一种标准IO流，虽然它通过 <code>FILE</code>指针来访问，但是并没有底层的文件 。所有的IO都是通过在缓冲区和主存之间来回传送字节来完成。</p>
<blockquote>
<p>虽然它看起来像是文件流，但是更适用于字符串操作</p>
</blockquote>
<ul>
<li><p>创建内存流：</p>
<pre><code>  #include&lt;stdio.h&gt;
  FILE *fmemopen(void *restrict buf,size_t size,const char *restrict type);
</code></pre><ul>
<li>参数：<ul>
<li><code>buf</code>：内存流缓冲区的起始地址</li>
<li><code>size</code>：内存流缓冲区的大小（字节数）<ul>
<li>若<code>buf</code>为<code>NULL</code>时，则函数负责分配<code>size</code>字节的缓冲区，并在流关闭时自动释放分配的缓冲区</li>
</ul>
</li>
<li><code>type</code>:控制如何使用流（即打开内存流的方式）：<ul>
<li><code>r</code>或者<code>rb</code>：读打开</li>
<li><code>w</code>或者<code>wb</code>：写打开</li>
<li><code>a</code>或者<code>ab</code>：追加打开；为在第一个<code>null</code>字节处写打开</li>
<li><code>r+</code>或者<code>r+b</code>或<code>rb+</code>：读写打开</li>
<li><code>w+</code>或者<code>w+b</code>或<code>wb+</code>：把文件截断为0，然后读写打开</li>
<li><code>a+</code>或者<code>a+b</code>或<code>ab+</code>：追加；为在第一个<code>null</code>字节处读写打开</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回流指针</li>
<li>失败：返回<code>NULL</code></li>
</ul>
<p>注意：</p>
</li>
<li>无论何时以追<code>a</code>方式打开内存流时，当前文件位置设为缓冲区中第一个<code>null</code>字节处。<ul>
<li>若缓冲区中不存在<code>null</code>字节，则当前位置设为缓冲结尾的后一个字节</li>
</ul>
</li>
<li>当内存流不是<code>a</code>方式打开时，当前位置设置为缓冲区的开始位置</li>
<li>如果<code>buf</code>是<code>null</code>，则打开流进行读或者写都没有任何意义。因为此时缓冲区是通过<code>fmemopen</code>分配的，没办法找到缓冲区的地址。</li>
<li>任何时候需要增加流缓冲区中数据流以及调用<code>fclose、fflush、fseek、fseeko、fsetpos</code>时都会在当前位置写入一个<code>null</code>字节</li>
</ul>
</li>
<li><p>创建内存流的其他两个函数：</p>
<pre><code>  #include&lt;stdio.h&gt;
  FILE *open_memstream(char **bufp,size_t *sizep);
  #include &lt;wchar.h&gt;
  FILE *open_wmemstream(wchar_t **bufp,size_t *sizep);
</code></pre><ul>
<li>参数：<ul>
<li><code>bufp</code>：指向缓冲区地址的指针（用于返回缓冲区地址）</li>
<li><code>sizep</code>:指向缓冲区大小的指针（用于返回缓冲区大小）</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回流指针</li>
<li>失败：返回 <code>NULL</code></li>
</ul>
<p>这两个函数创建的流：</p>
</li>
<li>只能写打开</li>
<li>缓冲区由函数自动创建</li>
<li>关闭流后需要程序员释放缓冲区</li>
<li><p>对流添加字节会增加缓冲区大小</p>
<p>在缓冲区地址和大小使用上要遵守规则：</p>
</li>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或者<code>fflush</code>后才有效</li>
<li>这些值只有在下一次写入或者调用<code>fclose</code>之前才有效。因为缓冲区可能增长，也可能需要重新分配</li>
</ul>
</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_memstream</code>函数：</p>
<pre><code>void test_memstream()
{
 M_TRACE(&quot;---------  Begin test_memstream()  ---------\n&quot;);
 char mem_buffer[16];
 FILE *fp=My_fmemopen(mem_buffer,16,&quot;r+&quot;);
 if(NULL!=fp)
 {

     char read_write_buffer[8];
     My_ftello(fp);   // 查看当前位置
     //**** 写入 ****//
     My_fputs(&quot;abcdefg\n&quot;,fp); // 每次7个字符加一个换行符
     My_fputs(&quot;0123456789&quot;,fp); // 没有换行符
     My_ftello(fp);   // 查看当前位置
     fflush(fp);
     print_char_buffer(mem_buffer,16);
     //**** 读取 ****//
     My_fseeko(fp,0,SEEK_SET); //重定位到文件头
     My_ftello(fp); // 查看当前位置
     My_fgets(read_write_buffer,8,fp); // 读取 abcdefg
     My_fgets(read_write_buffer,8,fp); // 读取 \n
     My_fgets(read_write_buffer,8,fp);// 读取 0123456，文件指针指向 null 字节
     My_fgets(read_write_buffer,8,fp);// 遇到 EOF，即 null 字节 （最后一个字节为 null 字节，因此有效字节只有15个字节）
     My_ftello(fp); // 查看当前位置，文件指针指向最后一个字节的下一个字节
     My_fgets(read_write_buffer,8,fp);// 遇到 EOF，此时读取返回 EOF，并且是 ferror 返回真，且 feof 返回真
     printf(&quot;feof=%d,ferror=%d\n&quot;,feof(fp),ferror(fp)); //ferror 返回真，且 feof 返回真

     print_char_buffer(mem_buffer,16); // 读取并不会删除 mem_buffer 中的内容
     fclose(fp);
 }
 M_TRACE(&quot;---------  End test_memstream()  ---------\n\n&quot;);
}
</code></pre><p> <img src="../imgs/std_IO/mem_FILE_stream.JPG" alt="mem_FILE_stream"> </p>
</li>
<li><p>标准IO库的缺点：效率不高。这与它需要复制的数据量有关。当使用每次一行的函数<code>fgets/fputs</code>时，通常需要复制两次数据：</p>
<ul>
<li>内核和标准IO缓冲区之间（当调用<code>read/write</code>时）</li>
<li>标准IO缓冲区和用户程序的缓冲区之间%  </li>
</ul>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> apue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> apue,文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件和目录]]></title>
      <url>/2017/12/04/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<h2 id="一、-stat-结构和权限相关"><a href="#一、-stat-结构和权限相关" class="headerlink" title="一、 stat 结构和权限相关"></a>一、 stat 结构和权限相关</h2><ol>
<li><p>四个<code>stat</code>函数：返回文件或者目录的信息结构：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int stat(const char * restrict pathname, struct stat*restrict buf);
 int fstat(int fd, struct stat* buf);
 int lstat(const char* restrict pathname,struct stat *restrict buf);
 int fstatat(int fd,const char*restrict pathname,struct stat*restrict buf,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件或者目录的名字</li>
<li><code>buf</code>：存放信息结构的缓冲区</li>
<li><code>fd</code>：打开的文件描述符<ul>
<li>对于<code>fstat</code>，该文件就是待查看信息的文件</li>
<li>对于<code>fstatat</code>，该文件是并不是待查看信息的文件。待查看信息的文件时已该<code>fd</code>对于的目录相对路径定位的</li>
</ul>
</li>
<li><p><code>flag</code>：控制着<code>fstatat</code>函数是否跟随一个符号链接。</p>
<p>对于<code>fstatat</code>函数：</p>
</li>
<li><p>待查看的文件名是由<code>fd</code>和<code>pathname</code>共同决定的。</p>
<ul>
<li>如果<code>pathname</code>是个绝对路径，则忽略<code>fd</code>参数</li>
<li>如果<code>pathname</code>是个相对路径路径，且 <code>fd=AT_FDCWD</code>，则在当前工作目录的路径下查找<code>pathname</code></li>
<li>如果<code>pathname</code>是个相对路径路径，且 <code>fd!=AT_FDCWD</code>，则在<code>fd</code>对应的打开目录下查找<code>pathname</code></li>
</ul>
</li>
<li><code>flag</code>：控制着<code>fstatat</code>函数是否跟随一个符号链接。当<code>!AT_SYMLINK_FOLLOW</code>标志被设置时，查看的是<code>pathname</code>（如果它是个符号链接）本身的信息；否则默认查看的是<code>pathname</code>（如果它是个符号链接）链接引用的文件的信息。    </li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>注意：</p>
</li>
<li><code>lstat</code>类似于<code>stat</code>，但是当<code>pathname</code>是个符号链接时，<code>lstat</code>查看的是该符号链接的有关信息；而<code>stat</code>是查看该符号链接引用的文件的信息。</li>
<li>在 <code>ubuntu 16.04</code>上，虽然有 <code>AT_SYMLINK_NOFOLLOW</code>这个常量，但是不支持。必须用 <code>!AT_SYMLINK_FOLLOW</code>。其常量定义为：<ul>
<li><code>AT_SYMLINK_FOLLOW</code>： 1024 (有效）</li>
<li><code>!AT_SYMLINK_FOLLOW</code>： 0(有效）</li>
<li><code>AT_SYMLINK_NOFOLLOW</code>： 256(无效）</li>
<li><code>AT_SYMLINK_FOLLOW</code>： -1025(无效）</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><code>stat</code>数据结构：其定义可能与具体操作系统相关，但是基本形式为：</p>
<pre><code> struct stat{
 mode_t             st_mode;     //文件权限和类型信息
 ino_t             st_ino;        //i-node 号
 dev_t             st_dev;        // 设备号
 dev_t             st_rdev;    // 特殊文件的设备号
 nlink_t         st_nlink;    // 硬链接数量
 uid_t             st_uid;        // owner 的用户ID
 gid_t             st_gid;        // owner 的组ID
 off_t             st_size;    //对普通文件，它是文件字节大小
 struct timespec st_atime;    // 上次访问时间
 struct timespec st_mtile;    // 上次修改时间
 struct timespec st_ctime;    // 上次文件状态改变的时间
 blksize_t         st_blksize;    // 最佳的 I/O block 大小
 blkcnt_t         st_blocks;    //分配的磁盘块数量
 }
</code></pre><p> 其中<code>timespec</code>结构与具体操作系统相关，但是至少包括下面两个字段：</p>
</li>
</ol>
<pre><code>    struct timespec{
    time_t tv_sec;    // 秒
    long tv_nsec;     //纳秒
        }
</code></pre><ol>
<li><p>UNIX 文件类型：</p>
<ul>
<li>普通文件：最常见的文件类型，这种文件包含了某种形式的数据。至于这种数据是二进制还是文本，对内核无区别。普通文件的内容解释由具体的应用程序进行。</li>
<li>目录文件：这种文件包含了其他文件的名字，以及指向这些文件有关信息的指针。<ul>
<li>只有内核可以直接写目录文件（通常用户写目录文件都要通过内核）</li>
<li>对某个目录文件具有读权限的任何一个进程都可以读取该目录的内容</li>
</ul>
</li>
<li>块特殊文件：这种类型的文件提供对设备（如磁盘）带缓冲的访问。每次访问以固定长度为单位进行。</li>
<li>字符特殊文件：这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。<blockquote>
<p>系统的所有设备，要么是字符特殊文件，要么是块特殊文件</p>
</blockquote>
</li>
<li><code>FIFO</code>：这种类型的文件用于进程间通信，有时也称为命名管道</li>
<li>套接字：这种类型的文件用于进程间的网络通信（也可用于单机上进程的非网络通信）</li>
<li><p>符号链接：这种类型的文件指向另一个文件</p>
<p>文件类型信息存放在<code>stat.st_mode</code>成员中，可以用下列的宏测试文件类型：</p>
</li>
<li><code>S_ISREG()</code>：测试是否普通文件</li>
<li><code>S_ISDIR()</code>：测试是否目录文件</li>
<li><code>S_ISCHR()</code>：测试是否字符特殊文件</li>
<li><code>S_ISBLK()</code>：测试是否块特殊文件</li>
<li><code>S_ISFIFO()</code>：测试是否<code>FIFO</code></li>
<li><code>S_ISLNK()</code>：测试是否符号链接文件</li>
<li><p><code>S_ISSOCK()</code>：测试是否套接字</p>
<p>另外 <code>POSIX.1</code> 允许将进程间通信对象说明为文件。但是下面的宏测试的不是<code>stat.st_mode</code>，而是<code>stat*</code>（<code>stat</code>指针）：</p>
</li>
<li><code>S_TYPEISMQ()</code>：测试是否消息队列</li>
<li><code>S_TYPEISSEM()</code>：测试是否信号量</li>
<li><code>S_TYPEISSHM()</code>：测试是否共享存储对象</li>
</ul>
</li>
<li><p>与一个进程有关的ID有很多:</p>
<ul>
<li>实际用户 ID 和实际组 ID： 标志我们究竟是谁。当我们登录进操作系统时，这两个值就确定了！</li>
<li>有效用户 ID、有效组ID、附属组 ID： 用于文件访问权限检查。</li>
<li><p>保存的设置用户ID、保存的设置组ID：由 <code>exec</code>函数保存</p>
<p>每个文件都有一个所有者和组所有者，分别有 <code>stat.st_uid</code>和<code>stat.st_gid</code>指定。当一个文件时可执行文件时，如果执行这个文件，那么进程的有效用户ID就是实际用户ID，有效组ID就是实际组ID，除了下面的情况：</p>
</li>
<li>当在<code>stat.st_mode</code>中设置了一个特殊标志：设置用户ID位时，则将进程的有效用户ID设置为文件所有者的用户ID</li>
<li><p>当在<code>stat.st_mode</code>中设置了一个特殊标志：设置组ID位时，则将进程的有效组ID设置为文件所有者的组ID</p>
<blockquote>
<p>任何进程都是由可执行文件被执行而得到。因此位于磁盘上的可执行文件的所属的用户ID和组ID会影响到进程的用户ID和组ID</p>
</blockquote>
<p>如果某个可执行文件所有者是<code>root</code>，且该文件的设置用户ID位已经被设置，那么无论谁执行这个可执行文件时，该可执行文件产生的进程就具有超级用户权限。</p>
<p>设置用户ID位、设置组ID位 都包含在<code>stat.st_mode</code>中，可以通过下列两个宏测试：</p>
</li>
<li><code>S_ISUID()</code>：测试是否设置了设置用户ID位</li>
<li><code>S_ISGID()</code>：测试是否设置了设置组ID位</li>
</ul>
</li>
<li><p>文件访问权限：所有文件类型（包括目录，字符特别文件等）都有访问权限。每个文件都有9个访问权限位：</p>
<ul>
<li><code>S_IRUSR</code>：用户读</li>
<li><code>S_IWUSR</code>：用户写</li>
<li><code>S_IXUSR</code>：用户执行</li>
<li><code>S_IRGRP</code>：组读</li>
<li><code>S_IWGRP</code>：组写</li>
<li><code>S_IXGRP</code>：组执行</li>
<li><code>S_IROTH</code>：其他读</li>
<li><code>S_IWOTH</code>：其他写</li>
<li><p><code>S_IXOTH</code>：其他执行</p>
<p>访问权限规则：</p>
</li>
<li><p>当用名字<code>pathname</code>打开任何一个类型的文件时，对<code>pathname</code>中包含的每一个目录，包括<code>pathname</code>可能隐含的当前工作目录都应该具有执行权限</p>
<blockquote>
<p>因此目录的执行权限位也称之为搜索位</p>
</blockquote>
</li>
<li>对一个文件的读权限决定了我们能否打开现有文件进行读操作</li>
<li>对一个文件的写权限决定了我们能否打开现有文件进行写操作</li>
<li>如果你在<code>open</code>函数中对一个文件指定了<code>O_TRUNC</code>标志，则必须对该文件具有写权限</li>
<li>为了在一个目录中常见一个新文件，必须对该目录具有写权限和执行权限</li>
<li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身没有权限的限制</li>
<li><p>如果用7个<code>exec</code>函数中的任何一个执行某个文件，则必须对该文件具有执行权限，且该文件必须是个普通文件</p>
<p>进程每次打开、创建、删除一个文件时，内核就进行文件访问权限测试。这种测试如下：</p>
</li>
<li><p>若进程的有效用户ID是0（超级用户），则对该文件的任何访问行为都批准</p>
</li>
<li>若进程的有效用户ID等于文件的所有者ID（也就是进程拥有此文件）：<ul>
<li>如果该文件的用户读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的用户写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的用户执行权限开放，则内核允许进程执行该文件</li>
</ul>
</li>
<li>若进程的有效组ID或者进程的附属组ID之一等于文件的组ID：<ul>
<li>如果该文件的组读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的组写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的用户执行权限开放，则内核允许进程执行该文件</li>
</ul>
</li>
<li><p>否则：</p>
<ul>
<li>如果该文件的其他读权限开放，则内核允许进程读该文件</li>
<li>如果该文件的其他写权限开放，则内核允许进程写该文件</li>
<li>如果该文件的其他户执行权限开放，则内核允许进程执行该文件</li>
</ul>
<p>只要有一个权限通过，则不再进行测试。若所有权限都不通过，则不允许访问。</p>
</li>
</ul>
</li>
<li><p>对一个目录的读权限和可执行权限是不同的：</p>
<ul>
<li>目录读权限：允许读目录，从而获得在该目录中所有文件名的列表</li>
<li>目录可执行权限：允许搜索该目录，从而寻找一个特定的文件名</li>
</ul>
</li>
<li><p>当一个进程通过<code>open</code>或者<code>creat</code>创建一个新文件时：</p>
<ul>
<li>新文件的用户ID被设置为进程的有效用户ID</li>
<li>新文件的组ID可以有两个值之一：<ul>
<li>进程的有效组ID</li>
<li>文件所在目录的组ID<blockquote>
<p>具体选择哪个，由具体操作系统决定</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>stat</code>和<code>lstat</code>示例：在<code>main</code>函数中调用<code>test_stat_lstat</code>函数：</p>
</li>
</ol>
<pre><code>void test_stat_lstat()
{
    M_TRACE(&quot;---------  Begin test_stat_lstat()  ---------\n&quot;);
    Stat stat_buf;
    My_stat(&quot;/home/huaxz1986/APUE/main.c&quot;,&amp;stat_buf); // regular file
    My_stat(&quot;/home/huaxz1986/APUE/&quot;,&amp;stat_buf); // dir file
    My_stat(&quot;/dev/loop0&quot;,&amp;stat_buf); // block file
    My_stat(&quot;/dev/mem&quot;,&amp;stat_buf); // char file
    My_lstat(&quot;/dev/cdrom&quot;,&amp;stat_buf); // link file
    My_stat(&quot;/run/systemd/initctl/fifo&quot;,&amp;stat_buf); // fifo file

    int fd=My_open_with_mode(&quot;test_stat&quot;,O_WRONLY|O_CREAT,S_IRUSR); // create a new file
    close(fd);
    My_stat(&quot;test_stat&quot;,&amp;stat_buf); // regular file
    M_TRACE(&quot;---------  End test_stat_lstat()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![stat](../imgs/file_dir/stat.JPG) 
</code></pre><h2 id="二、访问测试和文件模式创建屏蔽字"><a href="#二、访问测试和文件模式创建屏蔽字" class="headerlink" title="二、访问测试和文件模式创建屏蔽字"></a>二、访问测试和文件模式创建屏蔽字</h2><ol>
<li><p>当用<code>open()</code>函数打开一个文件时，内核根据进程的有效用户ID和有效组ID为依据来执行访问权限测试。但是如果你想测试进程的实际用户ID和实际组ID是否能够通过权限测试时，可以用下列两个函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int access(const char *pathname,int mode);
 int faccess(int fd,const char*pathname,int mode,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><p><code>mode</code>：指定要测试的模式。</p>
<ul>
<li>如果要测试文件是否已存在，则<code>mode</code>设为<code>F_OK</code></li>
<li>如果要测试进程的实际用户ID和实际组ID的权限，则可以为下列常量的按位或<ul>
<li><code>R_OK</code>：测试读权限</li>
<li><code>W_OK</code>：测试写权限</li>
<li><code>X_OK</code>：测试执行权限</li>
</ul>
</li>
</ul>
<p>对于 <code>faccess</code>函数：</p>
</li>
<li><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>AT_EACCESS</code>，则访问检查使用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>出错： 返回 -1</li>
</ul>
</li>
</ul>
</li>
<li><p>文件模式创建屏蔽字：当进程创建一个新的目录或者文件时，会使用文件模式创建屏蔽字。在文件模式创建屏蔽字中为1的位，在文件<code>mode</code>中的相应位一定被关闭。设置进程的文件模式创建屏蔽字的函数为：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 mode_t umask(mode_t cmask);
</code></pre><ul>
<li>参数： <ul>
<li><code>cmask</code>：要设置的新的文件模式创建屏蔽字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：旧的文件模式创建屏蔽字</li>
<li>函数未指定失败时返回何值</li>
</ul>
<p>如果你在通过<code>creat</code>或者<code>open</code>函数指定了<code>mode</code>，那么该<code>mode</code>必须通过文件模式创建屏蔽字的屏蔽之后才是最终新创建的文件的权限模式。<code>umask</code>指定了哪个，哪个权限就被屏蔽了！</p>
<blockquote>
<p>shell 有一个<code>umask</code>命令。我们可以通过该命令来设置或者打印当前的文件模式创建屏蔽字</p>
</blockquote>
</li>
</ul>
</li>
<li><p>示例：测试 <code>umask</code>和<code>access</code>函数的用法：在<code>main</code>函数中调用<code>test_access_umask</code> 函数：</p>
</li>
</ol>
<pre><code>void test_access_umask()
{
    My_access(&quot;/no/exist&quot;,F_OK); // no exist
    My_access(&quot;/etc/shadow&quot;,W_OK);// can not write
    My_access(&quot;/home/huaxz1986/APUE&quot;,W_OK); // can write

    print_new_file_mode(&quot;test_umask1&quot;) ;// old umask
    //new umask
    My_umask(S_IRUSR|S_IRGRP|S_IROTH);
    print_new_file_mode(&quot;test_umask2&quot;) ;// new umask
}
</code></pre><p>  <img src="../imgs/file_dir/access_umask.JPG" alt="access_umask"> </p>
<p>可以看到：</p>
<ul>
<li><code>access</code>函数：对于不存在的文件名访问失败；对没有写权限的名字写访问失败</li>
<li>被创建的文件的访问权限是由文件创建屏蔽字、创建文件时指定的权限二者共同作用的</li>
</ul>
<h2 id="三、修改文件访问权限和文件所属用户"><a href="#三、修改文件访问权限和文件所属用户" class="headerlink" title="三、修改文件访问权限和文件所属用户"></a>三、修改文件访问权限和文件所属用户</h2><ol>
<li><p>修改文件的现有的访问权限：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int chmod(const char*pathname,mode_t mode);
 int fchmod(int fd,mode_t mode);
 int fchmodat(int fd,const char*pathname,mode_t mode,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><p><code>mode</code>：文件修改后的权限。</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><p><code>fd</code>：打开的文件描述符</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>!AT_SYMLINK_FOLLOW</code>，则<code>fchmodtat</code>并不跟随符号链接</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>出错： 返回 -1</li>
</ul>
<p>参数<code>mode</code>可以是下面常量的按位或：（来自头文件<code>&lt;sys/stat.h&gt;</code></p>
</li>
<li><code>S_ISUID</code>：执行时设置用户ID</li>
<li><code>S_ISGID</code>：执行时设置组ID</li>
<li><code>S_ISVTX</code>：粘着位</li>
<li><code>S_IRWXU</code>：用户读、写和执行</li>
<li><code>S_IRUSR</code>：用户读</li>
<li><code>S_IWUSR</code>：用户写</li>
<li><code>S_IXUSR</code>：用户执行</li>
<li><code>S_IRWXG</code>：组读、写和执行</li>
<li><code>S_IRGRP</code>：用户读</li>
<li><code>S_IWGRP</code>：用户写</li>
<li><code>S_IXGRP</code>：用户执行</li>
<li><code>S_IRWXO</code>：其他读、写和执行</li>
<li><code>S_IROTH</code>：用户读</li>
<li><code>S_IWOTH</code>：用户写</li>
<li><p><code>S_IXOTH</code>：用户执行</p>
<p><code>chmod</code>函数更新的只是<code>i</code>节点最近一次被修改的时间。</p>
<p><code>chmod</code>函数在下列条件下自动清除两个权限位：</p>
</li>
<li>如果我们试图设置普通文件的粘着位，而且又没有超级用户权限，则<code>mod</code>中的粘着位被自动关闭。这意味着只有超级用户才能设置普通文件的粘着位</li>
<li>新创建文件的组<code>ID</code>可能不是调用进程所属的组<code>ID</code>，它可能是父目录的组<code>ID</code></li>
</ul>
</li>
<li><p>粘着位：如果对一个目录设置了粘着位，则任何对该目录具有写权限的进程都能够在该目录中创建文件。但是：只有满足下列条件之一的用户才能删除或者重命名该目录下的文件：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户<blockquote>
<p>对于未设置粘着位的目录，则只要用户对该目录有写权限，那么就有修改和重命名该目录下其他文件的能力</p>
</blockquote>
</li>
</ul>
</li>
<li><p>修改用户的ID和组ID：</p>
<pre><code> #include&lt;unistd.h&gt;
 int chown(const char *pathname,uid_t owner,gid_t group);
 int fchown(int fd,uid_t owner,gid_t group);
 int fchownat(int fd,const char *pathname,uid_t owner,gid_t group,int flag);
 int lchown(const char *pathname,uid_t owner,gid_t group);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：文件路径名</li>
<li><code>owner</code>：文件修改后的用户ID</li>
<li><p><code>group</code>：文件修改后的组ID</p>
<p>对于<code>fchown</code>函数：</p>
</li>
<li><p><code>fd</code>：打开的文件描述符，要修改的就是这个文件</p>
<p>对于 <code>fchmod</code>函数：</p>
</li>
<li><p><code>fd</code>：一个打开目录文件的描述符，或者<code>AT_FDCWD</code></p>
</li>
<li><code>pathname</code>：<ul>
<li>如果为绝对路径，则忽略<code>fd</code>参数</li>
<li>如果为相对路径，则相对路径的目录由<code>fd</code>指定。<ul>
<li>若<code>fd=AT_FDCWD</code>，则表示相对于当前工作目录</li>
<li>否则相对于<code>fd</code>对于的打开的目录</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：如果是<code>!AT_SYMLINK_FOLLOW</code>，则<code>fchmodtat</code>并不跟随符号链接，修改的是符号链接本身而不是符号链接指向的文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>出错： 返回 -1</li>
</ul>
<p>有两点注意：</p>
</li>
<li><code>lchown</code>函数更改的是符号链接本身，而<code>chown</code>遇到符号链接时更改的是符号链接指向的文件</li>
<li>如果这些函数由非超级用户进程调用，则成功返回时，该文件的设置用户ID和设置组ID位都被清除</li>
</ul>
</li>
<li><p>示例：在 <code>main</code> 函数中调用<code>test_chmod_chown</code> 函数：</p>
</li>
</ol>
<pre><code>void test_chmod_chown()
{
    const char *file_name=&quot;test&quot;;
    Stat buf;

    My_stat(file_name,&amp;buf);
    My_chmod(file_name,S_IRWXU);
    My_chown(file_name,1,1);
}
</code></pre><pre><code>  ![chmod_chown](../imgs/file_dir/chmod_chown.JPG) 

可以看到：
- 修改文件所属的用户和组，需要超级用户权限。普通用户无法修改，即使该用户就是该文件的所有者也不行
</code></pre><h2 id="四、修改文件长度"><a href="#四、修改文件长度" class="headerlink" title="四、修改文件长度"></a>四、修改文件长度</h2><ol>
<li><p>文件长度：<code>stat.st_size</code>字段存放的是以字节为单位的文件的长度。此字段只对普通文件、目录文件、符号链接才有意义：</p>
<ul>
<li>对普通文件：其长度就是文件的大小。长度为0表示该文件为空</li>
<li>对目录文件：其长度通常是个整数（如16或者512）的整数倍</li>
<li><p>对符号链接：其长度是符号链接本身存放的某个文件名的实际字节数（它并不包含字符串的<code>null</code>字节，因为这些字符是存放在文件中，而不是存放在内存中的字符串）</p>
<p>另外<code>stat.st_blksize</code>存放的是对于文件 I/O 较合适的块长度；<code>stat.st_blocks</code>存放的是所分配的块的数量（一个块512字节）。注意：</p>
</li>
<li>对于普通文件，可能包含空洞。空洞是由于设置的文件偏移量超过了文件末尾，然后写入了某些数据造成的。对于空洞文件：<ul>
<li>空洞文件的存储需要的磁盘块数量可能远小于文件大小。文件大小是文件末尾到文件头的字节数</li>
<li>读取空洞文件的空洞时，对于没有写过的字节位置<code>read</code>返回的是字节0</li>
</ul>
</li>
</ul>
</li>
<li><p>截断文件：通常可以用带<code>O_TRUNC</code>选项的<code>open()</code>函数来清空一个文件（截断到0）。但是如果希望截断文件使得文件大小为指定字节数，则可以用下列的函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int truncate(const char*pathname,off_t length);
 int ftruncate(int fd,off_t length);
</code></pre><ul>
<li>参数：<ul>
<li><code>pathname</code>：文件路径名</li>
<li><code>length</code>：文件修改后大小（字节数）</li>
<li><code>fd</code>：打开的文件描述符，要修改的就是这个文件</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>出错： 返回 -1</li>
</ul>
<p>有两点注意：</p>
</li>
<li>若<code>length</code>小于文件的原大小，则修改文件大小之后，文件新的尾端之后的位置不再可以访问</li>
<li>若<code>length</code>大于文件的原大小，则修改文件大小之后，会形成空洞。即从文件原大小新的尾端形成了空洞</li>
</ul>
</li>
<li><p>示例：在<code>main</code>函数中调用<code>test_truncate_size</code>函数：</p>
</li>
</ol>
<pre><code>void test_truncate_size()
{
    M_TRACE(&quot;---------  Begin test_truncate_size()  ---------\n&quot;);
    char buffer[100];
    int len;
    int fd=My_open_with_mode(&quot;test&quot;,O_CREAT|O_TRUNC|O_RDWR,S_IRWXU);
    My_write(fd,&quot;abcdefg&quot;,8);
    print_file_size(&quot;test&quot;);  // 打印文件大小
    //****  扩张文件 *******//
    My_truncate(&quot;test&quot;,20);  // 扩张文件
    My_lseek(fd,0,SEEK_SET);  // 读取之前先调整文件读取位置
    len=My_read(fd,buffer,20);
    printf(&quot;Read:&quot;);
    for (int i=0;i&lt;len;i++)  // 打印读取内容
        printf(&quot;\t0x%x,&quot;,buffer[i]);
    printf(&quot;\n&quot;);
    //****  截断文件 *******//
    My_truncate(&quot;test&quot;,5);   // 截断文件
    My_lseek(fd,0,SEEK_SET);  // 读取之前先调整文件读取位置
    len=My_read(fd,buffer,5);
    printf(&quot;Read:&quot;);
    for (int i=0;i&lt;len;i++)
        printf(&quot;\t0x%x,&quot;,buffer[i]);
    printf(&quot;\n&quot;);
    close(fd);
    M_TRACE(&quot;---------  End test_truncate_size()  ---------\n&quot;);
}
</code></pre><pre><code>  ![truncate](../imgs/file_dir/truncate.JPG) 

可以看到：
- 对于文件空洞，它不占用任何磁盘空间；空洞部分读出的内容全为0
- 对于非常小的文件，比如这里的 8 字节文字，磁盘分配了 8个块（4kb）。
</code></pre><h2 id="五、UNIX文件系统、硬链接、软链接、删除、重命名"><a href="#五、UNIX文件系统、硬链接、软链接、删除、重命名" class="headerlink" title="五、UNIX文件系统、硬链接、软链接、删除、重命名"></a>五、UNIX文件系统、硬链接、软链接、删除、重命名</h2><ol>
<li><p>UNIX文件系统简介(传统的基于BSD的UNIX文件系统，称作<code>UFS</code>）：</p>
<ul>
<li>一个磁盘可以划分成一个或者多个分区，每个分区可以包含一个文件系统。每个文件系统包含一些柱面组。每个柱面组包括：<ul>
<li>一个 i 节点图：用于指示哪些 i 节点已经被使用，哪些未被使用</li>
<li>一个 块位图：用于指示哪些数据块已经被使用，哪些为被使用</li>
<li>一个 i 节点组。它包含的是许多 i  节点。</li>
<li>一个数据区：存放具体的数据块和目录块</li>
</ul>
</li>
<li>数据区包含两种类型的块：<ul>
<li>目录块：它的内容是 <code>&lt;i 节点编号&gt;|&lt;文件名&gt;</code> 这种格式的记录的列表</li>
<li>数据块：它的内容就是具体文件的数据        </li>
</ul>
</li>
<li>i 节点是固定长度的记录项，它包含有关文件的大部分信息<ul>
<li>每个 i 节点都有一个链接计数，其值是指向 i 节点的目录的项数(这种链接类型称之为硬链接)。只有当该链接计数减少为0时，才可以删除该链接文件（也就是释放该文件占用的数据块）。<ul>
<li>在<code>stat</code>结构中，链接计数包含在<code>st_nlink</code>成员中（POSIX常量：<code>LINK_MAX</code>指定了一个文件链接数的最大值）         </li>
</ul>
</li>
<li>每个 i 节点包含了文件有关的所有信息：文件类型、文件权限访问位、文件长度和指向文件数据块的指针<ul>
<li><code>stat</code>结构中的大多数信息来自于 i  结点。只有两项重要数据存放在目录项中：文件名、i节点编号</li>
</ul>
</li>
<li>目录项中的 i 节点编号只能指向同一个文件系统中的相应的 i 节点。<blockquote>
<p>因此硬链接不能跨文件系统</p>
</blockquote>
</li>
<li>当在不更换文件系统的情况下重命名一个文件时，该文件的实际内容并未移动。只需要构造一个指向现有 i 节点的新目录项，并删除来的目录项。此时该 i节点的链接计数不会改变<blockquote>
<p>这就是 <code>mv</code>命令的操作方式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>与硬链接对应的概念是软链接。软链接也称作符号链接，它是一种特殊的文件。该文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字。同时该文件的 i 节点指示了该文件类型是 <code>S_IFLNK</code>，于是系统知道了这个文件是个符号链接。</p>
<ul>
<li>硬链接直接指向文件的<code>i</code>节点</li>
<li><p>软链接是对一个文件的间接指针</p>
<p>引入符号链接的原因是为了避开硬链接的一些限制：</p>
</li>
<li>硬链接通常要求链接和文件位于同一个文件系统中</li>
<li><p>只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）</p>
<p>对于符号链接以及它指向何种类型的文件并没有什么限制。任何用户都可以创建指向目录的符号链接。但是使用符号链接有可能在文件系统中引入循环</p>
<p>对于处理文件和目录的函数，如果传递的是一个符号链接的文件名，则应该注意：函数是否跟随符号链接，即函数是处理符号链接指向的文件，还是处理符号链接本身。</p>
</li>
<li><p>跟随符号链接（即处理符号链接指向的文件）的函数有：<code>access</code>、<code>chdir</code>、<code>chmod</code>、<code>chown</code>、<br><code>creat</code>、<code>exec</code>、<code>link</code>、<code>open</code>、<code>opendir</code>、<code>pathconf</code>、<code>stat</code>、<code>truncate</code></p>
</li>
<li>不跟随符号链接（即处理符号链接文件本身）的函数有：<code>lchown</code>、<code>lstat</code>、<code>readlink</code>、<code>remove</code>、<code>rename</code>、<code>unlink</code><ul>
<li>一个例外的情况：如果用<code>O_CREAT</code>和<code>O_EXCL</code>选项调用<code>open</code>，此时若参数是个符号链接的文件名，则<code>open</code>出错返回（并不考虑符号链接指向的文件是否存在），同时将<code>errno</code>设为<code>EEXIST</code></li>
</ul>
</li>
</ul>
</li>
<li><p>任何一个目录 <code>dirxxx</code> 的硬链接至少为2：</p>
<ul>
<li>该目录的内容中有一条名为的<code>.</code>记录，该记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点</li>
<li>该目录的父目录的内容中有一条记录，记录的名字<code>dirxxx</code>，记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点</li>
<li>若该目录有子目录。<code>dirxxx</code> 的任何子目录的内容有一条名为<code>..</code>的记录，该记录的 <code>&lt;i节点编号&gt;</code> 指向<code>dirxxx</code>目录的节点<blockquote>
<p>因此父目录中的每个子目录都使得父目录的链接计数加 1</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>link/linkat</code>函数：创建一个指向现有文件的硬链接</p>
<pre><code> #include&lt;unistd.h&gt;
 int link(const char *existingpath,const char *newpath);
 int linkat(int efd,const char*existingpath,int nfd,const char *newpath,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>existingpath</code>：现有的文件的文件名（新创建的硬链接指向它）</li>
<li><p><code>newpath</code>：新创建的目录项</p>
<ul>
<li>如果<code>newpath</code>已存在，则返回出错</li>
<li>只创建<code>newpath</code>中的最后一个分量，路径中的其他部分应当已经存在。<blockquote>
<p>假设 <code>newpath</code>为：<code>/home/aaa/b/c.txt</code>，则要求 <code>/home/aaa/b</code>已经存在，只创建<code>c.txt</code></p>
</blockquote>
</li>
</ul>
<p>对于<code>linkat</code>函数：</p>
</li>
<li>现有的文件名是通过<code>efd</code>和<code>existingpath</code>指定。<ul>
<li>若<code>existingpath</code>是绝对路径，则忽略<code>efd</code></li>
<li>若 <code>existingpath</code>是相对路径，则：<ul>
<li>若 <code>efd=AT_FDCWD</code>，则<code>existingpath</code>是相对于当前工作目录来计算</li>
<li>若 <code>efd</code>是一个打开的目录文件的文件描述符，则<code>existingpath</code>是相对于<code>efd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li>新建的文件名是通过<code>nfd</code>和<code>newpath</code>指定。<ul>
<li>若<code>newpath</code>是绝对路径，则忽略<code>nfd</code></li>
<li>若 <code>newpath</code>是相对路径，则：<ul>
<li>若 <code>nfd=AT_FDCWD</code>，则<code>newpath</code>是相对于当前工作目录来计算</li>
<li>若 <code>nfd</code>是一个打开的目录文件的文件描述符，则<code>newpath</code>是相对于<code>nfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：当现有文件是符号链接时的行为：<ul>
<li><code>flag=AT_SYMLINK_FOLLOW</code>：创建符号链接指向的文件的硬链接（跟随行为）</li>
<li><code>flag=!AT_SYMLINK_FOLLOW</code>:创建符号链接本身的硬链接（默认行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>这两个函数创建新目录项并对链接计数加1。创建新目录项和增加链接计数是一个原子操作。</p>
<p>另外，大多数操作系统中，只有超级用户才能创建指向一个目录的硬链接，因为这样做很有可能在文件系统中形成循环。</p>
</li>
</ul>
</li>
<li><p><code>unlink</code>函数：删除一个现有的目录项</p>
<pre><code> #include&lt;unistd.h&gt;
 int unlink(const char*pathname);
 int unlinkat(int fd,const char*pathname,int flag);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><p><code>pathname</code>：现有的、待删除的目录项的完整路径名。</p>
<p>对于<code>unlinkat</code>函数：</p>
</li>
<li>现有的文件名是通过<code>fd</code>和<code>pathname</code>指定。<ul>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：<ul>
<li><code>flag=AT_REMOVEDIR</code>：可以类似于<code>rmdir</code>一样的删除目录</li>
<li><code>flag=!AT_REMOVEDIR</code>:与<code>unlink</code>执行同样的操作</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果还对该目录设置了粘着位，则对该目录必须具有写权限以及下列三个条件之一：</p>
</li>
<li>拥有该文件</li>
<li>拥有该目录</li>
<li><p>具有超级用户权限</p>
<p>这两个函数删除目录项并对链接计数减1。创建新目录和增加链接计数是一个原子操作。</p>
</li>
<li>如果该文件的硬链接数不为0， 则还可以通过其他链接访问该文件的内容</li>
<li>如果该文件的硬链接数为0，而没有进程打开该文件，则该文件的内容才有被删除</li>
<li>如果该文件的硬链接数为0，但是有进程打开了该文件，则该文件的内容不能被删除。当进程关闭文件时，内核会检查打开该文件的进程个数；当这个数量为0，内核再去检查其链接计数。如果链接计数也是0，则就删除该文件的内容。<blockquote>
<p>这个特性常用于创建临时文件，先<code>open,create</code>一个文件，然后立即调用<code>unlink</code>。这样即使程序崩溃，它所创建的临时文件也不会遗留下来</p>
</blockquote>
</li>
<li><p>如果删除目录项出错，则不对该文件做任何更改</p>
<p>如果<code>pathname</code>是个符号链接，则<code>unlink</code>删除该符号链接，而不会删除由该符号链接所引用的文件。    </p>
<blockquote>
<p>如果仅仅给出符号链接的文件名，没有一个函数可以删除由该符号链接所引用的文件</p>
</blockquote>
<p>如果文件系统支持，超级用户可以调用<code>unlink</code>，其参数<code>pathname</code>指定一个目录</p>
<blockquote>
<p>通常推荐用<code>rmdir</code>函数，其语义更加清晰</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>link/unlink</code>实例：在<code>main</code>函数中调用<code>test_link_unlink</code>函数</p>
<pre><code>void test_link_unlink()
{
 M_TRACE(&quot;---------  Begin test_link_unlink()  ---------\n&quot;);
 assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0);
 un_prepare_file(&quot;test1&quot;);

 print_file_link_num(&quot;test&quot;);
 My_link(&quot;test&quot;,&quot;test1&quot;);
 My_unlink(&quot;test1&quot;);
 print_file_link_num(&quot;test&quot;);
 My_unlink(&quot;test1&quot;);
 My_unlink(&quot;test&quot;);
 print_file_link_num(&quot;test&quot;);

 un_prepare_file(&quot;test&quot;);
 un_prepare_file(&quot;test1&quot;);
 M_TRACE(&quot;---------  End test_link_unlink()  ---------\n\n&quot;);
}
</code></pre><p>   <img src="../imgs/file_dir/link_unlink.JPG" alt="link_unlink"> </p>
<p> 可以看到：</p>
<ul>
<li><code>test</code>和<code>new_test</code>这两个文件共享一个 i 结点。因此该节点的 硬链接数为2</li>
<li>一旦删除 <code>new_test</code>，则对<code>new_test</code>执行 <code>fstatat</code>失败（因为已经被<code>unlink</code>）。同时<code>test</code>的硬链接数为1</li>
<li>一旦<code>test</code>也被删除，则 <code>i</code>节点被释放。执行<code>unlink</code>失败。</li>
</ul>
</li>
<li><p><code>remove</code>函数：解除对一个目录或者文件的链接。</p>
<pre><code> #include&lt;stdio.h&gt;
 int remove(const char *pathname);
</code></pre><ul>
<li>参数<ul>
<li><code>pathname</code>：文件名或者目录名</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功：返回0</li>
<li>失败：返回 -1</li>
</ul>
<p>对于文件，<code>remove</code>功能与<code>unlink</code>相同；对于目录，<code>remove</code>功能与<code>rmdir</code>相同</p>
</li>
</ul>
</li>
<li><p><code>rename/renameat</code>函数：重命名文件或目录</p>
<pre><code> #inluce&lt;stdio.h&gt;
 int rename(const char*oldname,const char *newname);
 int renameat(int oldfd,const char*oldname,int newfd,const char* newname);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>oldname</code>：现有的文件名或者目录名</li>
<li><p><code>newname</code>：重命名的名字</p>
<ul>
<li>如果<code>oldname</code>是个文件名，则为该文件或者符号链接重命名。<ul>
<li>此时若<code>newname</code>已存在：若<code>newname</code>是个目录则报错；若<code>newname</code>不是个目录：则先将<code>newname</code>目录项删除，然后将<code>oldname</code>重命名为<code>newname</code></li>
<li>此时若<code>newname</code>不存在：则直接将<code>oldname</code>重命名为<code>newname</code>    </li>
</ul>
</li>
<li>如果<code>oldname</code>是个目录名，则为该目录重命名。<ul>
<li>此时若<code>newname</code>已存在：若<code>newname</code>是个目录且该目录是个空目录，则先将它删除，然后<code>oldname</code>重命名为<code>newname</code>；若<code>newname</code>是个目录且该目录不是个空目录，则报错；若<code>newname</code>不是个目录，则报错</li>
<li>此时若<code>newname</code>不存在：则直接将<code>oldname</code>重命名为<code>newname</code><blockquote>
<p><code>oldname</code> 不能是 <code>newname</code> 的前缀。因为重命名时，需要删除<code>oldname</code></p>
</blockquote>
</li>
</ul>
</li>
<li>如果<code>oldname</code>或者<code>newname</code>引用的是符号链接，则处理的是符号链接本身，而不是它引用的文件</li>
<li>不能对<code>.</code>和<code>..</code>重命名。即<code>.</code>和<code>..</code>不能出现在<code>oldname</code>和<code>newname</code>的最后部分</li>
<li>若<code>newname</code>和<code>oldname</code>引用同一个文件，则函数不作任何更改而成功返回</li>
</ul>
<p>对于<code>renameat</code>函数：</p>
</li>
<li>现有的文件名或目录名是通过<code>oldfd</code>和<code>oldname</code>指定。<ul>
<li>若<code>oldname</code>是绝对路径，则忽略<code>oldfd</code></li>
<li>若 <code>oldname</code>是相对路径，则：<ul>
<li>若 <code>oldfd=AT_FDCWD</code>，则<code>oldname</code>是相对于当前工作目录来计算</li>
<li>若 <code>oldfd</code>是一个打开的目录文件的文件描述符，则<code>oldname</code>是相对于<code>oldfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li>重命名的文件名或目录名是通过<code>newfd</code>和<code>newname</code>指定。<ul>
<li>若<code>newname</code>是绝对路径，则忽略<code>newfd</code></li>
<li>若 <code>newname</code>是相对路径，则：<ul>
<li>若 <code>newfd=AT_FDCWD</code>，则<code>newname</code>是相对于当前工作目录来计算</li>
<li>若 <code>newfd</code>是一个打开的目录文件的文件描述符，则<code>newname</code>是相对于<code>newfd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：当现有文件是符号链接时的行为：<ul>
<li><code>flag=AT_SYMLINK_FOLLOW</code>：创建符号链接指向的文件的硬链接（跟随行为）</li>
<li><code>flag=!AT_SYMLINK_FOLLOW</code>:创建符号链接本身的硬链接（默认行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>对于包含<code>oldname</code>以及<code>newname</code>的目录，调用进程必须具有写和执行的权限，因为将同时更改这两个目录。</p>
</li>
</ul>
</li>
<li><p><code>symlink/symlinkat</code>函数：创建一个符号链接</p>
<pre><code> #include&lt;unistd.h&gt;
 int symlink(const char*actualpath,const char *sympath);
 int symlinkat(const char*actualpath,int fd,const char*sympath);
</code></pre><ul>
<li>参数：<ul>
<li><code>actualpath</code>：符号链接要指向的文件或者目录（可能尚不存在）</li>
<li><code>sympath</code>：符号链接的名字<blockquote>
<p>二者不要求位于同一个文件系统中</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>    对于`symlinkat`函数：
    - 符号链接的名字是通过`fd`和`sympath`指定。
        - 若`sympath`是绝对路径，则忽略`fd`
        - 若 `sympath`是相对路径，则：
            - 若 `fd=AT_FDCWD`，则`sympath`是相对于当前工作目录来计算
            - 若 `fd`是一个打开的目录文件的文件描述符，则`sympath`是相对于`fd`对应的目录文件

- 返回值：
    - 成功： 返回 0
    - 失败： 返回 -1
</code></pre><ol>
<li><p><code>readlink/readlinkat</code>函数：打开符号链接本身</p>
<blockquote>
<p><code>open</code>函数是跟随链接的，即打开符号链接指向的文件</p>
</blockquote>
<pre><code>#include&lt;unistd.h&gt;
ssize_t readlink(const char *restrict pathname,char *restrict buf,size_t bufsize);
ssize_t readlinkat(int fd, const char* restrict pathname,char *restrict buf,
    size_t bufsize);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：符号链接的名字</li>
<li><code>buf</code>：存放符号链接内容的缓冲区</li>
<li><p><code>bufsize</code>：期望读入缓冲区的字节数</p>
<p>对于<code>readlinkat</code>函数：</p>
</li>
<li><p>符号链接的名字是通过<code>fd</code>和<code>pathname</code>指定。</p>
<ul>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回实际上读取的字节数</li>
<li>失败： 返回 -1</li>
</ul>
</li>
</ul>
<p><code>readlink</code>和<code>readlinkat</code>函数组合了<code>open、read、close</code>函数的所有操作。</p>
<p>注意：读入<code>buf</code>中的符号链接的内容，并不是以<code>null</code>字节终止。</p>
<blockquote>
<p>以<code>null</code>字节终止的是内存中的字符串这种数据结构。而符号链接文件的内容是简单的字符序列，并不是字符串。</p>
</blockquote>
</li>
<li><p>符号链接示例：在<code>main</code>函数中调用<code>test_symlink_readlink</code>函数：</p>
<p>```<br>void test_symlink_readlink()<br>{<br>M_TRACE(“———  Begin test_symlink_readlink()  ———\n”);<br>assert(prepare_file(“test”,”abcdefg0123456”,14,S_IRWXU)==0); // 准备 test 文件<br>print_file_type(“test”); // 查看 test 文件类型</p>
<p>My_symlink(“test”,”test_symlink”); // 创建软连接 test_symlink 到 test<br>print_file_type(“test_symlink”); // 查看 test_symlink 文件类型<br>print_link_file(“test_symlink”); // 由于open 是链接跟随，所以这里打印 test 的内容</p>
<p>char buffer[128];<br>My_readlink(“test_symlink”,buffer,128);</p>
<p>un_prepare_file(“test”); // 删除 test 文件<br>un_prepare_file(“test_symlink”); // 删除 test_symlink 文件<br>M_TRACE(“———  End test_symlink_readlink()  ———\n\n”);<br>}</p>
</li>
</ol>
<pre><code>```

![symlink](../imgs/file_dir/symlink.JPG)  

可以看到：
- 符号链接文件的内容就是它链接到的那个文件的绝对路径名，其中路径名字符序列不包含 `null`字节
- 在 `ubuntu 16.04`中，经多次测试，符号链接文件和普通文件的 `st_mode`完全相同。
- `open`一个链接文件，然后`read`时发现读文件出错，原因是文件描述符有误（实际上打开文件时返回的文件描述符没问题）
</code></pre><h2 id="六、修改文件的时间"><a href="#六、修改文件的时间" class="headerlink" title="六、修改文件的时间"></a>六、修改文件的时间</h2><ol>
<li><p>文件的时间：在<code>stat</code>结构中存放着文件的三个时间：</p>
<ul>
<li><code>st_atim</code>：文件数据的最后访问时间</li>
<li><code>st_mtim</code>：文件数据的最后修改时间</li>
<li><p><code>st_ctim</code>： i 节点状态的最后更改时间</p>
<p>关于这三个时间：</p>
</li>
<li>有很多操作，比如修改文件权限，修改文件的所有者等操作，他们只修改 i 节点状态（只影响<code>st_ctim</code>），但是并不修改文件数据，也并不访问文件数据</li>
<li>系统并不维护对 <code>i</code> 节点的最后访问时间。因此对于 <code>access</code>函数和 <code>stat</code>函数，他们并不修改这三个时间中的任何一个</li>
<li>创建一个文件不仅影响了文件本身的这三个时间，也会影响该文件目录的这三个时间</li>
</ul>
</li>
<li><p><code>futimens/utimensat/utimes</code>函数：修改文件的访问和修改时间</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int futimens(int fd,const struct timespec times[2]);
 int utimensat(int fd,const char*path,const struct timespec times[2],int flag);
 #include&lt;sys/time.h&gt;
 int utimes(const char*pathname,const struct timeval times[2]);
</code></pre><ul>
<li><p>参数：</p>
<p>  对于  <code>futimens</code>和 <code>utimensat</code>函数：</p>
<ul>
<li><p><code>times</code>：指向待修改文件的指定的文件数据访问和文件数据修改时间的指针。</p>
<blockquote>
<p>对于C语言，参数中的数组自动转换为指向数组的指针</p>
</blockquote>
<ul>
<li>这两个时间是日历时间，是自 1970:01:01–00:00:00 以来经历的秒数。不足秒的部分用纳秒表示</li>
<li>数组的第一个元素指定 <code>st_atim</code>；数组的第二个元素指定 <code>st_ctim</code></li>
<li><code>times</code>可以按照下列四种方式之一指定：<ul>
<li><code>times</code>为空指针： 则将文件的数据访问时间和文件数据修改时间设置为当前时间<blockquote>
<p> 此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程</p>
</blockquote>
</li>
<li><code>times</code>参数是指向<code>timespec</code>数组的指针：<ul>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为 <code>UTIME_NOW</code>，则相应的时间戳就设置为当前时间，忽略相应的<code>tv_sec</code>字段<blockquote>
<p>此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程</p>
</blockquote>
</li>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为 <code>UTIME_OMIT</code>，则相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段<blockquote>
<p>若两个时间戳都忽略，则不需要任何权限限制</p>
</blockquote>
</li>
<li>若数组的任何一个元素的<code>tv_nsec</code>字段为不是上面的两种之一，则相应的时间戳就设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段<blockquote>
<p>此时要求进程的有效用户ID等于该文件所有者的ID；或者进程是个超级用户进程（对文件只有写权限是不够的）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于 <code>utimes</code>函数：</p>
</li>
<li><code>pathname</code>：文件的路径名</li>
<li><p><code>times</code>：指向<code>timeval</code>数组的指针。 <code>timeval</code>结构用秒和微秒表示。</p>
<pre><code>  struct timeval{
      time_t tv_sec;//秒
      long tv_usec; //微秒
  };
</code></pre><p>对于 <code>futimens</code>函数：</p>
</li>
<li><p><code>fd</code>：待修改文件的打开的文件描述符</p>
<p>对于 <code>utimensat</code>函数：</p>
</li>
<li>待打开文件的名字是通过<code>fd</code>和<code>path</code>指定。<ul>
<li>若<code>path</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>path</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>path</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>path</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><code>flag</code>：若待修改的文件是符号链接<ul>
<li>如果为<code>!AT_SYMLINK_FOLLOW</code>，则符号链接本身的时间就会被修改</li>
<li>默认情况下，修改的是符号链接指向的文件的时间（跟随行为）</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回 0</li>
<li>失败： 返回 -1</li>
</ul>
<p>我们不能对<code>st_ctim</code>（i节点最后被修改时间）指定一个值。这个时间是被自动更新的。</p>
</li>
</ul>
</li>
<li><p>示例：在 <code>main</code>函数中调用<code>test_utimes</code>函数： </p>
</li>
</ol>
<pre><code>void test_utimes()
{
    M_TRACE(&quot;---------  Begin test_utimes()  ---------\n&quot;);
    assert(prepare_file(&quot;test&quot;,NULL,0,S_IRWXU)==0); // 准备 test 文件
    print_file_time(&quot;test&quot;);
    sleep(2);
    My_access(&quot;test&quot;,F_OK); // 访问文件，但不修改文件
    print_file_time(&quot;test&quot;);
    sleep(2);
    My_chmod(&quot;test&quot;,S_IRUSR|S_IWUSR);//  修改文件状态
    print_file_time(&quot;test&quot;);

    struct timeval times[2];
    times[0].tv_usec=10;
    times[1].tv_sec=10;
    times[1].tv_usec=10;
    My_utimes(&quot;test&quot;,times);

    un_prepare_file(&quot;test&quot;); // 删除 test 文件
    M_TRACE(&quot;---------  End test_utimes()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![utimes](../imgs/file_dir/utimes.JPG)     
可以看到：
- `st_ctim`是由系统自动维护的，程序员无法手动指定
</code></pre><h2 id="七、目录操作"><a href="#七、目录操作" class="headerlink" title="七、目录操作"></a>七、目录操作</h2><ol>
<li><p><code>mkdir/mkdirat</code>函数创建一个空目录：</p>
<pre><code> #include&lt;sys/stat.h&gt;
 int mkdir(const char*pathname,mode_t mode);
 int mkdirat(int fd,const char *pathname,mode_t mode);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>:被创建目录的名字</li>
<li><p><code>mode</code>:被创建目录的权限</p>
<p>对于 <code>mkdirat</code>，被创建目录的名字是由<code>fd</code>和<code>pathname</code>共同决定的。</p>
</li>
<li>若<code>pathname</code>是绝对路径，则忽略<code>fd</code></li>
<li>若 <code>pathname</code>是相对路径，则：<ul>
<li>若 <code>fd=AT_FDCWD</code>，则<code>pathname</code>是相对于当前工作目录来计算</li>
<li>若 <code>fd</code>是一个打开的目录文件的文件描述符，则<code>pathname</code>是相对于<code>fd</code>对应的目录文件</li>
</ul>
</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回 -1</li>
</ul>
<p>注意：</p>
</li>
<li>他们创建的目录是空目录。</li>
<li>对于目录，通常至少要设置一个执行权限位，以允许访问该目录中的文件名</li>
</ul>
</li>
<li><p><code>rmdir</code>函数：删除一个空目录</p>
<pre><code> #include&lt;unistd.h&gt;
 int rmdir(const char *pathname);
</code></pre><ul>
<li><p>参数：</p>
<ul>
<li><code>pathname</code>：待删除的空目录的名字</li>
</ul>
</li>
<li><p>返回值：</p>
<ul>
<li>成功： 返回0</li>
<li>失败： 返回 -1</li>
</ul>
<p>如果调用此函数使得目录的链接计数为0时：    </p>
</li>
<li>如果此时没有其他进程打开该目录，则释放由此目录占用的空间。</li>
<li>如果此时有一个或者多个进程打开此目录，则在此函数返回时删除最后一个链接以及 <code>.</code>和<code>..</code>项，直到最后一个打开该目录的进程关闭该目录时此目录才真正被释放。<ul>
<li>此时，在此目录中不能再创建新文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>读、写目录：对于某个目录具有访问权限的任何用户都可以读该目录。但是为了防止文件系统产生混乱，只有内核才能写目录。</p>
<blockquote>
<p>一个目录的写权限和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不能写目录本身</p>
</blockquote>
<pre><code> #include&lt;dirent.h&gt;
 DIR *opendir(const char *pathname);
 DIR *fdopendir(int fd);
 struct dirent *readdir(DIR *dp);
 void rewinddir(DIR *dp);
 int closedir(DIR *dp);
 long telldir(DIR *dp);
 void seekdir(DIR *dp,long loc);
</code></pre><p> 各个函数：</p>
<ul>
<li><code>opendir</code>：打开目录。<ul>
<li>参数：<code>pathname</code>：目录的名字</li>
<li>返回值：成功返回目录指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>fdopendir</code>：打开目录。<ul>
<li>参数：<code>fd</code>：目录文件的文件描述符</li>
<li>返回值：成功返回目录指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>readdir</code>：读取目录<ul>
<li>参数： <code>dp</code>：目录指针</li>
<li>返回值： 成功则返回目录项的指针；失败返回 <code>NULL</code></li>
</ul>
</li>
<li><code>rewinddir</code>:将目录的文件偏移量清零（这样下次读取就是从头开始）<ul>
<li>参数：<code>dp</code>：目录指针</li>
</ul>
</li>
<li><code>closedir</code>：关闭目录。<ul>
<li>参数：<code>dp</code>：目录指针</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>telldir</code>：返回目录的文件偏移量<ul>
<li>参数：<code>dp</code>：目录指针</li>
<li>返回值：成功返回目录的文件偏移量 ；失败返回 -1</li>
</ul>
</li>
<li><p><code>seekdir</code>：设置目录的当前位置</p>
<ul>
<li>参数：<code>dp</code>：目录指针；<code>loc</code>：要设定的文件偏移量</li>
</ul>
<p>对于 <code>DIR</code>结构，它是一个内部结构。起作用类似于 <code>FILE</code>结构。<br>对于<code>dirent</code>结构，它是定义在<code>&lt;dirent.h&gt;</code>头文件中。其与具体操作系统相关。但是它至少定义了两个成员：</p>
<pre><code>struct dirent{
ino_t d_ino; // i 节点编号
char d_name[];// 以 null 结尾的文件名字符串
}
</code></pre><blockquote>
<p><code>d_name</code>项的大小并没有指定，但必须保证它能包含至少 <code>NAME_MAX</code>个字节（不包含终止<code>null</code>字节）</p>
</blockquote>
<p>目录中各目录项的顺序与操作系统有关。它们通常不按照字母顺序排列</p>
</li>
</ul>
</li>
<li><p>当前工作目录：每个进程都有一个当前工作目录。此目录是搜索所有相对路径名的起点。</p>
<blockquote>
<p>当前工作目录是本进程的一个属性</p>
</blockquote>
<p> 与当前工作目录相关的有三个函数：</p>
<pre><code> #include&lt;unistd.h&gt;
 int chdir(const char *pathname);
 int fchdir(int fd);
 char *getcwd(char *buf,size_t size);
</code></pre><p> 各个函数：</p>
<ul>
<li><code>chdir</code>：更改当前工作目录。<ul>
<li>参数：<code>pathname</code>：将该目录作为当前工作目录</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>fchdir</code>：更改当前工作目录。<ul>
<li>参数：<code>fd</code>：将该 <code>fd</code> 文件描述符对应的目录作为当前工作目录</li>
<li>返回值：成功返回 0 ；失败返回 -1</li>
</ul>
</li>
<li><code>getcwd</code>：返回当前工作目录的名字<ul>
<li>参数： <code>buf</code>：缓冲区地址；<code>size</code>：缓冲区长度。这两个参数决定了当前工作目录名字字符串存放的位置。<blockquote>
<p>缓冲区必须足够长以容纳绝对路径名加上一个终止<code>null</code>字节。否则返回出错。</p>
</blockquote>
</li>
<li>返回值： 成功则返回 <code>buf</code>；失败返回 <code>NULL</code></li>
</ul>
</li>
</ul>
</li>
<li><p>示例： 在<code>main</code>函数中调用 <code>test_dir_operations</code> 函数：</p>
</li>
</ol>
<pre><code>void test_dir_operations()
{
    M_TRACE(&quot;---------  Begin test_dir_operations()  ---------\n&quot;);
    //*** 创建目录 ****
    My_mkdir(&quot;test&quot;,S_IRWXU);
    My_mkdir(&quot;test/test1&quot;,S_IRWXU);

    //*** 创建文件
    prepare_file(&quot;test/tfile_1&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/tfile_2&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/tfile_3&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_11&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_22&quot;,NULL,0,S_IRWXU);
    prepare_file(&quot;test/test1/tfile_33&quot;,NULL,0,S_IRWXU);

    print_dir(&quot;test&quot;);

    print_cwd();
    My_chdir(&quot;test&quot;);
    print_cwd();
    My_chdir(&quot;../&quot;); // 切换回来，否则后面的删除文件都会失败（因为都是相对路径）
    print_cwd();
    //***** 清理
    My_rmdir(&quot;test&quot;); // 目录非空，删除失败！
    un_prepare_file(&quot;test/tfile_1&quot;);
    un_prepare_file(&quot;test/tfile_2&quot;);
    un_prepare_file(&quot;test/tfile_3&quot;);
    un_prepare_file(&quot;test/test1/tfile_11&quot;);
    un_prepare_file(&quot;test/test1/tfile_22&quot;);
    un_prepare_file(&quot;test/test1/tfile_33&quot;);
    My_rmdir(&quot;test/test1&quot;); // 必须非空才能删除成功
    My_rmdir(&quot;test&quot;); // 必须非空才能删除成功
    M_TRACE(&quot;---------  End test_dir_operations()  ---------\n\n&quot;);
}
</code></pre><pre><code>  ![dir_function](../imgs/file_dir/dir_function.JPG) %                                                                    
</code></pre>]]></content>
      
        <categories>
            
            <category> apue </category>
            
        </categories>
        
        
        <tags>
            
            <tag> apue,文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C语言指针&内存分配]]></title>
      <url>/2017/11/27/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88&amp;%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<blockquote>
<p>指针也是一种数据类型。</p>
</blockquote>
<a id="more"></a>
<h2 id="对数据类型的认识"><a href="#对数据类型的认识" class="headerlink" title="对数据类型的认识"></a>对数据类型的认识</h2><h3 id="常见非指针类型"><a href="#常见非指针类型" class="headerlink" title="常见非指针类型"></a>常见非指针类型</h3><p><code>int型，char型，long型 ...</code><br><code>int a=10</code><br>中心：该内存空间<br>a ：内存空间代号<br>10：内存空间存放的数据<br>&amp;a：a对应的地址编号（该内存空间对应的地址编号）（32位系统编号有32位，64位系统编号有64位）</p>
<blockquote>
<p>小插曲，回顾32&amp;64位系统的变量类型的不同之处：</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">32(byte)</th>
<th>64(byte)</th>
</tr>
</thead>
<tbody>
<tr>
<td>long</td>
<td style="text-align:center">4</td>
<td>8</td>
</tr>
<tr>
<td>int *(指针型变量)</td>
<td style="text-align:center">4</td>
<td>8</td>
</tr>
</tbody>
</table>
<h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p><code>char * ,int *,long * ,...</code></p>
<pre><code>int b=10
int *a=&amp;b
</code></pre><p>中心：该内存空间（这条表达式是重点：<code>int *a=&amp;b</code>）<br>a: 该内存空间的代号<br>&amp;b：该内存空间中存放的数据（是一个地址编号，本例中是存放b的内存空间的地址编号）<br>&amp;a：a对应的地址编号（该内存空间对应的地址编号）</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型比较特殊：</p>
<pre><code>int func(){
    return 0;
}
</code></pre><p>在内存中函数存放与代码段地址空间（不可修改），所以对函数取地址<code>&amp;func</code>，得到的是代码段，该函数对应的地址。<br>有一个有趣的现象是，gdb调试时，<code>p func</code>,<code>p *func</code>,<code>p &amp;func</code>,得到的全是func函数对应的代码段地址。</p>
<pre><code>(gdb) p func
$1 = {int (int)} 0x6b0 &lt;func&gt;
(gdb) p *func
$2 = {int (int)} 0x6b0 &lt;func&gt;
(gdb) p &amp;func
$3 = (int (*)(int)) 0x6b0 &lt;func&gt;
</code></pre><p>也许函数名本本身就是一个特殊的指针变量，指向自己。但是（*func）好像没有意义。如果是自己定义的指针类型，是可以指向对应类型的函数的，这个时候和普通的指针类型是一样的。</p>
<pre><code class="C">9    int func(int a)
10    {
11        int b=10;
12        printf(&quot;a=%d\nb=%d\n&quot;,a,b);
13        return a*b;
14    }


15    int func1(int b){
16        return 0;
17    }

22    int main()
23    {
24        int a=12;
25        int (*pfunc)(int a)=&amp;func;
26        int b = (*pfunc)(a);
27        pfunc=&amp;func1;


(gdb) p pfunc 
$2 = (int (*)(int)) 0x5555555546e4 &lt;func1&gt;
(gdb) p func
$3 = {int (int)} 0x5555555546b0 &lt;func&gt;
(gdb) p func1
$4 = {int (int)} 0x5555555546e4 &lt;func1&gt;
(gdb) p main
$5 = {int ()} 0x5555555546f2 &lt;main&gt;
(gdb) p &amp;pfunc 
$6 = (int (**)(int)) 0x7fffffffe168
</code></pre>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><ol>
<li>数组在虚拟内存中，是连续存储的。</li>
<li><code>char *s=&quot;fdl&quot;</code>,这种这是字符串常量定义的一种方式，不能做修改，如同<code>const int a=10</code>，此类常量存在于内存中的数据段。</li>
</ol>
<h2 id="内存组织形式"><a href="#内存组织形式" class="headerlink" title="内存组织形式"></a>内存组织形式</h2><p>参考：<a href="http://blog.csdn.net/gatieme/article/details/43567433" target="_blank" rel="external">C程序的内存布局(Memory Layout)</a></p>
<p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1511797169278.jpg" alt="C语言目标文件的内存布局"></p>
<p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1511797204333.jpg" alt="C语言可执行程序的内存分布"></p>
]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言,内存分配 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[celery学习笔记]]></title>
      <url>/2017/11/19/celery%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在程序的运行过程中，我们经常会遇到一些耗时耗资源的操作，为了避免他们阻塞主程序的运行，我们经常会采用多线程或异步任务。比如，在web开发中，    对于新用户的注册，我们通常会给他们发送一封激活邮件，而发送邮件是个IO阻塞式任务，如果直接把它放到应用当中去，就需要等邮件发出去之后才能进行下一步操作，此时用户只能等待再等待，更好的方式是在业务逻辑中触发一个发送邮件的异步任务，而主程序可以继续往下执行。<br><a id="more"></a><br><a href="https://github.com/celery/celery" target="_blank" rel="external">Celery</a>是一个强大的<code>分布式任务队列</code>,他可以让任务执行完全脱离主程序，甚至他可以被分配到其他主机上运行。我们通常使用它来实现异步任务（async task）和定时任务（crontab）。它的架构组图如下：</p>
<p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1511082386190.jpg" alt="celery 架构图"></p>
<ul>
<li>任务模块Task<ul>
<li>包含异步和定时任务。其中，异步任务通常在业务逻辑中被触发然后发往任务队列中，而定时任务由Celery Beat 进程周期性地将任务发往任务队列。</li>
</ul>
</li>
<li>消息中间件Broker<ul>
<li>Broker，即任务调度队列，接受任务生产者发来的消息（即任务），将任务存入队列。Celery本身不提供队列服务，官方推荐使用RabbitMQ和Redis等。</li>
</ul>
</li>
<li>任务执行单元Worker<ul>
<li>Worker是执行任务的处理单元，它实时监控消息队列，获取队列中调度的任务，并执行它。</li>
</ul>
</li>
<li>任务结果存储Backend<pre><code>  - Backend用于存储任务的执行结果，以供查询。同消息中间件一样，存储也可以使用RabbitMQ，Radis，和MongoDB等。
</code></pre></li>
</ul>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>使用celery实现异步任务主要包含三个步骤：</p>
<ol>
<li>创建一个celery实例</li>
<li>启动Celery Worker</li>
<li>应用程序调用异步任务<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3>正确安装celery，redis以及使用redis的celery相关依赖:</li>
</ol>
<pre><code class="shell?linenums">redis 我用的是容器，直接
docker pull redis
docker run -d -p 6379:6379 --name redis redis:latest

pip install celery
pip install &#39;celery[redis]&#39;
</code></pre>
<h4 id="创建Celery实例"><a href="#创建Celery实例" class="headerlink" title="创建Celery实例"></a>创建Celery实例</h4><p>编写tasks.py</p>
<pre><code class="python"># -*- coding: utf-8 -*-

import time
from celery import Celery

broker = &#39;redis://127.0.0.1:6379&#39;
backend = &#39;redis://127.0.0.1:6379/0&#39;

app = Celery(&#39;my_task&#39;, broker=broker, backend=backend)

@app.task
def add(x, y):
    time.sleep(5)     # 模拟耗时操作
    return x + y
</code></pre>
<p>上面代码，做了以下几件事情，</p>
<ul>
<li>创建了一个Celery实例app，名称为<code>my_task</code>;</li>
<li>指定消息中间件为redis，URL为 <code>redis://127.0.0.1:6379</code>;</li>
<li>指定存储用redis，URL为<code>redis://127.0.0.1:6379/0</code>; </li>
<li>创建了一个celery任务<code>add</code> ，当函数被<code>@app.task</code>装饰后，就成为可被Celery调度的任务。</li>
</ul>
<h4 id="启动Celery-Worker"><a href="#启动Celery-Worker" class="headerlink" title="启动Celery Worker"></a>启动Celery Worker</h4><p>在当前目录，使用如下方式启动Celery Worker</p>
<pre><code>$ celery worker -A tasks --loglevel=info
</code></pre><p>其中：</p>
<ul>
<li>参数 <code>-A</code> 指定了Celery实例的位置，本例是在 <code>tasks.py</code> 中，Celery会自动在该文件中寻找Celery对象实例，当然我们也可以指定，在本例中使用 <code>-A tasks.app</code> ;</li>
<li>参数 <code>--loglevel</code> 指定了日志的级别，默认为warning，也可以使用 <code>-l info</code> 来表示。</li>
</ul>
<p>在生产环境中，我们通常会使用Supervisor来控制Celery Worker 进程。<br>启动成功后，控制台会显示如下输出（最后两行输出是我调用了task后的输出，刚开始时没有）：<br><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1511101696833.jpg" alt="启动celery worker"></p>
<h4 id="调用任务"><a href="#调用任务" class="headerlink" title="调用任务"></a>调用任务</h4><p> 现在我们可以通过<code>delay()</code>和<code>apply_async()</code> 方法来调用任务。</p>
<p> 在当前目录打开Python控制台，输入以下代码：</p>
<pre><code class="python"> (qw_export_post_env) 
 日 19 11月 - 22:25  ~/code/py/celery 
 @dl  python 
Python 2.7.13+ (default, Jul 19 2017, 18:15:03) 
[GCC 6.4.0 20170704] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; from tasks import add 
&gt;&gt;&gt; add.delay(2,1)
&lt;AsyncResult: d8be1e96-37bd-4868-9276-7bceafb99ae7&gt;
&gt;&gt;&gt; result=add.delay(2,1)
&gt;&gt;&gt; result.ready() # 使用 ready() 判断任务是否执行完毕
True
&gt;&gt;&gt; result.get() # 使用 get() 获取任务结果
3
&gt;&gt;&gt; result=add.delay(2,1)
&gt;&gt;&gt; result.get()
3
&gt;&gt;&gt; result=add.delay(2,1)
&gt;&gt;&gt; result.ready()
False
&gt;&gt;&gt; result.ready()
True
&gt;&gt;&gt; result.get()
3
</code></pre>
<p>在上面，我们从<code>tasks.py</code> 文件中导入了 <code>add</code> 任务对象，然后使用 <code>delay()</code> 方法将任务发送到消息中间件（Broker） ，Celery Worker进程监控到该任务后，就会进行执行。上面图片上最后两行输出，就是执行该任务的日志。这说明该任务已经被调度并执行成功。</p>
<p>上面我们是在 Python的环境中调用的任务。事实上，我们通常在应用程序中调用任务。比如我们将下面的程序保存为<code>client.py</code>:</p>
<pre><code class="python"># -*- coding: utf-8 -*-

from tasks import add

# 异步任务
add.delay(2, 8)

print &#39;hello world&#39;
</code></pre>
<h3 id="使用配置"><a href="#使用配置" class="headerlink" title="使用配置"></a>使用配置</h3><p>分离配置文件任务文件，以及应用程序。<br>在上面的例子中，我们直接把 Broker 和 Backend 的配置写在了程序当中，更好的做法是将配置项统一写入到一个配置文件中，通常我们将该文件命名为 <code>celeryconfig.py</code> 。    Celery 的配置比较多，可以在<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html" target="_blank" rel="external">官方文档</a>查询每个配置项的含义。</p>
<p>下面，我们再看一个例子。项目结构如下：</p>
<pre><code>celery_demo                    # 项目根目录
    ├── celery_app             # 存放 celery 相关文件
    │   ├── __init__.py
    │   ├── celeryconfig.py    # 配置文件
    │   ├── task1.py           # 任务文件 1
    │   └── task2.py           # 任务文件 2
    └── client.py              # 应用程序`
</code></pre><p><code>__init__.py</code> 代码如下：</p>
<pre><code># -*- coding: utf-8 -*-

from celery import Celery

app = Celery(&#39;demo&#39;)                                # 创建 Celery 实例
app.config_from_object(&#39;celery_app.celeryconfig&#39;)   # 通过 Celery 实例加载配置模块
</code></pre><p><code>celeryconfig.py</code> 代码如下：</p>
<pre><code>BROKER_URL = &#39;redis://127.0.0.1:6379&#39;               # 指定 Broker
CELERY_RESULT_BACKEND = &#39;redis://127.0.0.1:6379/0&#39;  # 指定 Backend

CELERY_TIMEZONE=&#39;Asia/Shanghai&#39;                     # 指定时区，默认是 UTC
# CELERY_TIMEZONE=&#39;UTC&#39;                             

CELERY_IMPORTS = (                                  # 指定导入的任务模块
    &#39;celery_app.task1&#39;,
    &#39;celery_app.task2&#39;
)
</code></pre><p><code>task1.py</code> 代码如下：</p>
<pre><code>import time
from celery_app import app

@app.task
def add(x, y):
    time.sleep(2)
    return x + y
</code></pre><p><code>task2.py</code> 代码如下：</p>
<pre><code>import time
from celery_app import app

@app.task
def multiply(x, y):
    time.sleep(2)
    return x * y
</code></pre><p><code>client.py</code> 代码如下：</p>
<pre><code class="python">#!/usr/bin/env python
# coding=utf-8
from celery_app import task1
from celery_app import task2
import time

result1=task1.add.apply_async(args=[2,8])
result2=task2.multiply.apply_async(args=[3,8])

print &quot;hello&quot; 

while(not result1.ready() or not result2.ready()):
    time.sleep(0.5)
    print result1.ready()
print result1.get()
print result2.get()
</code></pre>
<p>现在，让我们启动 Celery Worker 进程，在项目的根目录下执行下面命令：</p>
<pre><code>celery_demo $ celery -A celery_app worker --loglevel=info
</code></pre><p>接着，运行 <code>$ python client.py</code> ，它会发送两个异步任务到 Broker，在 Worker 的窗口我们可以看到如下输出：</p>
<pre><code>[2017-11-19 22:50:39,573: INFO/MainProcess] Received task: celery_app.task1.add[b6e8b247-9f94-4b77-8181-2613247df0f6]  
[2017-11-19 22:50:39,575: INFO/MainProcess] Received task: celery_app.task2.multiply[c578f21b-d8c6-453f-8d2f-f9d1f16a57fd]  
[2017-11-19 22:50:41,585: INFO/ForkPoolWorker-1] Task celery_app.task1.add[b6e8b247-9f94-4b77-8181-2613247df0f6] succeeded in 2.010242356s: 10
[2017-11-19 22:50:41,585: INFO/ForkPoolWorker-3] Task celery_app.task2.multiply[c578f21b-d8c6-453f-8d2f-f9d1f16a57fd] succeeded in 2.009279021s: 24
</code></pre><p>执行输出：</p>
<pre><code class="python"> @dl  python client.py 
hello
False
False
False
False
10
24
</code></pre>
<h3 id="delay-和-apply-async"><a href="#delay-和-apply-async" class="headerlink" title="delay 和 apply_async"></a>delay 和 apply_async</h3><p>在前面的例子中，我们使用 <code>delay()</code> 或 <code>apply_async()</code> 方法来调用任务。事实上，<code>delay</code> 方法封装了 <code>apply_async</code>，如下：</p>
<pre><code>def delay(self, *partial_args, **partial_kwargs):
    &quot;&quot;&quot;Shortcut to :meth:`apply_async` using star arguments.&quot;&quot;&quot;
    return self.apply_async(partial_args, partial_kwargs)
</code></pre><p>也就是说，<code>delay</code> 是使用 <code>apply_async</code> 的快捷方式。<code>apply_async</code> 支持更多的参数，它的一般形式如下：</p>
<pre><code>apply_async(args=(), kwargs={}, route_name=None, **options)
</code></pre><p><code>apply_async</code> 常用的参数如下：</p>
<ul>
<li>countdown：指定多少秒后执行任务<pre><code>task1.apply_async(args=(2, 3), countdown=5)    # 5 秒后执行任务
</code></pre></li>
<li>eta (estimated time of arrival)：指定任务被调度的具体时间，参数类型是 datetime<pre><code>from datetime import datetime, timedelta
# 当前 UTC 时间再加 10 秒后执行任务
task1.multiply.apply_async(args=[3, 7], eta=datetime.utcnow() + timedelta(seconds=10))
</code></pre></li>
<li>expires：任务过期时间，参数类型可以是 int，也可以是 datetime<pre><code>task1.multiply.apply_async(args=[3, 7], expires=10)    # 10 秒后过期
</code></pre>更多的参数列表可以在<a href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.apply_async" target="_blank" rel="external">官方文档</a>中查看。</li>
</ul>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>Celery 除了可以执行<strong>异步任务</strong>，也支持执行<strong>周期性任务（Periodic Tasks）</strong>，或者说定时任务。Celery Beat 进程通过读取配置文件的内容，周期性地将定时任务发往任务队列。</p>
<p>让我们看看例子，项目结构如下：</p>
<pre><code>celery_demo                    # 项目根目录
    ├── celery_app             # 存放 celery 相关文件
        ├── __init__.py
        ├── celeryconfig.py    # 配置文件
        ├── task1.py           # 任务文件
        └── task2.py           # 任务文件
</code></pre><p><code>__init__.py</code> 代码如下：</p>
<pre><code># -*- coding: utf-8 -*-

from celery import Celery

app = Celery(&#39;demo&#39;)
app.config_from_object(&#39;celery_app.celeryconfig&#39;)
celeryconfig.py 代码如下：

# -*- coding: utf-8 -*-

from datetime import timedelta
from celery.schedules import crontab

# Broker and Backend
BROKER_URL = &#39;redis://127.0.0.1:6379&#39;
CELERY_RESULT_BACKEND = &#39;redis://127.0.0.1:6379/0&#39;

# Timezone
CELERY_TIMEZONE=&#39;Asia/Shanghai&#39;    # 指定时区，不指定默认为 &#39;UTC&#39;
# CELERY_TIMEZONE=&#39;UTC&#39;

# import
CELERY_IMPORTS = (
    &#39;celery_app.task1&#39;,
    &#39;celery_app.task2&#39;
)

# schedules
CELERYBEAT_SCHEDULE = {
    &#39;add-every-30-seconds&#39;: {
         &#39;task&#39;: &#39;celery_app.task1.add&#39;,
         &#39;schedule&#39;: timedelta(seconds=30),       # 每 30 秒执行一次
         &#39;args&#39;: (5, 8)                           # 任务函数参数
    },
    &#39;multiply-at-some-time&#39;: {
        &#39;task&#39;: &#39;celery_app.task2.multiply&#39;,
        &#39;schedule&#39;: crontab(hour=9, minute=50),   # 每天早上 9 点 50 分执行一次
        &#39;args&#39;: (3, 7)                            # 任务函数参数
    }
}
</code></pre><p><code>task1.py</code> 代码如下：</p>
<pre><code>import time
from celery_app import app

@app.task
def add(x, y):
    time.sleep(2)
    return x + y
</code></pre><p><code>task2.py</code> 代码如下：</p>
<pre><code>import time
from celery_app import app

@app.task
def multiply(x, y):
    time.sleep(2)
    return x * y
</code></pre><p>现在，让我们启动 <code>Celery Worker</code> 进程，在项目的根目录下执行下面命令：</p>
<pre><code>celery_demo $ celery -A celery_app worker --loglevel=info
</code></pre><p>接着，启动 <code>Celery Beat</code> 进程，定时将任务发送到 <code>Broker</code>，在项目根目录下执行下面命令：</p>
<pre><code>celery_demo $ celery beat -A celery_app
celery beat v4.0.1 (latentcall) is starting.
__    -    ... __   -        _
LocalTime -&gt; 2016-12-11 09:48:16
Configuration -&gt;
    . broker -&gt; redis://127.0.0.1:6379//
    . loader -&gt; celery.loaders.app.AppLoader
    . scheduler -&gt; celery.beat.PersistentScheduler
    . db -&gt; celerybeat-schedule
    . logfile -&gt; [stderr]@%WARNING
    . maxinterval -&gt; 5.00 minutes (300s)
</code></pre><p>之后，在 Worker 窗口我们可以看到，任务 task1 每 30 秒执行一次，而 task2 每天早上 9 点 50 分执行一次。</p>
<p>在上面，我们用两个命令启动了 Worker 进程和 Beat 进程，我们也可以将它们放在一个命令中：</p>
<pre><code>$ celery -B -A celery_app worker --loglevel=info
</code></pre><p>Celery 周期性任务也有多个配置项，可参考<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html" target="_blank" rel="external">官方文档</a>。</p>
<p><a href="http://geek.csdn.net/news/detail/128791" target="_blank" rel="external">转载自</a></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python,web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OJ查重设计]]></title>
      <url>/2017/11/14/OJ%E6%9F%A5%E9%87%8D%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>因为OJ有一个查重功能需要完善，所以我今天查阅了百度和google，目前可以用的有standford的moss和<a href="https://dickgrune.com/" target="_blank" rel="external">Dick grune</a>的<a href="https://dickgrune.com/Programs/similarity_tester/" target="_blank" rel="external">sim</a>。<br><a id="more"></a></p>
<h2 id="sim"><a href="#sim" class="headerlink" title="sim"></a>sim</h2><blockquote>
<p>一个实用的代码查重工具</p>
</blockquote>
<p>点击上面的sim就可以下载，支持Unix like OS 和windows。<br>支持的语言有： C, C++, Java, Pascal, Modula-2, Lisp, Miranda and<br>natural language text.</p>
<h3 id="Linux安装sim"><a href="#Linux安装sim" class="headerlink" title="Linux安装sim"></a>Linux安装sim</h3><p>依赖下面几个程序：</p>
<ul>
<li>gcc, <code>flex</code>, cp, ln, echo, rm, and wc</li>
<li>其中flex可能需要单独安装</li>
</ul>
<p>有个小坑，sim-***.zip文件是直接在项目根目录里面压缩的，所以解压时（unzip）先新建一个文件夹，把zip放进去，在解压。</p>
<p>然后，需要修改Makefile后才能安装。<br>不然Make会出错。</p>
<p>打开Makefile，大概是55-72行，是windows的安装选项，我们实在linux下安装，所以不需要，把这些行删除掉。然后修改44,45,46行，我修改后如下：</p>
<pre><code>DIR =        /home/dl
BINDIR =    /usr/bin
MAN1DIR =    /usr/share/man/man1
</code></pre><p>Ubuntu的话，直接照抄我的，保存就可以。这个DIR变量不重要，BINDIR表示生成的可执行文件存放的位置，放在/usr/bin下可以直接执行sim的这些命令，因为<code>/usr/bin</code>一般都存在与环境变量下。MANDIR表示man手册的安装位置，ubuntu（debian系）的是这个，其他的不太清楚。<br>然后，就可以执行make的相关命令了，可以先执行<code>make help</code>查看make相关命令。<br>make test<br>生成sim_c , 并执行sim_c的相关案例。没问题的话，就可以执行：</p>
<pre><code>make clean
make install
</code></pre><p>执行完成后，sim就安装完毕了。以下命令就安装好了，分别支持对应的语言。</p>
<pre><code>sim_c     sim_c++   sim_java  sim_lisp  sim_m2    sim_mira  sim_pasc  sim_text
</code></pre><h3 id="sim-使用"><a href="#sim-使用" class="headerlink" title="sim 使用"></a>sim 使用</h3><p>查看sim.pdf,好吧，看这个如果英语不好的话，很痛苦。我列举以下常用的：</p>
<pre><code>-r N：显示重复百分比大于N的比较项。（没有-r参数的话，N默认24）
-w N：设置输出显示的行宽（没有-w参数的话，N默认80）
-p：输出百分比.（默认是对比每两个文件握一次手，以前面的文件为主，共【（n^2-n）/2】次。
-o file：将输出的内容重定向到file文件
-O：在命令执行的开始显示每个参数代表的含义。（我就是利用这个参数快速学会了sim的使用）
-M：在最后显示内存使用情况。
-a:对比所有，目前还不太清楚。（每个文件都与其他的文件握一次手，【n^2-n】次）
-e:单独对比每一个。（比较次数同-p，但是比较内容策略，与-a，-p有何不同，还没弄清楚）
</code></pre><h3 id="后期工作"><a href="#后期工作" class="headerlink" title="后期工作"></a>后期工作</h3><p>基于sim，利用python，封装一个独立的、方便使用的查重工具。<br>python 取得代码<br>sim<br>python 后台数据库过滤，取得代码，存入文件，文件名为username_time.language,存在一个以该用户名命名的文件夹下。然后执行三种语言的查重。并且输出结果。结果以文本显示。</p>
<h3 id="window安装"><a href="#window安装" class="headerlink" title="window安装"></a>window安装</h3><p>我没有尝试文档上，说需要MSDOS+MinGW。<br>另外Makefile的编辑，肯定是先删除unix like配置部分，然后修改BINDIR和MAN1DIR。自行发挥，自求多福。</p>
<h2 id="moss"><a href="#moss" class="headerlink" title="moss"></a>moss</h2><p>还没有看呢，感觉sim就挺好的了。有时间看一下moss。比较一下哪个封装起来更容易。</p>
]]></content>
      
        <categories>
            
            <category> OJ研发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 查重,OJ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[32位和64位系统区别及int字节数]]></title>
      <url>/2017/11/12/32%E4%BD%8D%E5%92%8C64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%88%AB%E5%8F%8Aint%E5%AD%97%E8%8A%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="64位系统和32位有什么区别？"><a href="#64位系统和32位有什么区别？" class="headerlink" title="64位系统和32位有什么区别？"></a>64位系统和32位有什么区别？</h2><p>1、64bit CPU拥有更大的寻址能力，最大支持到16GB内存，而32bit只支持4G内存</p>
<p>2、64位CPU一次可提取64位数据，比32位提高了一倍，理论上性能会提升1倍。但这是建立在64bit操作系统，64bit软件的基础上的。</p>
<a id="more"></a>
<h3 id="什么是64位处理器？"><a href="#什么是64位处理器？" class="headerlink" title="什么是64位处理器？"></a>什么是64位处理器？</h3><p>之所以叫做“64位处理器”，是因为电脑内部都是实行2进制运算，处理器（CPU）一次处理数据的能力也是2的倍数。8位处理器、16位处理器、32位处理器和64位处理器，其计数都是2的倍数。一次处理的数据越大，该电脑处理信息的能力越来越大；因此64位处理在先天就比32位处理器具有快速的能力。那为什么不用更高级的128位处理器呢？因为位数越高，处理器芯片的设计也就越复杂，目前的技术水平暂时无法制造这么复杂的芯片。</p>
<h3 id="64位处理器之失"><a href="#64位处理器之失" class="headerlink" title="64位处理器之失"></a>64位处理器之失</h3><p>※硬件———缺乏驱动程序，很多现有硬件无法使用</p>
<p>※软件———操作系统不是问题，但是软件出现不兼容难题</p>
<h3 id="64位处理器之得"><a href="#64位处理器之得" class="headerlink" title="64位处理器之得"></a>64位处理器之得</h3><p>※硬件———更快的执行速度，更大的内存管理</p>
<p>※软件———最新的尖端软件首先出现在64位平台</p>
<h2 id="数据类型对应字节数"><a href="#数据类型对应字节数" class="headerlink" title="数据类型对应字节数"></a>数据类型对应字节数</h2><h3 id="程序运行平台"><a href="#程序运行平台" class="headerlink" title="程序运行平台"></a>程序运行平台</h3><p>不同的平台上对不同数据类型分配的字节数是不同的。<br>个人对平台的理解是CPU+OS+Compiler，是因为：<br>      1、64位机器也可以装32位系统（x64装XP）；<br>      2、32位机器上可以有16/32位的编译器（XP上有tc是16位的，其他常见的是32位的）；<br>      3、即使是32位的编译器也可以弄出64位的integer来（int64）。<br>      以上这些是基于常见的wintel平台，加上我们可能很少机会接触的其它平台（其它的CPU和OS），所以个人认为所谓平台的概念是三者的组合。<br>      虽然三者的长度可以不一样，但显然相互配合（即长度相等，32位的CPU+32位的OS+32位的Compiler）发挥的能量最大。<br>      理论上来讲 我觉得数据类型的字节数应该是由CPU决定的，但是实际上主要由编译器决定(占多少位由编译器在编译期间说了算)。</p>
<h3 id="常用数据类型对应字节数"><a href="#常用数据类型对应字节数" class="headerlink" title="常用数据类型对应字节数"></a>常用数据类型对应字节数</h3><p>  可用如<code>sizeof（char),sizeof(char*)</code>等得出</p>
<h4 id="32位编译器："><a href="#32位编译器：" class="headerlink" title="32位编译器："></a>32位编译器：</h4><pre><code>  char ：1个字节
  char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
  short int : 2个字节
  int：  4个字节
  unsigned int : 4个字节
  float:  4个字节
  double:   8个字节
  long:   4个字节
  long long:  8个字节
  unsigned long:  4个字节
</code></pre><h4 id="64位编译器："><a href="#64位编译器：" class="headerlink" title="64位编译器："></a>64位编译器：</h4><pre><code>  char ：1个字节
  char*(即指针变量): 8个字节
  short int : 2个字节
  int：  4个字节
  unsigned int : 4个字节
  float:  4个字节
  double:   8个字节
  long:   8个字节
  long long:  8个字节
  unsigned long:  8个字节
</code></pre>]]></content>
      
        <categories>
            
            <category> C </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C,Cpp,面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS学习笔记1入门]]></title>
      <url>/2017/11/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>JS学习笔记1入门篇<br><a id="more"></a><br>document.write();是追加写，不是覆盖写。<br>html是顺序读取的，所以插入到html中的js也是顺序执行的。<br>JS中区分大小写；<br>引用外部js文件<br><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br>定义函数：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function funcname(){
        alert(&quot;hello world!&quot;);
    }
&lt;/script&gt;

//调用

&lt;form&gt;
    &lt;input type=&quot;butten&quot; value=&quot;按钮&quot; submit=&quot;funcname()&quot; /&gt;
&lt;/form&gt;
</code></pre><p>常用命令：</p>
<pre><code>document.write(&quot;向网页中写入内容&quot;);
alert(&quot;弹窗&quot;);
confirm(&quot;确定与否，确定返回真，取消返回假！&quot;);
prompt(str1, str2);//弹窗，显示str1和文本框，文本框中为str2。确定返回文本框中的值，取消返回null。

window.open(&#39;URL&#39;,&#39;窗口名（新建窗口的位置）&#39;,&#39;参数&#39;)
URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
   4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。
</code></pre><p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510450850257.jpg" alt="参数"></p>
<pre><code>window.close();//关闭窗口
object=document.getElementById(&quot;id_num&quot;);//返回html对应DOM对象
Object.innerHTML //用于获取或替换 HTML 元素的内容
Object.style.property=newstyle;
基本属性表（property）:
</code></pre><p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510453299235.jpg" alt="常用属性"></p>
<pre><code>Object.style.display = &quot;value&quot;
value取值
</code></pre><p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510453214953.jpg" alt="value取值"></p>
<pre><code>var object=document.getElementById(&quot;p1&quot;);
object.className = &quot;classname&quot;;//控制类名（className 属性）
</code></pre><p>实例：</p>
<pre><code>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;txttent-Type&quot; txttent=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;title&gt;javascript&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;
body{font-size:12px;}
#txt{
    height:400px;
    width:600px;
    border:#333 solid 1px;
    padding:5px;}
p{
    line-height:18px;
    text-indent:2em;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h2 id=&quot;con&quot;&gt;JavaScript课程&lt;/H2&gt;
  &lt;div id=&quot;txt&quot;&gt; 
     &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt;
        &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt;
        &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt;
        &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt;
  &lt;/div&gt;
  &lt;form&gt;
  &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt;
    &lt;input type=&quot;button&quot; value=&quot;改变颜色&quot; onclick=&quot;set.changeColor()&quot;&gt;  
    &lt;input type=&quot;button&quot; value=&quot;改变宽高&quot; onclick=&quot;set.changeSize()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;隐藏内容&quot; onclick=&quot;set.objHide()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;显示内容&quot; onclick=&quot;set.objShow()&quot;&gt;
    &lt;input type=&quot;button&quot; value=&quot;取消设置&quot; onclick=&quot;set.offSet()&quot;&gt;
  &lt;/form&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
   var txt=document.getElementById(&quot;txt&quot;);
   var set={
    changeColor:function(){
        txt.style.color=&quot;red&quot;;
        txt.style.backgroundColor=&quot;#ccc&quot;;
    },
    changeSize:function(){
        txt.style.width=&quot;300px&quot;;
        txt.style.height=&quot;300px&quot;;
    },
    objHide:function(){
        txt.style.display=&quot;none&quot;;
    },
    objShow:function(){
        txt.style.display=&quot;block&quot;;
    },
    offSet:function(){
        var message=confirm(&quot;你确定要重置所有设置么？&quot;);
        if(message==true){
            txt.removeAttribute(&#39;style&#39;);
        }
    }
  }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js,前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS学习笔记2进阶]]></title>
      <url>/2017/11/12/JS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>JS学习笔记2进阶篇</p>
<a id="more"></a>
<p>注意别吧关键字敲错了。。。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量命名规则："><a href="#变量命名规则：" class="headerlink" title="变量命名规则："></a>变量命名规则：</h3><p>1.必须以字母、下划线或美元符号开头，后面可以跟字母、下划线、美元符号和数字。如下:<br>正确:<code>mysum</code>，<code>_mychar</code>，<code>$numa1</code><br>2.变量名区分大小写，如:A与a是两个不同变量。<br>3.不允许使用JavaScript关键字和保留字做变量名<br><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510456490936.jpg" alt="关键字&amp;保留字"></p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>同C语言：<br>！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符<br><a href="http://www.jb51.net/article/37282.htm" target="_blank" rel="external">优先级参考</a></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>var myarr=new Array();
var myarr=new Array(3);//数组长度为3
var myarr=new Array(3,4);//数组长度为2，第一个元素为3，第二个元素为4
myarr.length  //myarr的长度
myarr.splice(a,b);从myarr[a]开始删除b个元素

字符串类型有split方法，分割字符串。

sort方法，
arr.sort(function(a, b){
    if(a.length &gt; b.length){
        return 1
    }else if(a.length &lt; b.length){
        return -1
    }else{
        return 0
    }
})
//长度短的在前

二维数组定义方式：
var myarr=new Array();  //先声明一维 
for(var i=0;i&lt;2;i++){   //一维长度为2
   myarr[i]=new Array();  //再声明二维 
   for(var j=0;j&lt;3;j++){   //二维长度为3
   myarr[i][j]=i+j;   // 赋值，每个数组元素的值为i+j
   }
 }

 或者：

 var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]//表示的是值
</code></pre><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>if,else:<br><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510471496920.jpg" alt="if else"></p>
<p>switch：</p>
<pre><code>switch(表达式)
{
case值1:
  执行代码块 1
  break;
case值2:
  执行代码块 2
  break;
...
case值n:
  执行代码块 n
  break;
default:
  与 case值1 、 case值2...case值n 不同时执行的代码
}
</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>for循环：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
var num=1;
for (num=1;num&lt;=6;num++)  //初始化值；循环条件；循环后条件值更新
{   document.write(&quot;取出第&quot;+num+&quot;个球&lt;br /&gt;&quot;);
}
&lt;/script&gt;
</code></pre><p>while循环：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
var num=0;  //初始化值
while (num&lt;=6)   //条件判断
{
  document.write(&quot;取出第&quot;+num+&quot;个球&lt;br /&gt;&quot;);
  num=num+1;  //条件值更新
}
&lt;/script&gt;
</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。 网页中的每个元素都可以产生某些可以触发 JavaScript 函数或程序的事件。<br>比如说，当用户单击按钮或者提交表单数据时，就发生一个鼠标单击（onclick）事件，需要浏览器做出处理，返回给用户一个结果。</p>
</blockquote>
<pre><code>&lt;input name=&quot;点击我&quot; type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;openwin()&quot;/&gt;
&lt;input name=&quot;确定&quot; type=&quot;button&quot; value=&quot;确定&quot; onmouseover=&quot;message()&quot;/&gt;
&lt;form onmouseout=&quot;message()&quot;&gt;&lt;a href=&quot;http://www.imooc.com&quot; &gt;点击我&lt;/a&gt;&lt;/form&gt;
onfocus=&quot;message()&quot;
onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。
&lt;input name=&quot;username&quot; type=&quot;text&quot; value=&quot;请输入用户名！&quot; onblur=&quot;message()&quot;&gt;
&lt;textarea name=&quot;summary&quot; cols=&quot;60&quot; rows=&quot;5&quot; onselect=&quot;message()&quot;&gt;请写入个人简介，不少于200字！&lt;/textarea&gt;
&lt;textarea name=&quot;summary&quot; cols=&quot;60&quot; rows=&quot;5&quot; onchange=&quot;message()&quot;&gt;请写入个人简介，不少于200字！&lt;/textarea&gt;
&lt;body onload=&quot;message()&quot;&gt;事件会在页面加载完成后，立即发生，同时执行被调用的程序。
注意：1. 加载页面时，触发onload事件，事件写在&lt;body&gt;标签内。

&lt;script type=&quot;text/javascript&quot;&gt;   
     window.onunload = onunload_message;   
     function onunload_message(){   
        alert(&quot;您确定离开该网页吗？&quot;);   
    }   
&lt;/script&gt;
</code></pre><p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1510481297715.jpg" alt="事件"></p>
<h2 id="javascript内置对象"><a href="#javascript内置对象" class="headerlink" title="javascript内置对象"></a>javascript内置对象</h2><h3 id="Date日期对象"><a href="#Date日期对象" class="headerlink" title="Date日期对象"></a>Date日期对象</h3><h3 id="String字符串对象"><a href="#String字符串对象" class="headerlink" title="String字符串对象"></a>String字符串对象</h3><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><h3 id="Array数组对象"><a href="#Array数组对象" class="headerlink" title="Array数组对象"></a>Array数组对象</h3><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><h3 id="JavaScript计时器"><a href="#JavaScript计时器" class="headerlink" title="JavaScript计时器"></a>JavaScript计时器</h3><h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><h3 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h3><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var b=navigator.appName;
  var b_c=navigator.appCodeName;
  var b_v=navigator.appVersion;
  var p=navigator.platform;
  var ua=navigator.userAgent;
  document.write(&quot;1:&quot;+b+&quot;&lt;br&gt;&quot;);
  document.write(&quot;2:&quot;+b_c+&quot;&lt;br&gt;&quot;);
  document.write(&quot;3:&quot;+b_v+&quot;&lt;br&gt;&quot;);
  document.write(&quot;4:&quot;+p+&quot;&lt;br&gt;&quot;);
  document.write(&quot;5:&quot;+ua+&quot;&lt;br&gt;&quot;);
&lt;/script&gt;
</code></pre><h3 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h3><h2 id="DOM对象，控制HTML元素"><a href="#DOM对象，控制HTML元素" class="headerlink" title="DOM对象，控制HTML元素"></a>DOM对象，控制HTML元素</h2>]]></content>
      
        <categories>
            
            <category> 前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js,前端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[毕业设计]]></title>
      <url>/2017/11/03/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<h2 id="定题"><a href="#定题" class="headerlink" title="定题"></a>定题</h2><blockquote>
<p>面向容器级别的虚拟化存储研究</p>
</blockquote>
<a id="more"></a>
<h2 id="案例研究"><a href="#案例研究" class="headerlink" title="案例研究"></a>案例研究</h2><p>speedy，容器镜像高性能存储解决方案。<br><a href="https://github.com/jcloudpub/speedy" target="_blank" rel="external">https://github.com/jcloudpub/speedy</a><br>田琪：我们通过Docker搭建了我们的弹性计算云平台，服务于公司内外各项业务。在搭建整个平台过程中遇到了很多问题，存储是其中一项待解决的问题。Docker官方提供了Docker Registry服务，但是最终的镜像文件落地存储并没有提供，目前支持的第三方存储服务主要是S3、Swift等。</p>
<p>我们也调研了一些开源分布式存储项目。发现主要存在几个问题：一是架构上倾向于无中心，或者一致性哈希等方式管理存储节点，运维方面我们比较担心可控性问题，另外增减机器都需要涉及文件数据的迁移，不利于线上系统稳定。二是大多开源方案都没有提供高性能的存储引擎，即只提供了数据分布的算法，但数据落地没有提供存储层的优化，这样产生大量文件时就会存在性能问题。三是针对大文件没有特别的优化措施。</p>
<p>认识到这些问题后，我们决定自己研发分布式存储系统，来解决和优化上述的问题。<br><img src="https://mp.weixin.qq.com/s?__biz=MzA4Nzg5Nzc5OA==&amp;mid=205537733&amp;idx=1&amp;sn=454c3ae65e684a8d0058f67bb50b2462&amp;scene=2&amp;from=timeline&amp;isappinstalled=0#rd" alt="京东开源的Docker镜像存储系统"></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>C语言编写的存储引擎高性能，高效率</li>
<li>高可用，存储实例多副本和无状态前后端代理的镜像服务器</li>
<li>高可控，弱化中心主节点，上传和下载不会通过中心主节点</li>
<li>高可扩展性，动态添加存储实例，前后端无状态镜像服务器</li>
<li>大文件被分成小块，从而可以快速并发的上传和下载这些块</li>
<li>仪表盘存储监控系统</li>
<li>仪表盘丰富的操控工具</li>
<li>支持docker 仓库1.0 API</li>
</ol>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="http://p.dearamaze.com/%E5%B0%8F%E4%B9%A6%E5%8C%A0/speedy-arch.png" alt="enter description here" title="speedy-arch"></p>
<h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><h4 id="docker-registry-speedy-driver"><a href="#docker-registry-speedy-driver" class="headerlink" title="docker-registry-speedy-driver"></a>docker-registry-speedy-driver</h4><h4 id="imageserver-镜像服务器"><a href="#imageserver-镜像服务器" class="headerlink" title="imageserver 镜像服务器"></a>imageserver 镜像服务器</h4><h4 id="块服务器主节点"><a href="#块服务器主节点" class="headerlink" title="块服务器主节点"></a>块服务器主节点</h4><h4 id="块服务器"><a href="#块服务器" class="headerlink" title="块服务器"></a>块服务器</h4><p>Docker Registry Driver是一个遵照Docker Registry 1.0协议实现的驱动，完成Docker Registry与后端存储系统的对接工作。<br>ChunkServer与ChunkMaster组成了一个通用的对象存储服务，ChunkMaster是中心节点，缓存了所有ChunkServer的信息，ChunkServer本身是最终镜像数据落地的存储节点，多个ChunkServer会构成一个组，拥有唯一的组ID，上传这个组内的所有ChunkServer都成功才算成功，下载可以随机选择其中一个节点下载。<br>ImageServer本身是一个无状态的Proxy服务，它相当于是后面通用对象存储服务的一个接入层，Driver发起的镜像上传/下载操作会直接发给ImageServer, ImageServer里面缓存了ChunkMaster中的存储节点信息，通过这些信息，ImageServer会进行ChunkServer节点的选择操作，找到一组合适的ChunkServer机器完成镜像的上传或下载操作。</p>
<h4 id="元数据服务器"><a href="#元数据服务器" class="headerlink" title="元数据服务器"></a>元数据服务器</h4><p>他是另外一个分布式的键值存储，尚未开源。你可以利用mysql代替他存储镜像层的元数据信息。</p>
<h3 id="启动顺序"><a href="#启动顺序" class="headerlink" title="启动顺序"></a>启动顺序</h3><p>1.metaserver<br>2.chunkmaster<br>3.chunkserver<br>4.imageserver<br>5.docker-registry</p>
<p>After that you can push and pull docker images.</p>
<h3 id="上传流程："><a href="#上传流程：" class="headerlink" title="上传流程："></a>上传流程：</h3><p>首先我们通过docker push命令发起上传镜像的操作，docker本身会进行多次与后端存储系统的交互，最后一次交互是上传image的layer数据到Docker Registry。</p>
<blockquote>
<p>这里我要简单吐个槽，合理的情况是这个结构化数据和非结构化数据分开存储，docker本身用json表示结构化的描述信息，也是上传到后端存储系统的，个人觉得docker的元数据管理方面很混乱。</p>
</blockquote>
<p>如果使用默认的本地存储，Docker Registry就直接把数据写到了磁盘上，我们这里通过自己实现的Driver完成与后端对象存储系统的上传工作。</p>
<p>我们的Driver首先会对源源不断上传过来的字节流进行切割，按照配置的固定大小并发上传到ImageServer中，并在上传的http请求中携带了该分片的索引及位置信息。</p>
<p>ImageServer在收到该分片上传请求后，根据自己从ChunkMaster中同步过来的chunk信息来动态选择一组ChunkServer，并将分片上传到该组ChunkServer中的所有实例上，都成功才返回成功。并将分片索引位置信息及上传成功返回的文件ID提交给MetaServer保存.</p>
<p>Driver在收到所有分片的上传成功返回后，再返回给前端Docker，整个上传流程结束。</p>
<h3 id="下载流程："><a href="#下载流程：" class="headerlink" title="下载流程："></a>下载流程：</h3><p>首先docker通过docker pull请求下载镜像，同样在真正下载数据开始前，docker同Docker Registry以及后端的存储系统间也会产生多次的数据交互，这里省略，最后一步是下载对应的Image Layer数据。</p>
<p>Docker Registry在收到下载请求后首先通过ImageServer从MetaServer里获取到该文件path对应的分片信息，主要是分片的个数，及每一片的索引，然后将这些分片下载请求并发的发送给ImageServer服务器。</p>
<p>ImageServer收到分片下载请求后，查询MetaServer获得对应的文件ID，该文件ID中包含有ChunkServer的位置信息，随后请求相应ChunkServer下载数据并返回给Driver。</p>
<p>Driver收到分片下载的数据后，会根据分片的位置索引进行排序，按文件分片顺序返回给Docker。</p>
<h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><ol>
<li>metadata组织形式（他是没有开源的）。</li>
<li>另外一个就是driver部分，他目前用的是device-mapper，他也提到overlayfs。<br> a. 我们可以在dm上面做文章，加上我们的重删。<br> b. 利用overlayfs，做driver，这个工作量估计有点大。</li>
</ol>
<p>1、Docker镜像存储技术探秘</p>
<p>我们首先思考一个问题，docker本质上都涉及了哪些方面的技术：</p>
<p>Linux内核系统技术，如：Namespace, Cgroup等；<br>存储技术，如：镜像的存储，镜像的CoW所需的文件系统，如：overlayfs, aufs, dm等；<br>网络技术，如：libnetwork，flannel等开源项目主要来解决容器的网络互通及SDN等问题。<br>我们今天的话题主要集中在存储技术方面，也就是和镜像相关，docker依赖的存储技术方面也是分为两个方面：</p>
<p>单机内核层存储技术，也就是overlayfs, aufs等主要用于提供镜像的CoW机制，解决的是一台物理资源跑多个容器，多个容器之间共享同一个rootfs，然后各自修改是通过CoW完成的，这样解决存储空间等问题。这个话题我已经公开分享过很多次，不再多说了。<br>另一层面，当我们使用Docker过程中，可能会使用到很多不同的镜像，这些镜像本身也是需要存储的，我们需要一个靠可用的可扩展的分布式存储系统。<br>我们今天就详细讨论这两个方面的技术选型，Docker镜像驱动的选择。默认支持的驱动主要有这几个：</p>
<p>Docker<br>btrfs<br>aufs<br>overlayfs<br>device mapper<br>vfs<br>个人认为我们的选择主要是在overlayfs与device mapper之间，btrfs因为目前还没有production ready，生产环境用的公司应该很少，aufs因为没有进入主线内核，且代码庞大书写风格又比较混乱，所以也不是很看好，目前只有少数发行版默认支持这个文件系统。</p>
<p>而vfs则是完全没有解决任何问题，比如一台物理机跑100个容器，则相应的rootfs会独立保存100份，这个完全没法接受，所以最终我们很可能是在overlayfs与device mapper之间进行选择。</p>
<p>ovelayfs简介：</p>
<p>overlayfs本身是一个叠加文件系统，用于叠合多个文件系统形成一个新的文件系统，使用方式如下：</p>
<p>mount -t overlay overlay -olowerdir=/lower, upperdir=/upper, workdir=/work /merged</p>
<p>简单的说overlayfs通过Linux内核VFS层的灵活性能够将对文件A的修改变成对B的修改，利用这种灵活性来完成文件系统叠加的效果。比如指令：</p>
<p>/lower：是下层的文件系统，通常是只读的。可以放我们的镜像模板的rootfs 如果我们要对其中某个文件做修改，比如文件A，则overlayfs会将该文件拷贝到/upper目录中修改，也就是实现了文件级别的CoW。<br>/merged ：是最终叠加后形成的文件系统，也就是用户实际使用看到叠加效果后的文件系统。<br>device-mapper简介：</p>
<p>device-mapper(后面简称dm)本身是一个位于内核通用块层的一个框架，完成内核IO的一些策略定制等功能，比如可以通过dm完成磁盘的软raid功能，比如facebook前些时间开源的flashcache缓存方案也是基于device-mapper的。</p>
<p>DM是一个框架，提供了通用的一套框架完成IO的重定向及定制等策略，它包含很多具体的策略实现，Docker用到的是其中的thin-provision。thin-provision本质上提供两个功能：</p>
<p>磁盘空间按需分配，这个特点决定了如果Docker使用dm驱动，则对应的盘大小默认10G，实际是不占任何空间的，直到你真正写入数据，才会占用实际的磁盘空间。<br>基于block块粒度的CoW，如上面overlayfs原理类似，我要修改一个文件，thin-provision会将修改的部分对应的磁盘块单独拷贝出来一份修改，这里粒度是要小于overlayfs的。<br>dm与overlayfs之间的选择：</p>
<p>从上面原理上分析不难得出一个结论，dm的CoW的粒度是要比overlayfs的小的，也就是说如果用overlayfs做驱动，存在的问题是如果模板rootfs中有个比较大的文件在大多数容器中都可能会动态修改，则这个文件需要整个copyup到上层文件系统，而用dm则只需要CoW修改的那个块。</p>
<p>从这方面讲dm是占优的，但是dm在使用中存在很多功能限制，因为它本身是一个块设备，所以并不了解上层文件系统的细节，使用中存在种种限制，并且在文件系统缓存这层也没有overlayfs有效。但是overlayfs需要3.18以上kernel才支持。大多数Linux发行版还不支持这么高的内核版本，所以需要单独编译。</p>
<p>综合考虑，个人认为当前用dm是可以接受的选择，未来可能会切换到overlayfs上。</p>
]]></content>
      
        <categories>
            
            <category> 存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 容器,计划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据可视化echarts]]></title>
      <url>/2017/10/25/python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96bokeh/</url>
      <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><blockquote>
<p>展示数据</p>
</blockquote>
<p>就是向人家写好的框架里面填充数据。调参侠！</p>
<a id="more"></a>
<h2 id="常用图形"><a href="#常用图形" class="headerlink" title="常用图形"></a>常用图形</h2><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h2 id="前后端代码模板"><a href="#前后端代码模板" class="headerlink" title="前后端代码模板"></a>前后端代码模板</h2>]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python,数据分析 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python time datetime学习]]></title>
      <url>/2017/10/25/python%20time%20datetime%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python,时间处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mongodb 学习笔记]]></title>
      <url>/2017/10/23/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="mongodb简介"><a href="#mongodb简介" class="headerlink" title="mongodb简介"></a>mongodb简介</h2><a id="more"></a>
<h2 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a>mongodb安装</h2><h2 id="mongodb常用命令"><a href="#mongodb常用命令" class="headerlink" title="mongodb常用命令"></a>mongodb常用命令</h2><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><p><code>show dbs</code></p>
<h3 id="显示该数据库下所有集合（表）"><a href="#显示该数据库下所有集合（表）" class="headerlink" title="显示该数据库下所有集合（表）"></a>显示该数据库下所有集合（表）</h3><p><code>show collections</code><br>或者<br><code>show tables</code></p>
<h3 id="显示集合中所有数据（查询）"><a href="#显示集合中所有数据（查询）" class="headerlink" title="显示集合中所有数据（查询）"></a>显示集合中所有数据（查询）</h3><pre><code># 输出
&gt; db.col.find()
{ &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;by&quot; : &quot;NB教程&quot; }
{ &quot;_id&quot; : ObjectId(&quot;59edafca4995c58db2af8d2e&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;NB教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100 }

# 格式化输出
&gt; db.col.find().pretty()
{
    &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;by&quot; : &quot;NB教程&quot;
}
{
    &quot;_id&quot; : ObjectId(&quot;59edafca4995c58db2af8d2e&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,
    &quot;by&quot; : &quot;NB教程&quot;,
    &quot;url&quot; : &quot;http://www.runoob.com&quot;,
    &quot;tags&quot; : [
        &quot;mongodb&quot;,
        &quot;database&quot;,
        &quot;NoSQL&quot;
    ],
    &quot;likes&quot; : 100
}
</code></pre><table class="reference"><br>    <thead><br>    <tr><br>    <th>操作</th><br>    <th>格式</th><br>    <th>范例</th><br>    <th>RDBMS中的类似语句</th><br>    </tr><br>    </thead><br>    <tbody><br>    <tr><br>    <td>等于</td><br>    <td><code>{&lt;key&gt;:&lt;value&gt;</code>}</td><br>    <td><code>db.col.find({“by”:”菜鸟教程”}).pretty()</code></td><br>    <td><code>where by = ‘菜鸟教程’</code></td><br>    </tr><br>    <tr><br>    <td>小于</td><br>    <td><code>{&lt;key&gt;:{$lt:&lt;value&gt;}}</code></td><br>    <td><code>db.col.find({“likes”:{$lt:50}}).pretty()</code></td><br>    <td><code>where likes &lt; 50</code></td><br>    </tr><br>    <tr><br>    <td>小于或等于</td><br>    <td><code>{&lt;key&gt;:{$lte:&lt;value&gt;}}</code></td><br>    <td><code>db.col.find({“likes”:{$lte:50}}).pretty()</code></td><br>    <td><code>where likes &lt;= 50</code></td><br>    </tr><br>    <tr><br>    <td>大于</td><br>    <td><code>{&lt;key&gt;:{$gt:&lt;value&gt;}}</code></td><br>    <td><code>db.col.find({“likes”:{$gt:50}}).pretty()</code></td><br>    <td><code>where likes &gt; 50</code></td><br>    </tr><br>    <tr><br>    <td>大于或等于</td><br>    <td><code>{&lt;key&gt;:{$gte:&lt;value&gt;}}</code></td><br>    <td><code>db.col.find({“likes”:{$gte:50}}).pretty()</code></td><br>    <td><code>where likes &gt;= 50</code></td><br>    </tr><br>    <tr><br>    <td>不等于</td><br>    <td><code>{&lt;key&gt;:{$ne:&lt;value&gt;}}</code></td><br>    <td><code>db.col.find({“likes”:{$ne:50}}).pretty()</code></td><br>    <td><code>where likes != 50</code></td><br>    </tr><br>    </tbody><br></table>

<h4 id="AND-和-OR-联合使用"><a href="#AND-和-OR-联合使用" class="headerlink" title="AND 和 OR 联合使用"></a>AND 和 OR 联合使用</h4><pre><code>以下实例演示了 AND 和 OR 联合使用，类似常规 SQL 语句为： &#39;where likes&gt;50 AND (by = &#39;菜鸟教程&#39; OR title = &#39;MongoDB 教程&#39;)&#39;

&gt;db.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()
{
        &quot;_id&quot; : ObjectId(&quot;56063f17ade2f21f36b03133&quot;),
        &quot;title&quot; : &quot;MongoDB 教程&quot;,
        &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,
        &quot;by&quot; : &quot;菜鸟教程&quot;,
        &quot;url&quot; : &quot;http://www.runoob.com&quot;,
        &quot;tags&quot; : [
                &quot;mongodb&quot;,
                &quot;database&quot;,
                &quot;NoSQL&quot;
        ],
        &quot;likes&quot; : 100
}
</code></pre><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>使用用户名和密码连接登陆到指定数据库，格式如下：<br><code>mongodb://admin:123456@localhost/test</code></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>use dbname</code><br>如果数据库存在，则切换到dbname，如果不存在，则创建。<br>刚创建完成后，使用<code>show dbs</code>命令，看不到dbname，必须向dbname中添加数据后才能显示。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>&gt; show dbs 
admin  0.000GB
fdl    0.000GB
local  0.000GB
test   0.000GB
&gt; use fdl
switched to db fdl
&gt; db.dropDatabase()
2017-10-23T16:54:13.853+0800 I COMMAND  [conn1] dropDatabase fdl starting
2017-10-23T16:54:13.857+0800 I COMMAND  [conn1] dropDatabase fdl finished
{ &quot;dropped&quot; : &quot;fdl&quot;, &quot;ok&quot; : 1 }
&gt; show dbs
admin  0.000GB
local  0.000GB
test   0.000GB
</code></pre><h3 id="向collection添加数据"><a href="#向collection添加数据" class="headerlink" title="向collection添加数据"></a>向collection添加数据</h3><p><code>db.collectionname.insert({&quot;name&quot;:&quot;fandeliang&quot;})</code></p>
<pre><code class="shell?linenums">#  插入单条数据

&gt; var document = db.collection.insertOne({&quot;a&quot;: 3})
&gt; document
{
        &quot;acknowledged&quot; : true,
        &quot;insertedId&quot; : ObjectId(&quot;571a218011a82a1d94c02333&quot;)
}

#  插入多条数据
&gt; var res = db.collection.insertMany([{&quot;b&quot;: 3}, {&#39;c&#39;: 4}])
&gt; res
{
        &quot;acknowledged&quot; : true,
        &quot;insertedIds&quot; : [
                ObjectId(&quot;571a22a911a82a1d94c02337&quot;),
                ObjectId(&quot;571a22a911a82a1d94c02338&quot;)
        ]
}
</code></pre>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>注意加不加<code>$set:</code>的区别。</p>
<pre><code>&gt; use test
switched to db test
&gt; db.col.insert({
...     title: &#39;MongoDB 教程&#39;, 
...     description: &#39;MongoDB 是一个 Nosql 数据库&#39;,
...     by: &#39;菜鸟教程&#39;,
...     url: &#39;http://www.runoob.com&#39;,
...     tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],
...     likes: 100
... })
WriteResult({ &quot;nInserted&quot; : 1 })
&gt; show tables;
col
runoob
&gt; db.col.find()
{ &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;database&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 100 }
&gt; db.col.update({&quot;title&quot;:&quot;MongoDB 教程&quot;},{&quot;title&quot;:&quot;MongoDB&quot;,&quot;by&quot;:&quot;NB教程&quot;})
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
&gt; db.col.find()
{ &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;by&quot; : &quot;NB教程&quot; }
&gt; db.col.find().pretty()
{
    &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;by&quot; : &quot;NB教程&quot;
}
&gt; db.col.insert({
...     title: &#39;MongoDB 教程&#39;, 
...     description: &#39;MongoDB 是一个 Nosql 数据库&#39;,
...     by: &#39;菜鸟教程&#39;,
...     url: &#39;http://www.runoob.com&#39;,
...     tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;],
...     likes: 100
... })
WriteResult({ &quot;nInserted&quot; : 1 })
&gt; db.col.update({&quot;title&quot;:&quot;MongoDB 教程&quot;},{$set:{&quot;title&quot;:&quot;MongoDB&quot;,&quot;by&quot;:&quot;NB教程&quot;}})
WriteResult({ &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 })
&gt; db.col.find().pretty()
{
    &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;by&quot; : &quot;NB教程&quot;
}
{
    &quot;_id&quot; : ObjectId(&quot;59edafca4995c58db2af8d2e&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,
    &quot;by&quot; : &quot;NB教程&quot;,
    &quot;url&quot; : &quot;http://www.runoob.com&quot;,
    &quot;tags&quot; : [
        &quot;mongodb&quot;,
        &quot;database&quot;,
        &quot;NoSQL&quot;
    ],
    &quot;likes&quot; : 100
}

更多实例
只更新第一条记录：
db.col.update( { &quot;count&quot; : { $gt : 1 } } , { $set : { &quot;test2&quot; : &quot;OK&quot;} } );
全部更新：
db.col.update( { &quot;count&quot; : { $gt : 3 } } , { $set : { &quot;test2&quot; : &quot;OK&quot;} },false,true );
只添加第一条：
db.col.update( { &quot;count&quot; : { $gt : 4 } } , { $set : { &quot;test5&quot; : &quot;OK&quot;} },true,false );
全部添加加进去:
db.col.update( { &quot;count&quot; : { $gt : 5 } } , { $set : { &quot;test5&quot; : &quot;OK&quot;} },true,true );
全部更新：
db.col.update( { &quot;count&quot; : { $gt : 15 } } , { $inc : { &quot;count&quot; : 1} },false,true );
只更新第一条记录：
db.col.update( { &quot;count&quot; : { $gt : 10 } } , { $inc : { &quot;count&quot; : 1} },false,false );
</code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code>&gt; db.col.find().pretty()
{
    &quot;_id&quot; : ObjectId(&quot;59edaea04995c58db2af8d2d&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;by&quot; : &quot;NB教程&quot;
}
{
    &quot;_id&quot; : ObjectId(&quot;59edafca4995c58db2af8d2e&quot;),
    &quot;title&quot; : &quot;MongoDB&quot;,
    &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,
    &quot;by&quot; : &quot;NB教程&quot;,
    &quot;url&quot; : &quot;http://www.runoob.com&quot;,
    &quot;tags&quot; : [
        &quot;mongodb&quot;,
        &quot;database&quot;,
        &quot;NoSQL&quot;
    ],
    &quot;likes&quot; : 100
}
&gt; db.col.remove({&#39;title&#39;:&quot;MongoDB&quot;})
WriteResult({ &quot;nRemoved&quot; : 2 })
&gt; db.col.find().pretty()
&gt; 
db.collection.remove(
   &lt;query&gt;,
   {
     justOne: &lt;boolean&gt;,
     writeConcern: &lt;document&gt;
   }
)
参数说明：
query :（可选）删除的文档的条件。
justOne : （可选）如果设为 true 或 1，则只删除一个文档。
writeConcern :（可选）抛出异常的级别。

如果你想删除所有数据，可以使用以下方式（类似常规 SQL 的 truncate 命令）：
&gt;db.col.remove({})
&gt;db.col.find()
&gt;
</code></pre><h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a>$type 操作符</h3><blockquote>
<p>MongoDB 中可以使用的类型如下表所示：<br>类型    数字    备注<br>Double    1<br>String    2<br>Object    3<br>Array    4<br>Binary data    5<br>Undefined    6    已废弃。<br>Object id    7<br>Boolean    8<br>Date    9<br>Null    10<br>Regular Expression    11<br>JavaScript    13<br>Symbol    14<br>JavaScript (with scope)    15<br>32-bit integer    16<br>Timestamp    17<br>64-bit integer    18<br>Min key    255    Query with -1.<br>Max key    127     </p>
</blockquote>
<pre><code>如果想获取 &quot;col&quot; 集合中 title 为 String 的数据，你可以使用以下命令：

db.col.find({&quot;title&quot; : {$type : 2}})

输出结果为：
{ &quot;_id&quot; : ObjectId(&quot;56066542ade2f21f36b0313a&quot;), &quot;title&quot; : &quot;PHP 教程&quot;, &quot;description&quot; : &quot;PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;php&quot; ], &quot;likes&quot; : 200 }
{ &quot;_id&quot; : ObjectId(&quot;56066549ade2f21f36b0313b&quot;), &quot;title&quot; : &quot;Java 教程&quot;, &quot;description&quot; : &quot;Java 是由Sun Microsystems公司于1995年5月推出的高级程序设计语言。&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;java&quot; ], &quot;likes&quot; : 150 }
{ &quot;_id&quot; : ObjectId(&quot;5606654fade2f21f36b0313c&quot;), &quot;title&quot; : &quot;MongoDB 教程&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot; ], &quot;likes&quot; : 100 }
</code></pre><h3 id="Limit-Skip-和sort-方法"><a href="#Limit-Skip-和sort-方法" class="headerlink" title="Limit , Skip 和sort()方法"></a>Limit , Skip 和sort()方法</h3><blockquote>
<p>如果你需要在MongoDB中读取指定数量的数据记录，可以使用MongoDB的Limit方法，limit()方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数。<br>我们除了可以使用limit()方法来读取指定数量的数据外，还可以使用skip()方法来跳过指定数量的数据，skip方法同样接受一个数字参数作为跳过的记录条数。<br>在MongoDB中使用使用sort()方法对数据进行排序，sort()方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而-1是用于降序排列。<br>当查询时同时使用sort,skip,limit，无论位置先后，最先执行顺序 sort再skip再limit。</p>
</blockquote>
<pre><code>想要读取从 10 条记录后 100 条记录，相当于 sql 中limit (10,100)。
&gt; db.COLLECTION_NAME.find().skip(10).limit(100)
以上实例在集合中跳过前面 10 条返回 100 条数据。
skip 和 limit 结合就能实现分页。

db.col.find({},{&quot;title&quot;:1,_id:0}).limit(2)
补充说明：
第一个 {} 放 where 条件，为空表示返回集合中所有文档。
第二个 {} 指定那些列显示和不显示 （0表示不显示 1表示显示)。

&gt;db.col.find({},{&quot;title&quot;:1,_id:0}).sort({&quot;likes&quot;:-1})
{ &quot;title&quot; : &quot;PHP 教程&quot; }
{ &quot;title&quot; : &quot;Java 教程&quot; }
{ &quot;title&quot; : &quot;MongoDB 教程&quot; }
&gt;
</code></pre><p>### </p>
]]></content>
      
        <categories>
            
            <category> 学习笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mongodb,数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux镜像源整理]]></title>
      <url>/2017/09/30/Linux%E9%95%9C%E5%83%8F%E6%BA%90%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><a href="http://mirrors.ustc.edu.cn/help/" target="_blank" rel="external">各种Linux发行版源配置</a><br><a href="http://blog.csdn.net/bleachswh/article/details/51423585" target="_blank" rel="external">Linux国内常用源的介绍和使用</a><br><a href="http://blog.csdn.net/u013005025/article/details/60777128" target="_blank" rel="external">Linux镜像源 国内列表</a></p>
<a id="more"></a>
<p><a href="http://wiki.ubuntu.org.cn/%E6%BA%90%E5%88%97%E8%A1%A8" target="_blank" rel="external">Ubuntu源配置</a></p>
<h2 id="站点版"><a href="#站点版" class="headerlink" title="站点版"></a>站点版</h2><h3 id="企业站"><a href="#企业站" class="headerlink" title="企业站"></a>企业站</h3><p>1.搜狐：<a href="http://mirrors.sohu.com/" target="_blank" rel="external">http://mirrors.sohu.com/</a><br>2.网易：<a href="http://mirrors.163.com/" target="_blank" rel="external">http://mirrors.163.com/</a><br>3.阿里云：<a href="http://mirrors.aliyun.com/" target="_blank" rel="external">http://mirrors.aliyun.com/</a><br>4.腾讯：<a href="http://android-mirror.bugly.qq.com:8080/（仅针对APP开发的软件，限流，不推荐）" target="_blank" rel="external">http://android-mirror.bugly.qq.com:8080/（仅针对APP开发的软件，限流，不推荐）</a></p>
<h3 id="教育站"><a href="#教育站" class="headerlink" title="教育站"></a>教育站</h3><p>1.上海交通大学：<a href="http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问）" target="_blank" rel="external">http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问）</a><br>2.华中科技大学：<a href="http://mirror.hust.edu.cn/（当前已用容量估计：4.83T）" target="_blank" rel="external">http://mirror.hust.edu.cn/（当前已用容量估计：4.83T）</a><br>3.清华大学：<a href="http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T）" target="_blank" rel="external">http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T）</a><br>4.北京理工大学：<a href="http://mirror.bit.edu.cn/web/" target="_blank" rel="external">http://mirror.bit.edu.cn/web/</a><br>5.兰州大学：<a href="http://mirror.lzu.edu.cn/" target="_blank" rel="external">http://mirror.lzu.edu.cn/</a><br>6.中国科技大学：<a href="http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T）" target="_blank" rel="external">http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T）</a><br>7.大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T）" target="_blank" rel="external">http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T）</a><br>8.东北大学：<a href="http://mirror.neu.edu.cn/" target="_blank" rel="external">http://mirror.neu.edu.cn/</a><br>9.大连理工大学：<a href="http://mirror.dlut.edu.cn/" target="_blank" rel="external">http://mirror.dlut.edu.cn/</a><br>10.哈尔滨工业大学：<a href="http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问）" target="_blank" rel="external">http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问）</a><br>11.北京交通大学：<a href="http://mirror.bjtu.edu.cn/cn/" target="_blank" rel="external">http://mirror.bjtu.edu.cn/cn/</a><br>12.天津大学：<a href="http://mirror.tju.edu.cn（无法访问，ping超时）" target="_blank" rel="external">http://mirror.tju.edu.cn（无法访问，ping超时）</a><br>13.中国地质大学：<a href="http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T）" target="_blank" rel="external">http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T）</a><br>14.浙江大学：<a href="http://mirrors.zju.edu.cn/" target="_blank" rel="external">http://mirrors.zju.edu.cn/</a><br>15.厦门大学：<a href="http://mirrors.xmu.edu.cn/" target="_blank" rel="external">http://mirrors.xmu.edu.cn/</a><br>16.中山大学：<a href="http://mirror.sysu.edu.cn/" target="_blank" rel="external">http://mirror.sysu.edu.cn/</a><br>17.重庆大学：<a href="http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T）" target="_blank" rel="external">http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T）</a><br>18.北京化工大学：<a href="http://ubuntu.buct.edu.cn/（Android" target="_blank" rel="external">http://ubuntu.buct.edu.cn/（Android</a> SDK镜像仅供校内使用，当前已用容量估计：1.72T）<br>19.南阳理工学院：<a href="http://mirror.nyist.edu.cn/" target="_blank" rel="external">http://mirror.nyist.edu.cn/</a><br>20.中国科学院：<a href="http://www.opencas.org/mirrors/" target="_blank" rel="external">http://www.opencas.org/mirrors/</a><br>21.电子科技大学：<a href="http://ubuntu.uestc.edu.cn/（无法访问，ping超时）" target="_blank" rel="external">http://ubuntu.uestc.edu.cn/（无法访问，ping超时）</a><br>22.电子科技大学星辰工作室：<a href="http://mirrors.stuhome.net/（当前已用容量估计：1.08T）" target="_blank" rel="external">http://mirrors.stuhome.net/（当前已用容量估计：1.08T）</a><br>23.西北农林科技大学：<a href="http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB）" target="_blank" rel="external">http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB）</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.首都在线科技股份有限公司（英文名Capital Online Data Service）：<a href="http://mirrors.yun-idc.com/" target="_blank" rel="external">http://mirrors.yun-idc.com/</a><br>2.中国电信天翼云：<a href="http://mirrors.ctyun.cn/" target="_blank" rel="external">http://mirrors.ctyun.cn/</a><br>3.noc.im：<a href="http://mirrors.noc.im/（当前已用容量估计：3.74T）" target="_blank" rel="external">http://mirrors.noc.im/（当前已用容量估计：3.74T）</a><br>4.常州贝特康姆软件技术有限公司：<a href="http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB）" target="_blank" rel="external">http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB）</a><br>5.公云PubYun（母公司为贝特康姆）：<a href="http://mirrors.pubyun.com/" target="_blank" rel="external">http://mirrors.pubyun.com/</a><br>6.Linux运维派：<a href="http://mirrors.skyshe.cn/（使用阿里云服务器，界面使用浙江大学的模板，首页维护，内容可访问）" target="_blank" rel="external">http://mirrors.skyshe.cn/（使用阿里云服务器，界面使用浙江大学的模板，首页维护，内容可访问）</a><br>7.中国互联网络信息中心：<a href="http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB）" target="_blank" rel="external">http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB）</a><br>8.Fayea工作室：<a href="http://apache.fayea.com/（只做Apache镜像，当前已用容量估计：120GB）" target="_blank" rel="external">http://apache.fayea.com/（只做Apache镜像，当前已用容量估计：120GB）</a></p>
<h2 id="软件版"><a href="#软件版" class="headerlink" title="软件版"></a>软件版</h2><h3 id="操作系统类"><a href="#操作系统类" class="headerlink" title="操作系统类"></a>操作系统类</h3><p>1.Ubuntu<br>阿里云：<a href="http://mirrors.aliyun.com/ubuntu-releases/" target="_blank" rel="external">http://mirrors.aliyun.com/ubuntu-releases/</a><br>网易：<a href="http://mirrors.163.com/ubuntu-releases/" target="_blank" rel="external">http://mirrors.163.com/ubuntu-releases/</a><br>搜狐：<a href="http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了）" target="_blank" rel="external">http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了）</a><br>首都在线科技股份有限公司：<a href="http://mirrors.yun-idc.com/ubuntu-releases/" target="_blank" rel="external">http://mirrors.yun-idc.com/ubuntu-releases/</a></p>
<p>2.centos<br>网易：<a href="http://mirrors.163.com/centos/" target="_blank" rel="external">http://mirrors.163.com/centos/</a><br>搜狐：<a href="http://mirrors.sohu.com/centos/" target="_blank" rel="external">http://mirrors.sohu.com/centos/</a><br>阿里云：<a href="http://mirrors.aliyun.com/centos/" target="_blank" rel="external">http://mirrors.aliyun.com/centos/</a></p>
<h3 id="服务器类"><a href="#服务器类" class="headerlink" title="服务器类"></a>服务器类</h3><p>1.tomcat、Apache<br>中国互联网络信息中心：<a href="http://mirrors.cnnic.cn/apache/" target="_blank" rel="external">http://mirrors.cnnic.cn/apache/</a><br>华中科技大学：<a href="http://mirrors.hust.edu.cn/apache/" target="_blank" rel="external">http://mirrors.hust.edu.cn/apache/</a><br>北京理工大学：<a href="http://mirror.bit.edu.cn/apache/" target="_blank" rel="external">http://mirror.bit.edu.cn/apache/</a></p>
<p>2.MySQL<br>北京理工大学：<a href="http://mirror.bit.edu.cn/mysql/Downloads/" target="_blank" rel="external">http://mirror.bit.edu.cn/mysql/Downloads/</a><br>中国电信天翼云：<a href="http://mirrors.ctyun.cn/Mysql/" target="_blank" rel="external">http://mirrors.ctyun.cn/Mysql/</a></p>
<p>3.PostgreSQL<br>浙江大学：<a href="http://mirrors.zju.edu.cn/postgresql/" target="_blank" rel="external">http://mirrors.zju.edu.cn/postgresql/</a></p>
<p>4.MariaDB<br>中国电信天翼云：<a href="http://mirrors.ctyun.cn/MariaDB/" target="_blank" rel="external">http://mirrors.ctyun.cn/MariaDB/</a></p>
<p>5.VideoLAN<br>大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/videolan/" target="_blank" rel="external">http://mirrors.neusoft.edu.cn/videolan/</a><br>中国科技大学：<a href="http://mirrors.ustc.edu.cn/videolan-ftp/" target="_blank" rel="external">http://mirrors.ustc.edu.cn/videolan-ftp/</a></p>
<h3 id="开发工具类"><a href="#开发工具类" class="headerlink" title="开发工具类"></a>开发工具类</h3><p>1.eclipse<br>中国科技大学：<a href="http://mirrors.ustc.edu.cn/eclipse/" target="_blank" rel="external">http://mirrors.ustc.edu.cn/eclipse/</a><br>中国科学院：<a href="http://mirrors.opencas.cn/eclipse/" target="_blank" rel="external">http://mirrors.opencas.cn/eclipse/</a><br>东北大学：<a href="http://ftp.neu.edu.cn/mirrors/eclipse/，http://mirror.neu.edu.cn/eclipse/" target="_blank" rel="external">http://ftp.neu.edu.cn/mirrors/eclipse/，http://mirror.neu.edu.cn/eclipse/</a></p>
<p>2.安卓SDK<br>中国科学院：<a href="http://mirrors.opencas.ac.cn/android/repository/" target="_blank" rel="external">http://mirrors.opencas.ac.cn/android/repository/</a><br>南洋理工学院：<a href="http://mirror.nyist.edu.cn/android/repository/" target="_blank" rel="external">http://mirror.nyist.edu.cn/android/repository/</a><br>中国科学院：<a href="http://mirrors.opencas.cn/android/repository/" target="_blank" rel="external">http://mirrors.opencas.cn/android/repository/</a><br>腾讯：<a href="http://android-mirror.bugly.qq.com:8080/android/repository/（限流，不推荐）" target="_blank" rel="external">http://android-mirror.bugly.qq.com:8080/android/repository/（限流，不推荐）</a><br>大连东软信息学院：<a href="http://mirrors.neusoft.edu.cn/android/repository/（同步效果不如中科院的镜像，不推荐）" target="_blank" rel="external">http://mirrors.neusoft.edu.cn/android/repository/（同步效果不如中科院的镜像，不推荐）</a></p>
<p>3.Xcode<br>腾讯：<a href="http://android-mirror.bugly.qq.com:8080/Xcode/（从7.2之后不再更新，建议直接从官网下载）" target="_blank" rel="external">http://android-mirror.bugly.qq.com:8080/Xcode/（从7.2之后不再更新，建议直接从官网下载）</a></p>
<h2 id="官方镜像列表状态地址"><a href="#官方镜像列表状态地址" class="headerlink" title="官方镜像列表状态地址"></a>官方镜像列表状态地址</h2><p>CentOS：<a href="http://mirror-status.centos.org/#cn" target="_blank" rel="external">http://mirror-status.centos.org/#cn</a><br>Archlinux：<a href="https://www.archlinux.org/mirrors/status/" target="_blank" rel="external">https://www.archlinux.org/mirrors/status/</a><br>Ubuntu：<a href="https://launchpad.net/ubuntu/+cdmirrors" target="_blank" rel="external">https://launchpad.net/ubuntu/+cdmirrors</a><br>Debian：<a href="http://mirror.debian.org/status.html" target="_blank" rel="external">http://mirror.debian.org/status.html</a><br>Fedora Linux/Fedora EPEL：<a href="https://admin.fedoraproject.org/mirrormanager/mirrors" target="_blank" rel="external">https://admin.fedoraproject.org/mirrormanager/mirrors</a><br>Apache：<a href="http://www.apache.org/mirrors/#cn" target="_blank" rel="external">http://www.apache.org/mirrors/#cn</a><br>Cygwin：<a href="https://www.cygwin.com/mirrors.html" target="_blank" rel="external">https://www.cygwin.com/mirrors.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux,运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tcpdump 学习笔记]]></title>
      <url>/2017/09/29/tcpdump%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
</blockquote>
<h3 id="Linux-抓包原理"><a href="#Linux-抓包原理" class="headerlink" title="Linux 抓包原理"></a>Linux 抓包原理</h3><blockquote>
<p>Linux抓包是通过注册一种虚拟的底层网络协议来完成对网络报文(准确的说是网络设备)消息的处理权。当网卡接收到一个网络报文之后，它会遍历系统中所有已经注册的网络协议，例如以太网协议、x25协议处理模块来尝试进行报文的解析处理，这一点和一些文件系统的挂载相似，就是让系统中所有的已经注册的文件系统来进行尝试挂载，如果哪一个认为自己可以处理，那么就完成挂载。</p>
<p>当抓包模块把自己伪装成一个网络协议的时候，系统在收到报文的时候就会给这个伪协议一次机会，让它来对网卡收到的报文进行一次处理，此时该模块就会趁机对报文进行窥探，也就是把这个报文完完整整的复制一份，假装是自己接收到的报文，汇报给抓包模块。</p>
</blockquote>
<a id="more"></a>
<h3 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h3><p>Wireshark是一个网络协议检测工具，支持Windows平台、Unix平台、Mac平台，一般只在图形界面平台下使用Wireshark，如果是Linux的话，直接使用tcpdump了，因为一般而言Linux都自带的tcpdump，或者用tcpdump抓包以后用Wireshark打开分析。</p>
<p>在Mac平台下，Wireshark通过WinPcap进行抓包，封装的很好，使用起来很方便，可以很容易的制定抓包过滤器或者显示过滤器，具体简单使用下面会介绍。Wireshark是一个免费的工具，只要google一下就能很容易找到下载的地方。</p>
<p>所以，tcpdump是用来抓取数据非常方便，Wireshark则是用于分析抓取到的数据比较方便。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>tcpdump [ -AdDefIKlLnNOpqRStuUvxX ] [ -B buffer_size ] [ -c count ]
    [ -C file_size ] [ -G rotate_seconds ] [ -F file ]
    [ -i interface ] [ -m module ] [ -M secret ]
    [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]
    [ -W filecount ]
    [ -E spi@ipaddr algo:secret,...  ]
    [ -y datalinktype ] [ -z postrotate-command ] [ -Z user ]
    [ expression ]
</code></pre><h4 id="类型关键字"><a href="#类型关键字" class="headerlink" title="类型关键字"></a>类型关键字</h4><blockquote>
<p>host(缺省类型): 指明一台主机，如：host 210.27.48.<br>net: 指明一个网络地址，如：net 202.0.0.0<br>port: 指明端口号，如：port 23</p>
</blockquote>
<h4 id="确定方向关键字"><a href="#确定方向关键字" class="headerlink" title="确定方向关键字"></a>确定方向关键字</h4><blockquote>
<p>src: src 210.27.48.2, IP包源地址是210.27.48.2<br>dst: dst net 202.0.0.0, 目标网络地址是202.0.0.0<br>dst or src(缺省值)<br>dst and src</p>
</blockquote>
<h4 id="协议的关键字：缺省值是监听所有协议的信息包"><a href="#协议的关键字：缺省值是监听所有协议的信息包" class="headerlink" title="协议的关键字：缺省值是监听所有协议的信息包"></a>协议的关键字：缺省值是监听所有协议的信息包</h4><blockquote>
<p>fddi<br>ip<br>arp<br>rarp<br>tcp<br>udp</p>
</blockquote>
<h4 id="其他关键字"><a href="#其他关键字" class="headerlink" title="其他关键字"></a>其他关键字</h4><blockquote>
<p>gateway<br>broadcast<br>less<br>greater</p>
</blockquote>
<h4 id="常用表达式：多条件时可以用括号，但是得用-转义"><a href="#常用表达式：多条件时可以用括号，但是得用-转义" class="headerlink" title="常用表达式：多条件时可以用括号，但是得用\转义"></a>常用表达式：多条件时可以用括号，但是得用\转义</h4><blockquote>
<p>非：! or “not” (去掉双引号)<br>且：&amp;&amp; or “and”<br>或：|| or “or”</p>
</blockquote>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code>-A：以ASCII编码打印每个报文（不包括链路层的头），这对分析网页来说很方便；
-a：将网络地址和广播地址转变成名字； 
-c&lt;数据包数目&gt;：在收到指定的包的数目后，tcpdump就会停止；
-C：用于判断用 -w 选项将报文写入的文件的大小是否超过这个值，如果超过了就新建文件（文件名后缀是1、2、3依次增加）；
-d：将匹配信息包的代码以人们能够理解的汇编格式给出； 
-dd：将匹配信息包的代码以c语言程序段的格式给出； 
-ddd：将匹配信息包的代码以十进制的形式给出；
-D：列出当前主机的所有网卡编号和名称，可以用于选项 -i；
-e：在输出行打印出数据链路层的头部信息； 
-f：将外部的Internet地址以数字的形式打印出来； 
-F&lt;表达文件&gt;：从指定的文件中读取表达式,忽略其它的表达式； 
-i&lt;网络界面&gt;：监听主机的该网卡上的数据流，如果没有指定，就会使用最小网卡编号的网卡（在选项-D可知道，但是不包括环路接口），linux 2.2 内核及之后的版本支持 any 网卡，用于指代任意网卡； 
-l：如果没有使用 -w 选项，就可以将报文打印到 标准输出终端（此时这是默认）； 
-n：显示ip，而不是主机名； 
-N：不列出域名； 
-O：不将数据包编码最佳化； 
-p：不让网络界面进入混杂模式； 
-q：快速输出，仅列出少数的传输协议信息； 
-r&lt;数据包文件&gt;：从指定的文件中读取包(这些包一般通过-w选项产生)； 
-s&lt;数据包大小&gt;：指定抓包显示一行的宽度，-s0表示可按包长显示完整的包，经常和-A一起用，默认截取长度为60个字节，但一般ethernet MTU都是1500字节。所以，要抓取大于60字节的包时，使用默认参数就会导致包数据丢失； 
-S：用绝对而非相对数值列出TCP关联数； 
-t：在输出的每一行不打印时间戳； 
-tt：在输出的每一行显示未经格式化的时间戳记； 
-T&lt;数据包类型&gt;：将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议）； 
-v：输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息； 
-vv：输出详细的报文信息； 
-x/-xx/-X/-XX：以十六进制显示包内容，几个选项只有细微的差别，详见man手册； 
-w&lt;数据包文件&gt;：直接将包写入文件中，并不分析和打印出来；
expression：用于筛选的逻辑表达式；
</code></pre><h3 id="命令实践"><a href="#命令实践" class="headerlink" title="命令实践"></a>命令实践</h3><ol>
<li><p>直接启动tcpdump，将抓取所有经过第一个网络接口上的数据包</p>
<pre><code>tcpdump
</code></pre><p>控制台输出：</p>
<pre><code>@dl  sudo tcpdump
[sudo] dl 的密码：
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on wlp2s0, link-type EN10MB (Ethernet), capture size 262144 bytes
23:56:46.929328 IP 192.168.1.131.50220 &gt; 192.168.1.1.domain: 47168+ A? baidu.com. (27)
23:56:46.929357 IP 192.168.1.131.50220 &gt; 192.168.1.1.domain: 10125+ AAAA? baidu.com. (27)
23:56:46.929918 IP 192.168.1.131.40552 &gt; 192.168.1.1.domain: 15187+ PTR? 1.1.168.192.in-addr.arpa. (42)
23:56:46.936167 ARP, Request who-has 192.168.1.131 tell 192.168.1.1, length 28
</code></pre></li>
<li><p>抓取所有经过 en0，目的或源地址是 10.37.63.255 的网络数据：</p>
</li>
</ol>
<pre><code class="shell">tcpdump -i en0 host 10.37.63.255
</code></pre>
<ol>
<li>抓取主机10.37.63.255和主机10.37.63.61或10.37.63.95的通信：</li>
</ol>
<pre><code class="shell?linenums">tcpdump host 10.37.63.255 and \(10.37.63.61 or 10.37.63.95 \)

taomingkais-MacBook-Pro:~ TaoBangren$ sudo tcpdump host 10.37.63.255 and \(10.37.63.61 or 10.37.63.95 \)
tcpdump: data link type PKTAP
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on pktap, link-type PKTAP (Packet Tap), capture size 262144 bytes
11:10:38.395320 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:39.234047 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:39.962286 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:48.422443 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:49.153630 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:49.894146 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
11:10:52.600297 IP 10.37.63.61.netbios-ns &gt; 10.37.63.255.netbios-ns: NBT UDP PACKET(137): QUERY; REQUEST; BROADCAST
</code></pre>
<ol>
<li><p>抓取主机10.37.63.3所有在TCP 80端口接收到的数据包：</p>
<pre><code>tcpdump -i en0 host 10.37.63.3 and dst tcp port 80
</code></pre></li>
<li><p>抓取所有经过 en0，目标 MAC 地址是 00:01:02:03:04:05 的 ICMP 数据</p>
<pre><code>tcpdump -i eth1 &#39;((icmp) and ((ether dst host 00:01:02:03:04:05)))&#39;
</code></pre></li>
<li><p>抓SYN，ACK</p>
<pre><code>tcpdump -i en0 &#39;tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0&#39;
</code></pre></li>
<li><p>抓 SMTP 数据，抓取数据区开始为”MAIL”的包，”MAIL”的十六进制为 0x4d41494c</p>
</li>
</ol>
<pre><code class="shell">tcpdump -i en0 &#39;((port 25) and (tcp[(tcp[12]&gt;&gt;2):4] = 0x4d41494c))&#39;
</code></pre>
<ol>
<li>抓 HTTP GET 数据，”GET “的十六进制是 0x47455420<br>```<br>tcpdump -i en0 ‘tcp[(tcp[12]&gt;&gt;2):4] = 0x47455420’</li>
</ol>
<h1 id="0x4745-为”GET”前两个字母”GE”-0x4854-为”HTTP”前两个字母”HT”"><a href="#0x4745-为”GET”前两个字母”GE”-0x4854-为”HTTP”前两个字母”HT”" class="headerlink" title="0x4745 为”GET”前两个字母”GE”,0x4854 为”HTTP”前两个字母”HT”"></a>0x4745 为”GET”前两个字母”GE”,0x4854 为”HTTP”前两个字母”HT”</h1><p>tcpdump  -XvvennSs 0 -i en0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854</p>
<pre><code>
9. 抓 SSH 返回，&quot;SSH-&quot;的十六进制是 0x5353482D
</code></pre><p>tcpdump -i en0 ‘tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D’</p>
<h1 id="抓老版本的-SSH-返回信息，如”SSH-1-99-”"><a href="#抓老版本的-SSH-返回信息，如”SSH-1-99-”" class="headerlink" title="抓老版本的 SSH 返回信息，如”SSH-1.99..”"></a>抓老版本的 SSH 返回信息，如”SSH-1.99..”</h1><p>tcpdump -i en0 ‘(tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D) and (tcp[((tcp[12]&gt;&gt;2)+4):2] = 0x312E)’</p>
<pre><code>10. 高级包头过滤
**如前两个的包头过滤，首先了解如何从包头过滤信息：**

    proto[x:y]          : 过滤从x字节开始的y字节数。比如ip[2:2]过滤出3、4字节（第一字节从0开始排）
    proto[x:y] &amp; z = 0  : proto[x:y]和z的与操作为0
    proto[x:y] &amp; z !=0  : proto[x:y]和z的与操作不为0
    proto[x:y] &amp; z = z  : proto[x:y]和z的与操作为z
    proto[x:y] = z      : proto[x:y]等于z

&gt;操作符 : &gt;, &lt;, &gt;=, &lt;=, =, !=

**抓取端口大于1024的TCP数据包：**
``` shell
tcpdump -i en0 &#39;tcp[0:2] &gt; 1024&#39;
</code></pre><ol>
<li>抓 DNS 请求数据</li>
</ol>
<pre><code class="shell">tcpdump -i en0 udp dst port 53
</code></pre>
<ol>
<li>其他<br>-c 参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工 CTRL+C 还是抓的太多，于是可以用-c 参数指定抓多少个包。<pre><code class="shell">time tcpdump -nn -i en0 &#39;tcp[tcpflags] = tcp-syn&#39; -c 10000 &gt; /dev/null
</code></pre>
上面的命令计算抓 10000 个 SYN 包花费多少时间，可以判断访问量大概是多少。</li>
</ol>
<p>实时抓取端口号8000的GET包，然后写入GET.log</p>
<pre><code class="shell">tcpdump -i en0 &#39;((port 8000) and (tcp[(tcp[12]&gt;&gt;2):4]=0x47455420))&#39; -nnAl -w /tmp/GET.log
</code></pre>
<pre><code>转自：
    作者：陶邦仁
    链接：http://www.jianshu.com/p/a62ed1bb5b20
    來源：简书
</code></pre>]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell,网络,运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络常见面试题]]></title>
      <url>/2017/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="OSI，TCP-IP，五层协议的体系结构"><a href="#OSI，TCP-IP，五层协议的体系结构" class="headerlink" title="OSI，TCP/IP，五层协议的体系结构"></a>OSI，TCP/IP，五层协议的体系结构</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><ul>
<li><strong>OSI分层（7层）：</strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
<li><strong>TCP/IP分层（4层）：</strong>网络接口层、网际层、运输层、应用层。</li>
<li><p><strong>五层协议（5层）：</strong>物理层、数据链路层、网络层、运输层、应用层。</p>
<a id="more"></a>
<h3 id="每一层的作用"><a href="#每一层的作用" class="headerlink" title="每一层的作用"></a>每一层的作用</h3></li>
<li><p><strong>物理层：</strong>激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。</p>
</li>
<li><p><strong>数据链路层：</strong>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
</li>
<li><p><strong>网络层：</strong>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。</p>
</li>
<li><p><strong>传输层：</strong>第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
</li>
<li><p><strong>会话层：</strong>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
</li>
<li><p><strong>表示层：</strong>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
</li>
<li><p><strong>应用层：</strong>为操作系统或网络应用程序提供访问网络服务的接口。</p>
</li>
</ul>
<h3 id="每一层的协议"><a href="#每一层的协议" class="headerlink" title="每一层的协议"></a>每一层的协议</h3><ul>
<li><strong>物理层</strong>：<code>RJ45、CLOCK、IEEE802.3</code>   （中继器，集线器，网关） </li>
<li><strong>数据链路</strong>：<code>PPP、FR、HDLC、VLAN、MAC</code>  （网桥，交换机） </li>
<li><strong>网络层</strong>：<code>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）</code></li>
<li><strong>传输层</strong>：<code>TCP、UDP、SPX</code></li>
<li><strong>会话层</strong>：<code>NFS、SQL、NETBIOS、RPC</code></li>
<li><strong>表示层</strong>：<code>JPEG、MPEG、ASII</code> </li>
<li><strong>应用层</strong>：<code>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</code></li>
</ul>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><ul>
<li><strong>A类地址：</strong>以0开头，第一个字节范围：0~127.0.0.0 - 126.255.255.255）；   </li>
<li><p><strong>B类地址：</strong>以10开头，第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；</p>
</li>
<li><p><strong>C类地址：</strong>以110开头，第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；</p>
</li>
<li><p><strong>D类地址：</strong>以1110开头，第一个字节范围为224~239；</p>
</li>
<li><strong>内网地址: </strong>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</li>
<li><strong><em>IP地址与子网掩码相与得到主机号</em></strong></li>
</ul>
<h2 id="ARP协议的工作原理"><a href="#ARP协议的工作原理" class="headerlink" title="ARP协议的工作原理"></a>ARP协议的工作原理</h2><p>首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h2 id="RARP协议"><a href="#RARP协议" class="headerlink" title="RARP协议"></a>RARP协议</h2><pre><code>将局域网中某个主机的物理地址转换为IP地址，比如局域网中有一台主机只知道物理地址而不知道IP地址，那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答。RARP协议广泛应用于无盘工作站引导时获取IP地址。

RARP允许局域网的物理机器从网管服务器ARP表或者缓存上请求其IP地址。
</code></pre><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol>
<li><p>主机发送一个本地的RARP广播，在此广播包中，声明自己的MAC地址并且请求任何收到此请求的RARP服务器分配一个IP地址。</p>
</li>
<li><p>本地网段上的RARP服务器收到此请求后，检查其RARP列表，查找该MAC地址对应的IP地址。</p>
</li>
<li><p>如果存在，RARP服务器就给源主机发送一个响应数据包并将此IP地址提供给对方主机使用。</p>
</li>
<li><p>如果不存在，RARP服务器对此不做任何的响应。</p>
</li>
<li><p>源主机收到从RARP服务器的响应信息，就利用得到的IP地址进行通讯；如果一直没有收到RARP服务器的响应信息，表示初始化失败。</p>
</li>
</ol>
<h2 id="常见的路由选择协议，以及它们的区别"><a href="#常见的路由选择协议，以及它们的区别" class="headerlink" title="常见的路由选择协议，以及它们的区别"></a>常见的路由选择协议，以及它们的区别</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。</p>
<h3 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h3><p>底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p>
<h3 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h3><p>底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p>
<h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><pre><code>  ICMP协议：
因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。

  TFTP协议：
是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。

  HTTP协议：
超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 

  DHCP协议：
动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。  

  NAT协议：
网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，  

  DHCP协议：
一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。
</code></pre><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><ul>
<li><p>UDP是面向无连接的，不可靠的数据报服务；</p>
</li>
<li><p>TCP是面向连接的，可靠的字节流服务。</p>
</li>
<li><p>TCP的可靠性如何保证？<br>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</p>
</li>
</ul>
<h2 id="TCP三次握手和四次挥手的全过程"><a href="#TCP三次握手和四次挥手的全过程" class="headerlink" title="TCP三次握手和四次挥手的全过程"></a>TCP三次握手和四次挥手的全过程</h2><p><img src="http://p.dearamaze.com/17-6-11/36414953.jpg" alt=""><br><img src="http://function.dearamaze.com//17-6-11/52895012.jpg" alt=""></p>
<h2 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入www.baidu.com后执行的全部过程</h2><p>现在假设如果我们在客户端（客户端）浏览器中输入 <a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> ,而 baidu.com 为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作：</p>
<p>  1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。</p>
<p>  2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。</p>
<p>  3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>  4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</p>
<h2 id="HTTP协议包括哪些请求？"><a href="#HTTP协议包括哪些请求？" class="headerlink" title="HTTP协议包括哪些请求？"></a>HTTP协议包括哪些请求？</h2><p>GET：请求读取由URL所标志的信息。</p>
<p>POST：给服务器添加信息（如注释）。</p>
<p>PUT：在给定的URL下存储一个文档。</p>
<p>DELETE：删除给定的URL所标志的资源。</p>
<h2 id="HTTP中，POST与GET的区别"><a href="#HTTP中，POST与GET的区别" class="headerlink" title="HTTP中，POST与GET的区别"></a>HTTP中，POST与GET的区别</h2><p>(1)Get是从服务器上获取数据，Post是向服务器传送数据。</p>
<p>(2)Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p>
<p>(3)Get传送的数据量小，不能大于2KB；post传送的数据量较大，一般被默认为不受限制。</p>
<p>(4)根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p>
<p>I.所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p>
<p>II.幂等的意味着对同一URL的多个请求应该返回同样的结果。</p>
<h2 id="TCP对应的协议和UDP对应的协议"><a href="#TCP对应的协议和UDP对应的协议" class="headerlink" title="TCP对应的协议和UDP对应的协议"></a>TCP对应的协议和UDP对应的协议</h2><h3 id="TCP对应的协议："><a href="#TCP对应的协议：" class="headerlink" title="TCP对应的协议："></a>TCP对应的协议：</h3><p>（1） FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。</p>
<p>（2） Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。</p>
<p>（3） SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。</p>
<p>（4） POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>
<p>（5）HTTP协议：是从Web服务器传输超文本到本地浏览器的传送协议。</p>
<h3 id="UDP对应的协议："><a href="#UDP对应的协议：" class="headerlink" title="UDP对应的协议："></a>UDP对应的协议：</h3><p>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</p>
<p>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</p>
<h2 id="NAT协议、DHCP协议、DNS协议的作用"><a href="#NAT协议、DHCP协议、DNS协议的作用" class="headerlink" title="NAT协议、DHCP协议、DNS协议的作用"></a>NAT协议、DHCP协议、DNS协议的作用</h2><p>NAT协议：网络地址转换(NAT,Network AddressTranslation)属接入广域网(WAN)技术，</p>
<p>是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<p>DHCP协议：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）</p>
<p>是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>DNS协议：DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<h2 id="了解交换机、路由器、网关的概念，并知道各自的用途"><a href="#了解交换机、路由器、网关的概念，并知道各自的用途" class="headerlink" title="了解交换机、路由器、网关的概念，并知道各自的用途"></a>了解交换机、路由器、网关的概念，并知道各自的用途</h2><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><pre><code>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背
部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部
交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表
中。  

交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张
ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不
能划分网络层广播，即广播域。  
 交换机被广泛应用于二层网络交换，俗称“二层交换机”。  

交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。  
</code></pre><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><pre><code>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过
的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转
送。路由工作在OSI模型的第三层——即网络层，例如网际协议。  


路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。  
</code></pre><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><pre><code>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP
的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家
庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。  

在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能
转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系
统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关
（gateway）与路由器（router）还没有区别。  

在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。  


网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。  

对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。
</code></pre><h2 id="TCP的流量控制和拥塞控制"><a href="#TCP的流量控制和拥塞控制" class="headerlink" title="TCP的流量控制和拥塞控制"></a>TCP的流量控制和拥塞控制</h2><p>见<a href="http://blog.sina.com.cn/s/blog_6988593e01015wu0.html" target="_blank" rel="external">链接</a></p>
]]></content>
      
        <categories>
            
            <category> 面试题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vsftpd配置文件]]></title>
      <url>/2017/06/09/vsftpd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>vsftpd配置文件</p>
<a id="more"></a>
<pre><code class="conf">#禁用匿名用户登陆
anonymous_enable=NO

#允许本地用户登陆
local_enable=YES

#允许本地用户写入
write_enable=YES

#注意：这个地方如果不配置，就会出现只有root用户可以登陆，普通用户不可以
check_shell=NO

#掩码，决定了上传上来的文件的权限。设置为000使之有最大权限
local_umask=000

#允许记录日志
xferlog_enable=YES

#允许数据流从20端口传输
connect_from_port_20=YES

#日志路径
xferlog_file=/var/log/vsftpd.log

#ftp欢迎语，可以随便设置
ftpd_banner=hi,guys!

#注意：这个选项可以保证用户锁定在指定的家目录里，防止系统文件被修改。
chroot_local_user=YES

#注意：这个不配置有可能出现只能下载不能上传
allow_writeable_chroot=YES

#配置了可以以stand alone模式运行
listen=YES

#注意：该选项不配置可能导致莫名其妙的530问题
seccomp_sandbox=NO

#说明我们要指定一个userlist，里边放的是允许ftp登陆的本地用户。如果设置为YES，则文件里设置的是不允许登陆的本地用户
userlist_deny=NO
userlist_enable=YES

#记录允许本地登陆用户名的文件
userlist_file=/etc/vsftpd/allowed_users
</code></pre>
]]></content>
      
        <categories>
            
            <category> 配置文件 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ftp </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell知识遗漏2]]></title>
      <url>/2017/06/09/shell%E7%9F%A5%E8%AF%86%E9%81%97%E6%BC%8F2/</url>
      <content type="html"><![CDATA[<h2 id="比较与测试"><a href="#比较与测试" class="headerlink" title="比较与测试"></a>比较与测试</h2><ol>
<li>if条件</li>
<li>else if 和 else</li>
</ol>
<a id="more"></a>
<pre><code class="shell">#!/bin/bash
read i
if [ $i -gt 10 ];then
    echo &quot;i&gt;=10&quot;
elif [ $i -le 10 ]&amp;&amp;[ $i -gt 0 ];then
    echo &quot;0&lt;i&lt;=10&quot;
else
    echo &quot;i&lt;=0&quot;
fi
</code></pre>
<p>3.小技巧</p>
<blockquote>
<p>if 和 else 语句可以进行嵌套。 if 的条件判断部分可能会变得很长,<br>但可以用逻辑运算符将它变得简洁一些:</p>
</blockquote>
<pre><code>[ condition ] &amp;&amp; action; # 如果 condition 为真,则执行 action ;
[ condition ] || action; # 如果 condition 为假,则执行 action 。

&amp;&amp; 是逻辑与运算符, || 是逻辑或运算符。编写Bash脚本时,这是一
个很有用的技巧。现在来了解一下条件和比较操作。
</code></pre><p>4.比较运算符</p>
<p>算数运算符:</p>
<pre><code>-gt :大于。
-lt :小于。
-ge :大于或等于。
-le :小于或等于。
</code></pre><p>文件系统相关测试:</p>
<pre><code class="shell">我们可以使用不同的条件标志测试不同的文件系统相关的属性。
[ -f $file_var ] :如果给定的变量包含正常的文件路径或文件名,则返回真。(判断给定的文件,是否存在!只能判断文件!)
[ -x $var ] :如果给定的变量包含的文件可执行,则返回真。
[ -d $var ] :如果给定的变量包含的是目录,则返回真。
[ -e $var ] :如果给定的变量包含的文件(文件文件夹都可以)存在,则返回真。
[ -c $var ] :如果给定的变量包含的是一个字符设备文件的路径,则返回真。
[ -b $var ] :如果给定的变量包含的是一个块设备文件的路径,则返回真。
[ -w $var ] :如果给定的变量包含的文件可写,则返回真。
[ -r $var ] :如果给定的变量包含的文件可读,则返回真。
[ -L $var ] :如果给定的变量包含的是一个符号链接,则返回真。
使用方法如下:
fpath=&quot;/etc/passwd&quot;
if [ -e $fpath ]; then
    echo File exists;
else
    echo Does not exist;
fi
</code></pre>
<p>字符串比较:</p>
<pre><code>使用字符串比较时,最好用双中括号,因为有时候采用单个中括号会产生错误,所以最
好避开它们。
可以用下面的方法检查两个字符串,看看它们是否相同。
[[ $str1 = $str2 ]] :当 str1 等于 str2 时,返回真。也就是说, str1 和 str2 包含的文本是一模一样的。
[[ $str1 == $str2 ]] :这是检查字符串是否相等的另一种写法。
也可以检查两个字符串是否不同。

[[ $str1 != $str2 ]] :如果 str1 和 str2 不相同,则返回真。
我们还可以检查字符串的字母序情况,具体如下所示。
[[ $str1 &gt; $str2 ]] :如果 str1 的字母序比 str2 大,则返回真。
[[ $str1 &lt; $str2 ]] :如果 str1 的字母序比 str2 小,则返回真。
[[ -z $str1 ]] :如果 str1 包含的是空字符串,则返回真。
[[ -n $str1 ]] :如果 str1 包含的是非空字符串,则返回真。

注意在 = 前后各有一个空格。如果忘记加空格,那就不是比较关系了,而变成了赋值语句。
</code></pre><p>多条件组合</p>
<pre><code>使用逻辑运算符 &amp;&amp; 和 || 能够很容易地将多个条件组合起来:
if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]] ;
then
    commands;
fi
例如:
str1=&quot;Not empty &quot;
str2=&quot;&quot;
if [[ -n $str1 ]] &amp;&amp; [[ -z $str2 ]];
then
    echo str1 is nonempty and str2 is empty string.
fi

输出如下:
str1 is nonempty and str2 is empty string.
</code></pre><p>test命令</p>
<pre><code class="SHELL">test 命令可以用来执行条件检测。用 test 可以避免使用过多的括号。之前讲过的 [] 中的测试条件同样可以用于 test 命令。
例如:
if  [ $var -eq 0 ]; then echo &quot;True&quot;; fi
也可以写成:
if  test $var -eq 0 ; then echo &quot;True&quot;; fi
</code></pre>
<h2 id="录制并回放终端回话"><a href="#录制并回放终端回话" class="headerlink" title="录制并回放终端回话"></a>录制并回放终端回话</h2><p>暂且跳过,用的不多</p>
<p>## </p>
]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[py自动化运维第一章]]></title>
      <url>/2017/06/07/py%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h1 id="第一章-系统基础信息模块详解"><a href="#第一章-系统基础信息模块详解" class="headerlink" title="第一章 系统基础信息模块详解"></a>第一章 系统基础信息模块详解</h1><h2 id="系统性能信息模块psutil"><a href="#系统性能信息模块psutil" class="headerlink" title="系统性能信息模块psutil"></a>系统性能信息模块<code>psutil</code></h2><p>实例：<a href="https://github.com/giampaolo/psutil" target="_blank" rel="external">https://github.com/giampaolo/psutil</a></p>
<p>文档：<a href="https://pythonhosted.org/psutil/#recipes/" target="_blank" rel="external">https://pythonhosted.org/psutil/#recipes/</a></p>
<a id="more"></a>
<h3 id="shell中常用监控命令"><a href="#shell中常用监控命令" class="headerlink" title="shell中常用监控命令"></a>shell中常用监控命令</h3><p>ps:<br>top:<br>lsof:<br>netstat:<br>ifconfig:<br>who:<br>df:<br>kill:<br>free:<br>nice:<br>ionice:<br>iostat:<br>iotop:<br>uptime:<br>pidof:<br>tty:<br>taskset:<br>pmap:</p>
<!--more-->
<h3 id="获取系统性能信息"><a href="#获取系统性能信息" class="headerlink" title="获取系统性能信息"></a>获取系统性能信息</h3><ol>
<li>CPU信息<br>```python <blockquote>
<blockquote>
<blockquote>
<p>import psutil<br>psutil.cpu_times()<br>scputimes(user=3961.46, nice=169.729, system=2150.659, idle=16900.540, iowait=629.59, irq=0.0, softirq=19.42, steal=0.0, guest=0, nice=0.0)</p>
<p>for x in range(3):<br>…     psutil.cpu_percent(interval=1)<br>…<br>4.0<br>5.9<br>3.8</p>
<p>for x in range(3):<br>…     psutil.cpu_percent(interval=1, percpu=True)<br>…<br>[4.0, 6.9, 3.7, 9.2]<br>[7.0, 8.5, 2.4, 2.1]<br>[1.2, 9.0, 9.9, 7.2]</p>
<p>for x in range(3):<br>…     psutil.cpu_times_percent(interval=1, percpu=False)<br>…<br>scputimes(user=1.5, nice=0.0, system=0.5, idle=96.5, iowait=1.5, irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)<br>scputimes(user=1.0, nice=0.0, system=0.0, idle=99.0, iowait=0.0, irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)<br>scputimes(user=2.0, nice=0.0, system=0.0, idle=98.0, iowait=0.0, irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)</p>
<p>psutil.cpu_count()<br>4<br>psutil.cpu_count(logical=False)<br>2</p>
<p>psutil.cpu_stats()<br>scpustats(ctx_switches=20455687, interrupts=6598984, soft_interrupts=2134212, syscalls=0)</p>
<p>psutil.cpu_freq()<br>scpufreq(current=931.42925, min=800.0, max=3500.0)</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<pre><code>tip:

    irq:硬件中断
    softirq：软件中断
2. 内存信息
```python
&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.virtual_memory() #内存完整信息
svmem(total=10367352832, available=6472179712, percent=37.6, used=8186245120, free=2181107712, active=4748992512, inactive=2758115328, buffers=790724608, cached=3500347392, shared=787554304)
&gt;&gt;&gt; psutil.swap_memory() #获取交换分区信息
sswap(total=2097147904, used=296128512, free=1801019392, percent=14.1, sin=304193536, sout=677842944)
&gt;&gt;&gt;
</code></pre><p>tip:</p>
<pre><code>total:内存总数
used：已经使用的内存数
free：空闲内存数
buffers：缓冲使用数
cache：缓冲使用数
swap：交换分区使用数
</code></pre><p><a href="http://www.cnblogs.com/chenpingzhao/p/5161844.html" target="_blank" rel="external">free命令中cached和buffers的区别</a></p>
<ol>
<li><p>磁盘信息</p>
<pre><code class="python">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.disk_partitions()
[sdiskpart(device=&#39;/dev/sda1&#39;, mountpoint=&#39;/&#39;, fstype=&#39;ext4&#39;, opts=&#39;rw,nosuid&#39;),
sdiskpart(device=&#39;/dev/sda2&#39;, mountpoint=&#39;/home&#39;, fstype=&#39;ext, opts=&#39;rw&#39;)]
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.disk_usage(&#39;/&#39;)
sdiskusage(total=21378641920, used=4809781248, free=15482871808, percent=22.5)
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.disk_io_counters(perdisk=False)
sdiskio(read_count=719566, write_count=1082197, read_bytes=18626220032, write_bytes=24081764352, read_time=5023392, write_time=63199568, read_merged_count=619166, write_merged_count=812396, busy_time=4523412)
&gt;&gt;&gt;
</code></pre>
</li>
<li><p>网络信息</p>
<pre><code class="python">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.net_io_counters(pernic=True)
{&#39;eth0&#39;: netio(bytes_sent=485291293, bytes_recv=6004858642, packets_sent=3251564, packets_recv=4787798, errin=0, errout=0, dropin=0, dropout=0),
&#39;lo&#39;: netio(bytes_sent=2838627, bytes_recv=2838627, packets_sent=30567, packets_recv=30567, errin=0, errout=0, dropin=0, dropout=0)}
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.net_connections()
[pconn(fd=115, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketType.SOCK_STREAM: 1&gt;, laddr=(&#39;10.0.0.1&#39;, 48776), raddr=(&#39;93.186.135.91&#39;, 80), status=&#39;ESTABLISHED&#39;, pid=1254),
pconn(fd=117, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketType.SOCK_STREAM: 1&gt;, laddr=(&#39;10.0.0.1&#39;, 43761), raddr=(&#39;72.14.234.100&#39;, 80), status=&#39;CLOSING&#39;, pid=2987),
pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketType.SOCK_STREAM: 1&gt;, laddr=(&#39;10.0.0.1&#39;, 60759), raddr=(&#39;72.14.234.104&#39;, 80), status=&#39;ESTABLISHED&#39;, pid=None),
pconn(fd=-1, family=&lt;AddressFamily.AF_INET: 2&gt;, type=&lt;SocketType.SOCK_STREAM: 1&gt;, laddr=(&#39;10.0.0.1&#39;, 51314), raddr=(&#39;72.14.234.83&#39;, 443), status=&#39;SYN_SENT&#39;, pid=None)
...]
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.net_if_addrs()
{&#39;lo&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;127.0.0.1&#39;, netmask=&#39;255.0.0.0&#39;, broadcast=&#39;127.0.0.1&#39;, ptp=None),
     snic(family=&lt;AddressFamily.AF_INET6: 10&gt;, address=&#39;::1&#39;, netmask=&#39;ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff&#39;, broadcast=None, ptp=None),
     snic(family=&lt;AddressFamily.AF_LINK: 17&gt;, address=&#39;00:00:00:00:00:00&#39;, netmask=None, broadcast=&#39;00:00:00:00:00:00&#39;, ptp=None)],
&#39;wlan0&#39;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&#39;192.168.1.3&#39;, netmask=&#39;255.255.255.0&#39;, broadcast=&#39;192.168.1.255&#39;, ptp=None),
        snic(family=&lt;AddressFamily.AF_INET6: 10&gt;, address=&#39;fe80::c685:8ff:fe45:641%wlan0&#39;, netmask=&#39;ffff:ffff:ffff:ffff::&#39;, broadcast=None, ptp=None),
        snic(family=&lt;AddressFamily.AF_LINK: 17&gt;, address=&#39;c4:85:08:45:06:41&#39;, netmask=None, broadcast=&#39;ff:ff:ff:ff:ff:ff&#39;, ptp=None)]}
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.net_if_stats()
{&#39;eth0&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_FULL: 2&gt;, speed=100, mtu=1500),
&#39;lo&#39;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=65536)}
&gt;&gt;&gt;
</code></pre>
</li>
<li>其他系统信息<pre><code class="python">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; psutil.users()
[suser(name=&#39;giampaolo&#39;, terminal=&#39;pts/2&#39;, host=&#39;localhost&#39;, started=1340737536.0, pid=1352),
suser(name=&#39;giampaolo&#39;, terminal=&#39;pts/3&#39;, host=&#39;localhost&#39;, started=1340737792.0, pid=1788)]
&gt;&gt;&gt;
&gt;&gt;&gt; psutil.boot_time()
1365519115.0
&gt;&gt;&gt;
</code></pre>
</li>
</ol>
<h3 id="系统进程管理方法"><a href="#系统进程管理方法" class="headerlink" title="系统进程管理方法"></a>系统进程管理方法</h3><ol>
<li><p>进程信息<br>插入一条关于进程控制信号捕获的博客，常考笔试题（sigkill和sigstop不可被捕捉，sigint可以被捕捉）：<a href="http://blog.csdn.net/madpointer/article/details/13091705" target="_blank" rel="external">http://blog.csdn.net/madpointer/article/details/13091705</a></p>
</li>
<li><p>popen类的使用</p>
</li>
</ol>
<pre><code class="python">&gt;&gt;&gt; import psutil
&gt;&gt;&gt; from subprocess import PIPE
&gt;&gt;&gt; p = psutil.Popen([&quot;/usr/bin/python&quot;, &quot;-c&quot;, &quot;print(&#39;hello&#39;)&quot;], stdout=PIPE)
&gt;&gt;&gt; p.name()
&#39;python&#39;
&gt;&gt;&gt; p.username()
&#39;giampaolo&#39;
&gt;&gt;&gt; p.communicate()
(&#39;hello\n&#39;, None)
&gt;&gt;&gt; p.wait(timeout=2)
0
&gt;&gt;&gt;
</code></pre>
<h2 id="实用的IP地址处理模块IPy"><a href="#实用的IP地址处理模块IPy" class="headerlink" title="实用的IP地址处理模块IPy"></a>实用的IP地址处理模块<code>IPy</code></h2><pre><code class="python">#!/usr/bin/env python

from IPy import IP

ip_s = raw_input(&#39;Please input an IP or net-range: &#39;)
ips = IP(ip_s)


if len(ips) &gt; 1:
    print(&#39;net: %s&#39; % ips.net()) #输出网络地址
    print(&#39;netmask: %s&#39; % ips.netmask()) #输出网络掩码地址
    print(&#39;broadcast: %s&#39; % ips.broadcast())  #输出广播地址
    print(&#39;reverse address: %s&#39; % ips.reverseNames()[0])  #输出地址反向解析
    print(&#39;subnet: %s&#39; % len(ips)) #输出网络子网数
else:
    print(&#39;reverse address: %s&#39; % ips.reverseNames()[0])

print(&#39;hexadecimal: %s&#39; % ips.strHex()) #十六进制地址
print(&#39;binary ip: %s&#39; % ips.strBin()) #二进制地址
print(&#39;iptype: %s&#39; % ips.iptype()) #地址类型
</code></pre>
<h2 id="DNS处理模块dnspython"><a href="#DNS处理模块dnspython" class="headerlink" title="DNS处理模块dnspython"></a>DNS处理模块<code>dnspython</code></h2><p>插播新知识：<a href="http://roclinux.cn/?p=2449" target="_blank" rel="external">dig命令</a></p>
<h3 id="模块域名解析方法详解"><a href="#模块域名解析方法详解" class="headerlink" title="模块域名解析方法详解"></a>模块域名解析方法详解</h3><h4 id="常见的DNS解析类型"><a href="#常见的DNS解析类型" class="headerlink" title="常见的DNS解析类型"></a>常见的DNS解析类型</h4><p>A记录： 将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录</p>
<p>CNAME记录： 如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名</p>
<p>MX记录： 建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</p>
<p>NS记录： 域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录</p>
<p>TXT记录： 可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录</p>
<p>AAAA记录： 将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录</p>
<p>SRV记录： 添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</p>
<p>SOA记录： SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器</p>
<p>PTR记录： PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名</p>
<p>显性URL转发记录： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。</p>
<p>隐性UR转发记录L： 将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。</p>
<ol>
<li>DNS解析中一些问题</li>
</ol>
<p>2.1 A记录与CNAME记录</p>
<p>A记录是把一个域名解析到一个IP地址，而CNAME记录是把域名解析到另外一个域名，而这个域名最终会指向一个A记录，在功能实现在上A记录与CNAME记录没有区别。</p>
<p>CNAME记录在做IP地址变更时要比A记录方便。CNAME记录允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做A记录指向服务器IP，然后将其他的域名做别名(即：CNAME)到A记录的域名上。当服务器IP地址变更时，只需要更改A记录的那个域名到新IP上，其它做别名的域名会自动更改到新的IP地址上，而不必对每个域名做更改。</p>
<p>2.2 A记录与AAAA记录</p>
<p>二者都是指向一个IP地址，但对应的IP版本不同。A记录指向IPv4地址，AAAA记录指向IPv6地址。AAAA记录是A记录的升级版本。</p>
<p>2.3 IPv4与IPv6</p>
<p>IPv4，是互联网协议（Internet Protocol，IP）的第四版，也是第一个被广泛使用的版本，是构成现今互联网技术的基础协议。IPv4 的下一个版本就是IPv6，在将来将取代目前被广泛使用的IPv4。</p>
<p>IPv4中规定IP地址长度为32位（按TCP/IP参考模型划分) ，即有2^32-1个地址。IPv6的提出最早是为了解决，随着互联网的迅速发展IPv4地址空间将被耗尽的问题。为了扩大地址空间，IPv6将IP地址的长度由32位增加到了128位。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还解决了IPv4中的其它问题，如：端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。</p>
<p>2.4 TTL值</p>
<p>TTL－生存时间（Time To Live），表示解析记录在DNS服务器中的缓存时间，TTL的时间长度单位是秒，一般为3600秒。比如：在访问www.itbilu.com时，如果在DNS服务器的缓存中没有该记录，就会向某个NS服务器发出请求，获得该记录后，该记录会在DNS服务器上保存TTL的时间长度，在TTL有效期内访问www.itbilu.com，DNS服务器会直接缓存中返回刚才的记录。</p>
<h3 id="DNS轮询（不完善）"><a href="#DNS轮询（不完善）" class="headerlink" title="DNS轮询（不完善）"></a>DNS轮询（不完善）</h3><pre><code class="python">#!/usr/bin/python
#coding:utf-8

import dns.resolver
import os
import httplib

iplist=[]    #定义域名IP列表变量
appdomain=&quot;fdl66.github.io&quot;    #定义业务域名

def get_iplist(domain=&quot;&quot;):    #域名解析函数，解析成功IP将追加到iplist
    try:
        cname = dns.resolver.query(domain, &#39;CNAME&#39;)
        domains = []
        for i in cname.response.answer:
            for j in i.items:
                print j.to_text()+&quot;debug&quot;
                domains.append(j)
        for dom in domains:
            A=dns.resolver.query(str(dom),&#39;A&#39;)  # 解析A记录类型
            for i in A.response.answer:
                for j in i.items:
                    print j.address+&quot;debug&quot;
                    iplist.append(j.address)  # 追加到iplist
    except Exception,e:
        print &quot;dns resolver error:&quot;+str(e)
        return
    return True

def checkip(ip):
    checkurl=ip+&quot;:80&quot;
    getcontent=&quot;&quot;
    httplib.socket.setdefaulttimeout(5)    #定义http连接超时时间(5秒)
    conn=httplib.HTTPConnection(checkurl)    #创建http连接对象

    try:
        conn.request(&quot;GET&quot;, &quot;/&quot;,headers = {&quot;Host&quot;: appdomain})  #发起URL请求，添加host主机头
        r=conn.getresponse()
        getcontent =r.read(15)   #获取URL页面前15个字符，以便做可用性校验
    finally:
        print getcontent+&quot;debug&quot;
        if getcontent==&quot;&lt;!doctype html&gt;&quot;:  #监控URL页的内容一般是事先定义好，比如“HTTP200”等
            print ip+&quot; [OK]&quot;
        else:
            print ip+&quot; [Error]&quot;    #此处可放告警程序，可以是邮件、短信通知

if __name__==&quot;__main__&quot;:
    if get_iplist(appdomain) and len(iplist)&gt;0:    #条件：域名解析正确且至少要返回一个IP
        for ip in iplist:
            checkip(ip)
    else:
        print &quot;dns resolver error.&quot;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[逻辑块与物理块的对应关系]]></title>
      <url>/2017/06/07/%E9%80%BB%E8%BE%91%E5%9D%97%E4%B8%8E%E7%89%A9%E7%90%86%E5%9D%97%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h2 id="物理块的大小设定"><a href="#物理块的大小设定" class="headerlink" title="物理块的大小设定"></a>物理块的大小设定</h2><p>我们把Ext2、Minix、Ext等实际可使用的文件系统称为具体文件系统。具体文件系统管理的是一个逻辑空间，这个逻辑空间就象一个大的数组，数组的每个元素就是文件系统操作的基本单位——逻辑块，逻辑块是从0开始编号的，而且，逻辑块是连续的。与逻辑块相对的是物理块，物理块是数据在磁盘上的存取单位，也就是每进行一次I/O操作，最小传输的数据大小。我们知道数据是存储在磁盘的扇区中的，那么扇区是不是物理块呢？或者物理块是多大呢？这涉及到文件系统效率的问题。</p>
<a id="more"></a>
<p>如果物理块定的比较大，比如一个柱面大小，这时，即使是1个字节的文件都要占用整个一个柱面，假设Linux环境下文件的平均大小为1K，那么分配32K的柱面将浪费97%的磁盘空间，也就是说，大的存取单位将带来严重的磁盘空间浪费。另一方面，如果物理块过小，则意味着对一个文件的操作将进行更多次的寻道延迟和旋转延迟，因而读取由小的物理块组成的文件将非常缓慢！可见，时间效率和空间效率在本质上是相互冲突的。</p>
<p>因此，最优的方法是计算出Linux环境下文件的平均大小，然后将物理块大小定为最接近扇区的整数倍大小。在Ext2中，物理块的大小是可变化的，这取决于你在创建文件系统时的选择，之所以不限制大小，也正体现了Ext2的灵活性和可扩充性，一是因为要适应近年来文件的平均长度缓慢增长的趋势，二是为了适应不同的需要。比如，如果一个文件系统主要用于BBS服务，考虑到BBS上的文章通常很短小，所以，物理块选的小一点是恰当的。通常，Ext2的物理块占一个或几个连续的扇区，显然，物理块的数目是由磁盘容量等硬件因素决定的。逻辑块与物理块的关系类似于虚拟内存中的页与物理内存中的页面的关系。</p>
<h2 id="逻辑块与物理块之间的关系"><a href="#逻辑块与物理块之间的关系" class="headerlink" title="逻辑块与物理块之间的关系"></a>逻辑块与物理块之间的关系</h2><p>具体文件系统所操作的基本单位是逻辑块，只在需要进行I/O操作时才进行逻辑块到物理块的映射，这显然避免了大量的I/O操作，因而文件系统能够变得高效。逻辑块作为一个抽象的概念，它必然要映射到具体的物理块上去，因此，逻辑块的大小必须是物理块大小的整数倍，一般说来，两者是一样大的。</p>
<p>通常，一个文件占用的多个物理块在磁盘上是不连续存储的，因为如果连续存储，则经过频繁的删除、建立、移动文件等操作，最后磁盘上将形成大量的空洞，很快磁盘上将无空间可供使用。因此，必须提供一种方法将一个文件占用的多个逻辑块映射到对应的非连续存储的物理块上去，Ext2等类文件系统是用索引节点解决这个问题的，具体实现方法后面再予以介绍。</p>
<p>为了更好的说明逻辑块和物理块的关系，我们来看一个例子。</p>
<p>假设用户要对一个已有文件进行写操作，用户进程必须先打开这个文件，file结构记录了该文件的当前位置。然后用户把一个指向用户内存区的指针和请求写的字节数传送给系统，请求写操作，这时系统要进行两次映射。</p>
<p>（1）一组字节到逻辑块的映射。</p>
<p>这个映射过程就是找到起始字节到结束字节所占用的所有逻辑块号。这是因为在逻辑空间，文件传输的基本单位是逻辑块而不是字节。</p>
<p>（2）逻辑块到物理块的映射。</p>
<p>这个过程必须要用到索引节点结构，该结构中有一个物理块指针数组，以逻辑块号为索引，通过这些指针找到磁盘上的物理块，具体实现将在介绍Ext2索引节点时再进行介绍。</p>
<p>图1是由一组请求的字节到物理块的映射过程示意图。<br><img src="http://www.chinastor.com/uploads/allimg/121016/101U91B4-0.gif" alt=""></p>
<p>有了逻辑块和物理块的概念，我们也就知道通常所说的数据块是指逻辑块，以下没有特别说明，块或数据块指的是逻辑块。</p>
<p>在Ext2中，还有一个重要的概念：片（fragment），它的作用是什么？</p>
<p>每个文件必然占用整数个逻辑块，除非每个文件大小都恰好是逻辑块的整数倍，否则最后一个逻辑块必然有空间未被使用，实际上，每个文件的最后一个逻辑块平均要浪费一半的空间，显然最终浪费的还是物理块。在一个有很多文件的系统中，这种浪费是很大的。Ext2使用片来解决这个问题。</p>
<h2 id="片"><a href="#片" class="headerlink" title="片"></a>片</h2><p>片也是一个逻辑空间中的概念，其大小在1K至4K之间，但片的大小总是不大于逻辑块。假设逻辑块大小为4K，片大小为1K，物理块大小也是1K，当你要创建一个3K大小的文件时，实际上分配给你了3个片，而不会给你一个逻辑块，当文件大小增加到4K时，文件系统则分配一个逻辑块给你，而原来的四个片被清空。如果文件又增加到5K时，则占用1个逻辑块和1个片。上述三种情况下，所占用的物理块分别是3个、4个、5个，如果不采用片，则要用到4个、4个、8个物理块，可见，使用片，减少了磁盘空间的浪费。当然，在物理块和逻辑块大小一样时，片就没有意义了。<br>由上面分析也可看出：</p>
<p>物理块大小&lt;=片大小&lt;=逻辑块大小</p>
]]></content>
      
        <categories>
            
            <category> 文件系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据重删 </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell知识遗漏1]]></title>
      <url>/2017/05/16/shell%E7%9F%A5%E8%AF%86%E9%81%97%E6%BC%8F1/</url>
      <content type="html"><![CDATA[<h2 id="数组和关联数组"><a href="#数组和关联数组" class="headerlink" title="数组和关联数组"></a>数组和关联数组</h2><p>Bash从4.0版本之后才开始支持关联数组。<br>(1) 定义数组的方法有很多种。可以在单行中使用一列值来定义一个数组:</p>
<pre><code class="shell">
array_var=(1 2 3 4 5 6)
#这些值将会存储在以0为起始索引的连续位置上
</code></pre>
<p>另外,还可以将数组定义成一组“索引 - 值”:</p>
<pre><code class="shell">array_var[0]=&quot;test1&quot;
array_var[1]=&quot;test2&quot;
array_var[2]=&quot;test3&quot;
array_var[3]=&quot;test4&quot;
array_var[4]=&quot;test5&quot;
array_var[5]=&quot;test6&quot;
</code></pre>
<p>(2) 打印出特定索引的数组元素内容:</p>
<pre><code class="shell">echo ${array_var[0]}
test1
index=5
echo ${array_var[$index]}
test6
</code></pre>
<p>(3) 以清单形式打印出数组中的所有值:</p>
<pre><code class="shell">$ echo ${array_var[*]}
test1 test2 test3 test4 test5 test6
也可以这样使用:
$ echo ${array_var[@]}
test1 test2 test3 test4 test5 test6
</code></pre>
<p>(4) 打印数组长度(即数组中元素的个数):</p>
<pre><code class="shell">$ echo ${#array_var[*]}
6
</code></pre>
<a id="more"></a>
<h2 id="数组plus"><a href="#数组plus" class="headerlink" title="数组plus"></a>数组plus</h2><p>1).定义关联数组<br>在关联数组中,我们可以用任意的文本作为数组索引。首先,需要使用声明语句将一个变量<br>名声明为关联数组。像下面这样:</p>
<pre><code>$ declare -A ass_array
</code></pre><p>声明之后,可以用两种方法将元素添加到关联数组中。<br>利用内嵌“索引 - 值”列表的方法,提供一个“索引 - 值”列表:</p>
<pre><code>$ ass_array=([index1]=val1 [index2]=val2)
</code></pre><p>使用独立的“索引 - 值”进行赋值:</p>
<pre><code>$ ass_array[index1]=val1
$ ass_array&#39;index2]=val2
</code></pre><p>举个例子,试想如何用关联数组为水果制定价格:</p>
<pre><code>$ declare -A fruits_value
$ fruits_value=([apple]=&#39;100dollars&#39; [orange]=&#39;150 dollars&#39;)
</code></pre><p>用下面的方法显示数组内容:</p>
<pre><code>$ echo &quot;Apple costs ${fruits_value[apple]}&quot;
Apple costs 100 dollars
</code></pre><p>2).列出数组索引<br>每一个数组元素都有一个索引用于查找。普通数组和关联数组具有不同的索引类型。我们可<br>以用下面的方法获取数组的索引列表:</p>
<pre><code>$ echo ${!array_var[*]}
也可以使用:
$ echo ${!array_var[@]
</code></pre><p>以先前提到的 fruits_value 数组为例,运行如下命令:</p>
<pre><code>$ echo ${!fruits_value[*]}
orange apple
对于普通数组,这个方法同样可行。
</code></pre><h2 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h2><h2 id="函数和参数"><a href="#函数和参数" class="headerlink" title="函数和参数"></a>函数和参数</h2><p> <code>$1</code> 是第一个参数。</p>
<p> <code>$2</code> 是第二个参数。<br> <code>$n</code> 是第n个参数。</p>
<p> <code>&quot;$@&quot;</code> 被扩展成 <code>&quot;$1&quot; &quot;$2&quot; &quot;$3&quot;</code> 等。</p>
<p> <code>&quot;$*&quot;</code> 被扩展成 <code>&quot;$1c$2c$3&quot;</code> ,其中 c 是IFS的第一个字符。</p>
<p> <code>&quot;$@&quot;</code> 要比 <code>&quot;$*&quot;</code> 用得多。由于 <code>&quot;$*&quot;</code> 将所有的参数当做单个字符串,因此它很少被使用。<br> <code>$?</code>  上一条命令执行的返回值</p>
<p> <code>$#</code> 参数个数 </p>
<h2 id="字段分隔符和迭代器"><a href="#字段分隔符和迭代器" class="headerlink" title="字段分隔符和迭代器"></a>字段分隔符和迭代器</h2><pre><code class="shell">
#!/bin/bash
#用途: 演示IFS的用法
line=&quot;root:x:0:0:root:/root:/bin/bash&quot;
oldIFS=$IFS;
IFS=&quot;:&quot;
count=0
for item in $line;
do
    [ $count -eq 0 ] &amp;&amp; user=$item;
    [ $count -eq 6 ] &amp;&amp; shell=$item;
    let count++
done;
IFS=$oldIFS
echo $user\&#39;s shell is $shell;

输出为:
root&#39;s shell is /bin/bash
</code></pre>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><pre><code>for var in list;
do
    commands; #使用变量$var
done
</code></pre><p>list 可以是一个字符串,也可以是一个序列。<br>我们可以轻松地生成不同的序列。<br>echo {1..50} 能够生成一个从1~50的数字列表。 echo {a..z} 或 {A..Z} 或 {a..h} 可以生</p>
<p>成字母列表。同样,我们可以将这些方法结合起来对数据进行拼接(concatenate)<br>。下面的<br>代码中,变量 i 在每次迭代的过程里都会保存一个字符,范围从 <code>a ~ z :</code></p>
<pre><code>
for i in {a..z}; do actions; done;
</code></pre><p>for 循环也可以采用C语言中 for 循环的格式。例如:</p>
<pre><code>for((i=0;i&lt;10;i++))
{
    commands; #使用变量$i
}
</code></pre><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><pre><code>while condition
do
    commands;
done
</code></pre><p>用 true 作为循环条件能够产生无限循环。</p>
<h3 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h3><p>在Bash中还可以使用一个特殊的循环 until 。它会一直执行循环,直到给定的条件为真。<br>例如:</p>
<pre><code>
x=0;
until [ $x -eq 9 ]; #条件是[$x -eq 9 ]
do
    let x++; echo $x;
done
</code></pre>]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDE系列]]></title>
      <url>/2017/05/07/IDE%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<h1 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a>JetBrains</h1><blockquote>
<p>我所见过的最好的IDE，没有之一。</p>
</blockquote>
<a id="more"></a>
<p><img src="http://img.blog.csdn.net/20170605113013811?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc4MDM0OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="支持的语言"><br> 网址：<a href="https://www.jetbrains.com/products.html?fromMenu" target="_blank" rel="external">jetbrains</a></p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ol>
<li>地址：<a href="https://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="external">pycharm</a></li>
<li>激活：<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2></li>
<li>地址：<a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="external">IntelliJ IDEA</a></li>
<li>激活：<a href="http://www.cnblogs.com/suiyueqiannian/p/6754091.html" target="_blank" rel="external">http://www.cnblogs.com/suiyueqiannian/p/6754091.html</a> (2017-6-6测试可用)<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2></li>
<li>地址：<a href="https://www.jetbrains.com/clion/download/#section=linux" target="_blank" rel="external">CLion</a></li>
<li>激活：<a href="http://xclient.info/a/f0b9738a-36fd-8a97-a966-0d3db497092d.html" target="_blank" rel="external">http://xclient.info/a/f0b9738a-36fd-8a97-a966-0d3db497092d.html</a>  (2017-6-6测试可用)<h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2></li>
<li>地址：<a href="https://www.jetbrains.com/go/download/#section=linux" target="_blank" rel="external">golang</a></li>
<li>激活：<h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2></li>
<li>地址：<a href="http://color-themes.com/?view=index" target="_blank" rel="external">主题地址</a></li>
<li>推荐主题：（1）. <code>Sublime Text 2</code> （2）. <code>Monokai Sublime Text 3</code></li>
<li>详细教程：<a href="http://blog.csdn.net/simple_the_best/article/details/46941787" target="_blank" rel="external">地址</a></li>
</ol>
<h1 id="得良说"><a href="#得良说" class="headerlink" title="得良说"></a>得良说</h1><ol>
<li>能够熟练使用一个好的IDE，会大幅提高你的工作效率，不用为一些无关紧要的事情浪费时间。就比如这个jetbrains系列，是我见过的最好的ide系列，挺全的常用的语言基本都有，而且风格都一样，你熟练了一种，其他的自然无师自通。</li>
<li>我觉的比较赞 的功能：<pre><code> 1. 可以同步git，简单粗暴
 2. 各种包直接搜索安装，简单粗暴
 3. 多种语言，一个风格，简单粗暴
 4. 竟然支持markdown实时预览，哇这个功能是真的6,6的飞起 
 5. debug超级方便，简单粗暴
 6. 各种漂亮主题直接下载导入，简单粗暴外加漂亮
</code></pre></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 开发工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDE </tag>
            
            <tag> 敏捷开发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell正则]]></title>
      <url>/2017/05/05/shell%E6%AD%A3%E5%88%99/</url>
      <content type="html"><![CDATA[<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>1.特定字符</p>
<pre><code>&#39;a&#39;
</code></pre><p>2.范围内字符 </p>
<pre><code>[]单个字符
数字字符:[0-9],[259]
小写字母:[a-z]
大写字母:[A-Z]
符号:[,;:]
取反:[^0-9]
</code></pre><p>3.任意字符</p>
<pre><code>.:单个任意字符(注意:[.]和\.  , 这里就只表示点)
</code></pre><h2 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h2><p>1.边界字符:头尾字符</p>
<pre><code>^: ^root 表示以root开头的行
$: false$ 表示以false结束的行

空行的表示: ^$
</code></pre><p>2.元字符(代表普通字符或者特殊字符)</p>
<pre><code>
\w: 匹配任何字类字符,包括下划线([A-Za-z0-9_])
\W: 匹配任何非字类字符([^A-Za-z0-9_])
\b: 单词的分隔(不只是空格或者制表符)
dear@dear3442:~/code/sh$ egrep &#39;\b[0-9]+\b&#39; passwd 
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><code>&#39;asdf&#39;</code> ,<code>&#39;asdf&#39;</code></li>
<li><code>[0-9][0-9][0-9]</code>,<code>[a-z][a-z][a-z]</code></li>
<li><p>重复,逻辑</p>
<p> 重复:</p>
<pre><code> 1. *:零次或者多次 匹配前面的字符或子表达式
 2. \+:一次或者多次 匹配前面的字符或子表达式(注意grep使用的时候,要用 \+ )
 3. \?:零次或者一次 匹配前面的字符或子表达式(注意grep使用的时候,要用 \? )
 4. \{n,m\}: 重复n次到m次
</code></pre><p> 分组:</p>
<pre><code> $ grep &#39;\(se\)*&#39; test.txt #表示匹配se多次
</code></pre><p> 任意字符串:</p>
<pre><code> $ grep &#39;.*&#39; test.txt #可能会贪婪匹配
</code></pre><p> 逻辑:</p>
<pre><code> 1. 逻辑或: | : &#39;/bin/\(false\|true\)&#39;
</code></pre></li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol>
<li>4-10位的QQ号</li>
</ol>
<pre><code class="shell">grep &#39;^[0-9]\{4-10\}$&#39; qq.txt
</code></pre>
<p>2.匹配密码(有数字,26个字母和下划线组成)</p>
<pre><code>grep &#39;^\w\+$&#39; qq.txt
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="http://function.dearamaze.com/shell%E6%AD%A3%E5%88%99%E6%80%BB%E7%BB%93.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python多线程之threading模块]]></title>
      <url>/2017/04/23/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bthreading%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<h1 id="threading-模块"><a href="#threading-模块" class="headerlink" title="threading 模块"></a>threading 模块</h1><h2 id="使用threading模块-mtsleepC-py"><a href="#使用threading模块-mtsleepC-py" class="headerlink" title="使用threading模块(mtsleepC.py)"></a>使用threading模块(mtsleepC.py)</h2><p>threading模块的Thread类有一个join()方法,可以让主线程等待所有线程执行完毕</p>
<pre><code>#!/usr/bin/env python
# coding=utf-8

import threading
from time import sleep,ctime

loops=[4,2]

def loop(nloop,nsec):
    print &#39;start loop:&#39;,nloop,&#39; done at:&#39;,ctime()
    sleep(nsec)
    print &#39;loop&#39;,nloop,&#39;done at:&#39;,ctime()
def main():
    print &#39;starting at:&#39;,ctime()
    threads=[]
    nloops=range(len(loops))

    for i in nloops:
        t=threading.Thread(target=loop,args=(i,loops[i]))
        threads.append(t)

    for i in nloops:
        threads[i].start()

    for i in nloops:
        threads[i].join()

    print &#39;all DONE at:&#39;,ctime()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre><h2 id="子类化的Thread-mtsleepE-py"><a href="#子类化的Thread-mtsleepE-py" class="headerlink" title="子类化的Thread(mtsleepE.py)"></a>子类化的Thread(mtsleepE.py)</h2><p>本例对Thread子类化,而不是直接对其实例化,这将使我们在定制线程对象是拥有更多的灵活性,也能够简化线程调用的过程.</p>
<pre><code>#!/usr/bin/env python
# coding=utf-8

import threading 
from time import sleep ,ctime

loops=(4,2)

class MyThread(threading.Thread):
    def __init__(self,func,args,name=&#39;&#39;):
        threading.Thread.__init__(self)
        self.name = name 
        self.func = func 
        self.args = args 

    def run(self):
        self.func(*self.args)

def loop(nloop,nsec):
    print &#39;start loop&#39;,nloop,&#39;at:&#39;,ctime()
    sleep(nsec)
    print &#39;loop&#39;,nloop,&#39;done at:&#39;,ctime()

def main():
    print &#39;starting at:&#39;,ctime()
    threads  = []
    nloops=range(len(loops))

    for i in nloops:
        t=MyThread(loop,(i,loops[i]),loop.__name__)
        threads.append(t)

    for i in nloops:
        threads[i].start()

    for i in nloops:
        threads[i].join()

    print &#39;all DONE at:&#39;,ctime()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[python多线程]]></title>
      <url>/2017/04/22/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="thread-模块"><a href="#thread-模块" class="headerlink" title="thread 模块"></a>thread 模块</h1><h2 id="使用单线程执行循环"><a href="#使用单线程执行循环" class="headerlink" title="使用单线程执行循环"></a>使用单线程执行循环</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><pre><code class="python">
#!/usr/bin/env python
# coding=utf-8

from time import sleep , ctime 

def loop0():
    print &#39;start loop 0 at : &#39;, ctime()
    sleep(4)
    print &#39;loop 0 done ate : &#39;, ctime()

def loop1():
    print &#39;start loop 1 at : &#39;, ctime()
    sleep(2)
    print &#39;loop 1 done ate : &#39;, ctime()

def main():
    print &quot;starting at : &quot;,ctime()
    loop0()
    loop1()
    print &quot;all DONE at : &quot;,ctime()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果:"></a>执行结果:</h3><blockquote>
<p><code>顺序执行</code></p>
</blockquote>
<p><img src="http://function.dearamaze.com/onethr_run.png" alt="运行结果,顺序执行"></p>
<h2 id="使用thread模块-mtsleepA-py"><a href="#使用thread模块-mtsleepA-py" class="headerlink" title="使用thread模块(mtsleepA.py)"></a>使用thread模块(mtsleepA.py)</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="python">#!/usr/bin/env python
# coding=utf-8

import thread 
from time import sleep , ctime 

def loop0():
    print &#39;start loop 0 at : &#39;,ctime()
    sleep(4)
    print &#39;loop 0 done at : &#39;,ctime()

def loop1():
    print &#39;start loop 1 at :&#39;,ctime()
    sleep(2)
    print &#39;loop 1 done at :&#39;,ctime()

def main():
    print &#39;starting at :&#39;,ctime()
    thread.start_new_thread(loop0,())
    thread.start_new_thread(loop1,())
    sleep(6)
    print &#39;all done at :&#39;,ctime()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p><code>并行执行</code></p>
</blockquote>
<p><img src="http://function.dearamaze.com/mtsleepA.png" alt="执行结果,并行执行"></p>
<h2 id="修改mtsleepA-py-后"><a href="#修改mtsleepA-py-后" class="headerlink" title="修改mtsleepA.py 后"></a>修改mtsleepA.py 后</h2><pre><code class="python">#!/usr/bin/env python
# coding=utf-8

import thread 
from time import sleep , ctime 

def loop0():
    print &#39;start loop 0 at : &#39;,ctime()
    sleep(4)
    print &#39;loop 0 done at : &#39;,ctime()

def loop1():
    print &#39;start loop 1 at :&#39;,ctime()
    sleep(2)
    print &#39;loop 1 done at :&#39;,ctime()

def main():
    print &#39;starting at :&#39;,ctime()
    thread.start_new_thread(loop0,())
    thread.start_new_thread(loop1,())
    #sleep(6)
    print &#39;all done at :&#39;,ctime()

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p>注释掉了主线程中的sleep函数,发生了什么,反映了什么?</p>
<h3 id="执行结果-2"><a href="#执行结果-2" class="headerlink" title="执行结果"></a>执行结果</h3><blockquote>
<p><code>子线程隶属于父线程,父线程生命周期结束时,子线程也会结束.</code></p>
</blockquote>
<p><img src="http://function.dearamaze.com/mtsleepA_run2.png" alt="执行结果,主线程会强制结束子线程"></p>
<h2 id="使用线程和锁-mtsleepB-py"><a href="#使用线程和锁-mtsleepB-py" class="headerlink" title="使用线程和锁 (mtsleepB.py)"></a>使用线程和锁 (mtsleepB.py)</h2><pre><code class="python">#!/usr/bin/env python
# coding=utf-8

import thread 
from time import sleep , ctime 

loops = [4,2]

def loop(nloop,nsec,lock):
    print &#39;start loop &#39;,nloop,&#39;at:&#39;,ctime()
    sleep(nsec)
    print &#39;loop &#39;,nloop ,&#39;done at :&#39;,ctime()
    lock.release()

def main():
    print &#39;starting at:&#39;,ctime()
    locks=[]
    nloops = range(len(loops))

    #为线程创建锁
    for i in nloops:
        lock = thread.allocate_lock()
        lock.acquire()
        locks.append(lock)

    #开始执行各个线程
    for i in nloops:
        thread.start_new_thread(loop,(i,loops[i],locks[i]))

    #主线程等待所有的线程的锁完全释放
    for i in nloops:
        while locks[i].locked():pass

    print &#39;all DONE at:&#39;,ctime()

if __name__ == &#39;__main__&#39; :
    main()
</code></pre>
<h3 id="执行结果-3"><a href="#执行结果-3" class="headerlink" title="执行结果:"></a>执行结果:</h3><p><img src="http://function.dearamaze.com/mtsleepB.png" alt="线程锁"></p>
]]></content>
      
        <categories>
            
            <category> python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核模块编程]]></title>
      <url>/2017/04/21/Linux%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[运维面试题整理]]></title>
      <url>/2017/04/16/%E8%BF%90%E7%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<ol>
<li>linux如何挂在windows下的共享目录</li>
</ol>
<pre><code class="Shell">mount.cifs //192.168.1.3/server /mnt/server -o user=administrator,pass=123456
</code></pre>
<p>linux 下的server需要自己手动建一个  后面的user与pass 是windows主机的账号和密码 注意空格 和逗号</p>
<ol>
<li>查看http的并发请求数与其TCP连接状态</li>
</ol>
<pre><code class="Shell">netstat -n | awk &#39;/^tcp/ {++b[$NF]} END {for(a in b) print a, b[a]}&#39;
</code></pre>
<p>还有<code>ulimit -n</code>查看linux系统打开最大的文件描述符，这里默认1024，不修改这里web服务器修改再大也没用。若要用就修改很几个办法，这里说其中一个：<br>修改<code>/etc/security/limits.conf</code></p>
<pre><code class="Shell">* soft nofile 10240
* hard nofile 10240
</code></pre>
<p>重启后生效</p>
<ol>
<li>用<code>tcpdump</code>嗅探80端口的访问看看谁最高</li>
</ol>
<pre><code class="Shell">tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F&quot;.&quot; &#39;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#39; | sort | uniq -c | sort -nr |head -5 ;
</code></pre>
<ol>
<li>查看<code>/var/log</code>目录下文件数</li>
</ol>
<pre><code>ls /var/log/ -lR| grep &quot;^-&quot; |wc -l
</code></pre><ol>
<li>查看当前系统每个IP的连接数</li>
</ol>
<pre><code class="Shell">
netstat -n | awk &#39;/^tcp/ {print $5}&#39;| awk -F: &#39;{print $1}&#39; | sort | uniq -c | sort -rn
</code></pre>
<ol>
<li>shell下32位随机密码生成</li>
</ol>
<pre><code class="Shell">
cat /dev/urandom | head -1 | md5sum | head -c 32 &gt;&gt; /pass
</code></pre>
<p>将生成的32位随机数 保存到/pass文件里了</p>
<ol>
<li>统计出<code>apache</code>的<code>access.log</code>中访问量最多的5个IP</li>
</ol>
<pre><code class="Shel">cat access_log | awk  &#39;{print $1}&#39; | sort | uniq -c | sort -n -r | head -5
</code></pre>
<ol>
<li>如何查看二进制文件的内容</li>
</ol>
<p>我们一般通过<code>hexdump</code>命令 来查看二进制文件的内容。<br><code>hexdump -C XXX(文件名)</code>  -C是参数 不同的参数有不同的意义<br>-C  是比较规范的 十六进制和ASCII码显示<br>-c  是单字节字符显示<br>-b  单字节八进制显示<br>-o  是双字节八进制显示<br>-d  是双字节十进制显示<br>-x  是双字节十六进制显示<br>等等等等</p>
<ol>
<li><code>ps aux</code> 中的<code>VSZ</code>代表什么意思，<code>RSS</code>代表什么意思</li>
</ol>
<p>VSZ:虚拟内存集,进程占用的虚拟内存空间<br>RSS:物理内存集,进程占用的实际物理内存空间</p>
<ol>
<li>检测并修复<code>/dev/hda5</code></li>
</ol>
<p><code>fsck</code>用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查,用法：</p>
<ol>
<li>Linux系统的开机启动顺序</li>
</ol>
<p>加载BIOS–&gt;读取MBR–&gt;Boot Loader–&gt;加载内核–&gt;用户层init一句inittab文件来设定系统运行的等级(一般3或者5，3是多用户命令行，5是界面)–&gt;init进程执行rc.syninit–&gt;启动内核模块–&gt;执行不同级别运行的脚本程序–&gt;执行/etc/rc.d/rc.local(本地运行服务)–&gt;执行/bin/login,就可以登录了。</p>
<ol>
<li>符号链接与硬链接的区别</li>
</ol>
<p>我们可以把符号链接，也就是软连接 当做是 windows系统里的 快捷方式。<br>硬链接 就好像是 又复制了一份.<br><code>ln 3.txt 4.txt</code>  这是硬链接，相当于复制，不可以跨分区，但修改3,4会跟着变，若删除3,4不受任何影响。<br><code>ln -s 3.txt 4.txt</code>  这是软连接，相当于快捷方式。修改4,3也会跟着变，若删除3,4就坏掉了。不可以用了。</p>
<ol>
<li>保存当前磁盘分区的分区表</li>
</ol>
<p>dd 命令是以个强大的命令，在复制的同时进行转换</p>
<pre><code class="Shell">dd if=/dev/sda of=./mbr.txt bs=1 count=512
</code></pre>
<ol>
<li>如何在文本里面进行复制、粘贴，删除行，删除全部，按行查找和按字母查找。</li>
</ol>
<p>以下操作全部在命令行状态操作，不要在编辑状态操作。<br>在文本里 移动到想要复制的行  按yy  想复制到哪就移动到哪，然后按P  就黏贴了<br>删除行  移动到改行 按dd<br>删除全部  dG  这里注意G一定要大写<br>按行查找  :90 这样就是找到第90行<br>按字母查找 /path  这样就是 找到path这个单词所在的位置，文本里可能存在多个,多次查找会显示在不同的位置。 </p>
<ol>
<li>手动安装grub</li>
</ol>
<pre><code class="Shell">grub-install /dev/sda
</code></pre>
<ol>
<li>修改内核参数<pre><code>vi /etc/sysctl.conf  这里修改参数
sysctl -p  刷新后可用
</code></pre></li>
<li>在1-39内取随机数</li>
</ol>
<pre><code class="Shell">expr $[$RANDOM%39] + 1
</code></pre>
<p>RANDOM 随机数<br>%39 取余数 范围 0-38</p>
<ol>
<li>限制apache每秒新建连接数为1，峰值为3</li>
</ol>
<p>每秒新建连接数 一般都是由防火墙来做，apache本身好像无法设置每秒新建连接数，只能设置最大连接：</p>
<pre><code class="Shell">iptables -A INPUT -d 172.16.100.1 -p tcp --dport 80 -m limit --limit 1/second  -j ACCEPT
</code></pre>
<p>硬件防火墙设置更简单，有界面化，可以直接填写数字。。。<br>最大连接 apache本身可以设置<br>MaxClients 3  ,修改apache最大连接 前提还是要修改系统默认tcp连接数。我博客里也说了，这就不说了。</p>
<ol>
<li>FTP的主动模式和被动模式</li>
</ol>
<p>FTP协议有两种工作方式：PORT方式和PASV方式，中文意思为主动式和被动式。<br>PORT（主动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请 求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT 命令告诉服务器：“我打开了XX端口，你过来连接我”。于是服务器从20端口向客户端的 XX端口发送连接请求，建立一条数据链路来传送数据。<br>PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请 求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV 命令告诉客户端：“我打开了XX端口，你过来连接我”。于是客户端向服务器的XX端口 发送连接请求，建立一条数据链路来传送数据。<br>从上面可以看出，两种方式的命令链路连接方法是一样的，而数据链路的建立方法就完 全不同。</p>
<ol>
<li>显示<code>/etc/inittab</code>中以#开头，且后面跟了一个或者多个空白字符，而后又跟了任意非空白字符的行</li>
</ol>
<pre><code class="Shell">grep &quot;^# \{1,\}[^ ]&quot; /etc/inittab
</code></pre>
<ol>
<li>显示/etc/inittab中包含了:一个数字:(即两个冒号中间一个数字)的行</li>
</ol>
<pre><code class="Shell">grep &quot;\:[0-9]\{1\}\:&quot; /etc/inittab
</code></pre>
<ol>
<li>怎么把脚本添加到系统服务里，即用service来调用</li>
</ol>
<p>在脚本里加入</p>
<pre><code class="Shell">#!/bin/bash
# chkconfig: 345 85 15
# description: httpd
</code></pre>
<p>然后保存<br>chkconfig httpd –add  创建系统服务<br>现在就可以使用service 来 start or restart</p>
<ol>
<li>写一个脚本，实现批量添加20个用户，用户名为user01-20，密码为user后面跟5个随机字符</li>
</ol>
<pre><code class="Shell">#!/bin/bash
#description: useradd
for i in `seq -f&quot;%02g&quot; 1 20`;do
useradd user$i
echo &quot;user$i-`echo $RANDOM|md5sum|cut -c 1-5`&quot;|passwd –stdinuser$i &gt;/dev/null 2&gt;&amp;1
done
</code></pre>
<ol>
<li>写一个脚本，实现判断192.168.1.0/255网络里，当前在线的IP有哪些，能ping通则认为在线</li>
</ol>
<blockquote>
<p>Shell多线程</p>
</blockquote>
<pre><code class="Shell">
#!/bin/bash
for ip in `seq 1 255`
  do
    {
     ping -c 1 192.168.1.$ip &gt; /dev/null 2&gt;&amp;1
     if [ $? -eq 0 ]; then
          echo 192.168.1.$ip UP
     else
          echo 192.168.1.$ip DOWN
     fi
   }&amp;
done
wait
</code></pre>
<ol>
<li>写一个脚本，判断一个指定的脚本是否是语法错误；如果有错误，则提醒用户键入Q或者q无视错误并退出其它任何键可以通过vim打开这个指定的脚本</li>
</ol>
<pre><code class="Shell">[root@localhost  tmp]# cat checksh.sh
 #!/bin/bash
 read -p &quot;please input check script-&gt; &quot; file
 if [ -f $file ]; then
    sh -n $file &gt; /dev/null 2&gt;&amp;1
    if [ $? -ne 0 ]; then
        read -p &quot;You input $file syntax error,[Type q to exit or Type vim to  edit]&quot; answer
        case $answer in
        q | Q)
           exit 0
           ;;
        vim )
           vim $file
           ;;
        *）
         exit 0
         ;;
        esac
   fi
 else
    echo &quot;$file not exist&quot;
    exit 1
 fi
</code></pre>
<ol>
<li>写一个脚本：(26包括3个小题)</li>
</ol>
<p>1、创建一个函数，能接受两个参数：<br>1)第一个参数为URL，即可下载的文件；第二个参数为目录，即下载后保存的位置；<br>2)如果用户给的目录不存在，则提示用户是否创建；如果创建就继续执行，否则，函数返回一个51的错误值给调用脚本；<br>3)如果给的目录存在，则下载文件；下载命令执行结束后测试文件下载成功与否；如果成功，则返回0给调用脚本，否则，返回52给调用脚本；</p>
<pre><code class="Shell">[root@localhost tmp]# cat downfile.sh
#!/bin/bash
url=$1
dir=$2
download()
  {
    cd $dir &gt;&gt; /dev/null 2&gt;&amp;1
    if [ $? -ne 0 ];then
        read -p &quot;$dir No such file or directory,create?(y/n)&quot; answer
        if [ &quot;$answer&quot; == &quot;y&quot; ];then
            mkdir -p $dir
            cd $dir
            wget $url 1&gt; /dev/null 2&gt;&amp;1
        else
            return &quot;51&quot;
        fi
    fi
    if [ $? -ne 0 ]; then
        return &quot;52&quot;
    fi
}
download $url $dir
echo $?
</code></pre>
<ol>
<li>写一个脚本：（27包括2个小题）</li>
</ol>
<p>1、创建一个函数，可以接受一个磁盘设备路径（如<code>/dev/sdb</code>）作为参数;在真正开始后面步骤之前提醒用户有危险，并让用户选择是否继续；而后将此磁盘设备上的所有分区清空（提示，使用命令<code>dd if=/dev/zero of=/dev/sdb bs=512 count=1</code>实现，注意其中的设备路径不要写错了；<br>如果此步骤失败，返回67给主程序；<br>接着在此磁盘设备上创建两个主分区，一个大小为100M，一个大小为1G；如果此步骤失败，返回68给主程序；<br>格式化此两分区，文件系统类型为ext3；如果此步骤失败，返回69给主程序；<br>如果上述过程都正常，返回0给主程序；<br>2、调用此函数；并通过接收函数执行的返回值来判断其执行情况，并将信息显示出来；</p>
<pre><code class="Shell">local Darray=(`ls /dev/sd[a-z]`)
for i in ${Darray};do
  [[ &quot;$i&quot; == &quot;$1&quot; ]] &amp;&amp; Sd=$i &amp;&amp;break
done
  else
  return66
  fi
#当匹配成功，进入选择，告诉用户，是否继续，输错的话进入无限循环，当用户选择Y,则清空目标分区，且跳出while循环
while :;do
    read -p &quot;Warning!!!This operation will clean $Sd data.Next=y,Quit=n [y|n]:&quot; Choice
    case $Choice in
y)
   dd if=/dev/zero of=$Sd bs=512 count=1 &amp;&gt; /dev/null &amp;&amp;break || return 67 ;;
n)
   exit 88 ;;
*)
   echo &quot;Invalid choice,please choice again.&quot; ;;
esac
done
#使用echo传递给fdisk进行分区，如果此命令失败，则跳转出去，错误值68，需要注意的是，有时候这个返回值很诡异，笔者之前成功与否都是返回的1，后来重启之后，就好了，如果慎重的话，可以对创建的分区，进行判断，不过就需要使用其他工具截取相关字段了，虽有些小麻烦，但无大碍
</code></pre>
<pre><code class="Shell">echo-e &quot;n\np\n1\n\n+100M\nn\np\n2\n\n+1024M\nw\n&quot;|fdisk /dev/sdb&amp;&gt; /dev/null || return 68
#格式化之前，让内核重新读取磁盘分区表，值得注意的是，有的系统版本，使用partprobe无效，譬如笔者的环境是rhel5.8，而rhel6.0以后，这个命令就很危险了，而使用partx -a /dev/sdb则效果更好…此项需慎重，如果格式化失败，则告知把失败的分区定义成变量，且跳出函数，并带出错误值69
</code></pre>
<pre><code class="Shell">`partprobe`
Part=`fdisk -l /dev/$Sd|tail -2|cut -d” ” -f1`
for M in ${Part};do
   mke2fs -j $M &amp;&gt; /dev/null &amp;&amp; ErrorPart=$M &amp;&amp;return 69
done
  return 0
}
</code></pre>
<pre><code class="Shell">#下面代码，调用函数，接收函数返回值，根据返回值进行判断哪里出错。

Disk_Mod $1
Res=$?
[ $Res-eq 0 ] &amp;&amp; exit 0
[ $Res-eq 66 ] &amp;&amp; echo &quot;Error! Invalid input.&quot;
[ $Res-eq 67 ] &amp;&amp; echo &quot;Error! Command -&gt; dd &lt;- Faild.&quot;
[ $Res-eq 68 ] &amp;&amp; echo &quot;Error! Command -&gt; fdisk &lt;- Faild.&quot;
[ $Res-eq 69 ] &amp;&amp; echo &quot;Error! Command -&gt; mke2fs &lt;- Faild.&quot;
</code></pre>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务器搭建之路]]></title>
      <url>/2017/04/13/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<ul>
<li><p><a href="https://linux.cn/article-2436-1.html" target="_blank" rel="external">Linux下Nagios的安装与配置</a></p>
</li>
<li><p><a href="http://blog.topspeedsnail.com/archives/3049" target="_blank" rel="external">在Ubuntu上安装配置Ganglia</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 服务器搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 监控工具 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内核内存池-mempool]]></title>
      <url>/2017/04/07/%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E6%B1%A0-mempool/</url>
      <content type="html"><![CDATA[<blockquote>
<p><code>内存池(Memery Pool)</code>技术是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。 </p>
</blockquote>
<p>不仅在用户态应用程序中被广泛使用，同时在Linux内核也被广泛使用，在内核中有不少地方内存分配不允许失败。作为一个在这些情况下确保分配的方式，内核开发者创建了一个已知为内存池(或者是 “mempool” )的抽象，内核中内存池真实地只是相当于后备缓存，它尽力一直保持一个空闲内存列表给紧急时使用，而在通常情况下有内存需求时还是从公共的内存中直接分配，这样的做法虽然有点霸占内存的嫌疑，但是可以从根本上保证关键应用在内存紧张时申请内存仍然能够成功。</p>
<p>下面看下内核内存池的源码，内核内存池的源码在中，实现上非常简洁，描述内存池的结构mempool_t在头文件中定义，结构描述如下：</p>
<pre><code class="C">typedef struct mempool_s {
    spinlock_t lock; /*保护内存池的自旋锁*/
    int min_nr; /*内存池中最少可分配的元素数目*/
    int curr_nr; /*尚余可分配的元素数目*/
    void **elements; /*指向元素池的指针*/
    void *pool_data; /*内存源，即池中元素真实的分配处*/
    mempool_alloc_t *alloc; /*分配元素的方法*/
    mempool_free_t *free; /*回收元素的方法*/
    wait_queue_head_t wait; /*被阻塞的等待队列*/
} mempool_t;
</code></pre>
<p>内存池的创建函数mempool_create的函数原型如下：</p>
<pre><code class="C">mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
                mempool_free_t *free_fn, void *pool_data)
{
    return mempool_create_node(min_nr,alloc_fn,free_fn, pool_data,-1);
}
</code></pre>
<p>函数原型指定内存池可以容纳元素的个数、申请元素的方法、释放元素的方法，以及一个可选的内存源(通常是一个cache)，内存池对象创建完成后会自动调用alloc方法从pool_data上分配min_nr个元素用来填充内存池。<br>内存池的释放函数mempool_destory函数的原型很简单，应该也能猜到是依次将元素对象从池中移除，再释放给pool_data，最后释放池对象，如下：</p>
<pre><code class="C">void mempool_destroy(mempool_t *pool)
{
    while (pool-&gt;curr_nr) {
        void *element = remove_element(pool);
        pool-&gt;free(element, pool-&gt;pool_data);
    }
    kfree(pool-&gt;elements);
    kfree(pool);
}
</code></pre>
<p>值得注意的是内存池分配和回收对象的函数：mempool_alloc和mempool_free。mempool_alloc的作用是从指定的内存池中申请/获取一个对象，函数原型如下：</p>
<pre><code class="C">void * mempool_alloc(mempool_t *pool, gfp_t gfp_mask){
......
    element = pool-&gt;alloc(gfp_temp, pool-&gt;pool_data);
    if (likely(element != NULL))
        return element;

    spin_lock_irqsave(&amp;pool-&gt;lock, flags);
    if (likely(pool-&gt;curr_nr)) {
        element = remove_element(pool);/*从内存池中提取一个对象*/
        spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);
        /* paired with rmb in mempool_free(), read comment there */
        smp_wmb();
        return element;
    }
......
}
</code></pre>
<p>函数先是从pool_data中申请元素对象，当从pool_data无法成功申请到时，才会从池中提取对象使用，因此可以发现内核内存池mempool其实是一种后备池，在内存紧张的情况下才会真正从池中获取，这样也就能保证在极端情况下申请对象的成功率，单也不一定总是会成功，因为内存池的大小毕竟是有限的，如果内存池中的对象也用完了，那么进程就只能进入睡眠，也就是被加入到pool-&gt;wait的等待队列，等待内存池中有可用的对象时被唤醒，重新尝试从池中申请元素：</p>
<pre><code class="C">    init_wait(&amp;wait);
    prepare_to_wait(&amp;pool-&gt;wait, &amp;wait, TASK_UNINTERRUPTIBLE);
    spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);
    io_schedule_timeout(5*HZ);
    finish_wait(&amp;pool-&gt;wait, &amp;wait);
</code></pre>
<p>池回收对象的函数mempool_free的原型如下：</p>
<pre><code class="C">void mempool_free(void *element, mempool_t *pool)
{
    if (pool-&gt;curr_nr min_nr) {
        spin_lock_irqsave(&amp;pool-&gt;lock, flags);
        if (pool-&gt;curr_nr min_nr) {
            add_element(pool, element);
            spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);
            wake_up(&amp;pool-&gt;wait);
            return;
        }
        spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);
        }
    pool-&gt;free(element, pool-&gt;pool_data);
}
</code></pre>
<p>其实原则跟mempool_alloc是对应的，释放对象时先看池中的可用元素是否充足(pool-&gt;curr_nr == pool-&gt;min_nr)，如果不是则将元素对象释放回池中，否则将元素对象还给pool-&gt;pool_data。<br>    此外mempool也提供或者说指定了几对alloc/free函数，及在mempool_create创建池时必须指定的alloc和free函数，分别适用于不同大小或者类型的元素的内存池，具体如下：</p>
<pre><code class="C">void *mempool_alloc_slab(gfp_t gfp_mask, void *pool_data)
{
    struct kmem_cache *mem = pool_data;
    return kmem_cache_alloc(mem, gfp_mask);
}
void mempool_free_slab(void *element, void *pool_data)
{
    struct kmem_cache *mem = pool_data;
    kmem_cache_free(mem, element);
}

void *mempool_kmalloc(gfp_t gfp_mask, void *pool_data)
{
    size_t size = (size_t)pool_data;
    return kmalloc(size, gfp_mask);
}
void mempool_kfree(void *element, void *pool_data)
{
    kfree(element);
}

void *mempool_alloc_pages(gfp_t gfp_mask, void *pool_data)
{
    int order = (int)(long)pool_data;
    return alloc_pages(gfp_mask, order);
}
void mempool_free_pages(void *element, void *pool_data)
{
    int order = (int)(long)pool_data;
    __free_pages(element, order);
}
</code></pre>
<p>总体上来讲mempool的实现很简约，但是不简单，而且非常轻便易用，这也是内核奥妙之所在。</p>
<p><a href="http://blog.chinaunix.net/uid-27714502-id-3335217.html" target="_blank" rel="external">原文地址</a></p>
]]></content>
      
        <categories>
            
            <category> linux系统知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 内核 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[块设备驱动详解]]></title>
      <url>/2017/04/06/%E5%9D%97%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="块设备与字符设备的区别"><a href="#块设备与字符设备的区别" class="headerlink" title="块设备与字符设备的区别"></a>块设备与字符设备的区别</h1><p>1、 从字面上理解，块设备和字符设备最大的区别在于<code>读写数据的基本单元</code>不同。<br><code>块设备</code>读写数据的基本单元为块，例如磁盘通常为一个sector，而<code>字符设备</code>的基本单元为字节。<br>所以Linux中块设备驱动往往为磁盘设备的驱动，但是由于磁盘设备的IO性能与CPU相比很差，因此，块设备的数据流往往会引入文件系统的Cache机制。</p>
<p>2、 从实现角度来看，Linux为块设备和字符设备提供了两套机制。</p>
<p><code>字符设备</code>实现的比较简单，内核例程和用户态API一一对应，用户层的Read函数直接对应了内核中的Read例程，这种映射关系由字符设备的file_operations维护。<br><code>块设备</code>接口相对于字符设备复杂，read、write API没有直接到块设备层，而是直接到文件系统层，然后再由文件系统层发起读写请求。</p>
<h1 id="块设备读写流程"><a href="#块设备读写流程" class="headerlink" title="块设备读写流程"></a>块设备读写流程</h1><p>在学习块设备原理的时候，我最关系块设备的数据流程，从应用程序调用Read或者Write开始，数据在内核中到底是如何流通、处理的呢？然后又如何抵达具体的物理设备的呢？下面对一个带Cache功能的块设备数据流程进行分析。</p>
<p>1、 用户态程序通过open()打开指定的块设备，通过systemcall机制陷入内核，执行blkdev_open()函数，该函数注册到文件系统方法（file_operations）中的open上。在blkdev_open函数中调用bd_acquire()函数，bd_acquire函数完成文件系统inode到块设备bdev的转换，具体的转换方法通过hash查找实现。得到具体块设备的bdev之后，调用do_open()函数完成设备打开的操作。在do_open函数中会调用到块设备驱动注册的open方法，具体调用如下：gendisk-&gt;fops-&gt;open(bdev-&gt;bd_inode, file)。</p>
<p>2、 用户程序通过read、write函数对设备进行读写，文件系统会调用相应的方法，通常会调用如下两个函数：generic_file_read和blkdev_file_write。在读写过程中采用了多种策略，首先分析读过程。</p>
<p>3、 用户态调用了read函数，内核执行generic_file_read，如果不是direct io方式，那么直接调用do_generic_file_read-&gt;do_generic_mapping_read()函数，在do_generic_mapping_read（函数位于filemap.c）函数中，首先查找数据是否命中Cache，如果命中，那么直接将数据返回给用户态；否则通过address_space-&gt;a_ops-&gt;readpage函数发起一个真实的读请求。在readpage函数中，构造一个buffer_head，设置bh回调函数end_buffer_async_read，然后调用submit_bh发起请求。在submit_bh函数中，根据buffer_head构造bio，设置bio的回调函数end_bio_bh_io_sync，最后通过submit_bio将bio请求发送给指定的快设备。</p>
<p>4、 如果用户态调用了一个write函数，内核执行blkdev_file_write函数，如果不是direct io操作方式，那么执行buffered write操作过程，直接调用generic_file_buffered_write函数。Buffered write操作方法会将数据直接写入Cache，并进行Cache的替换操作，在替换操作过程中需要对实际的快设备进行操作，address_space-&gt;a_ops提供了块设备操作的方法。当数据被写入到Cache之后，write函数就可以返回了，后继异步写入的任务绝大部分交给了pdflush daemon（有一部分在替换的时候做了）</p>
<p>5、 数据流操作到这一步，我们已经很清楚用户的数据是如何到内核了。与用户最接近的方法是file_operations，每种设备类型都定义了这一方法（由于Linux将所有设备都看成是文件，所以为每类设备都定义了文件操作方法，例如，字符设备的操作方法为def_chr_fops，块设备为def_blk_fops，网络设备为bad_sock_fops）。每种设备类型底层操作方法是不一样的，但是通过file_operations方法将设备类型的差异化屏蔽了，这就是Linux能够将所有设备都理解为文件的缘由。到这里，又提出一个问题：既然这样，那设备的差异化又该如何体现呢？在文件系统层定义了文件系统访问设备的方法，该方法就是address_space_operations，文件系统通过该方法可以访问具体的设备。对于字符设备而言，没有实现address_space_operations方法，也没有必要，因为字符设备的接口与文件系统的接口是一样的，在字符设备open操作的过程中，将inode所指向的file_operations替换成cdev所指向的file_operations就可以了。这样用户层读写字符设备可以直接调用cdev中file_operations方法了。</p>
<p>6、 截至到步骤（4），读操作在没有命中Cache的情况下通过address_space_operations方法中的readpage函数发起块设备读请求；写操作在替换Cache或者Pdflush唤醒时发起块设备请求。发起块设备请求的过程都一样，首先根据需求构建bio结构，bio结构中包含了读写地址、长度、目的设备、回调函数等信息。构造完bio之后，通过简单的submit_bio函数将请求转发给具体的块设备。从这里可以看出，块设备接口很简单，接口方法为submit_bio（更底层函数为generic_make_request），数据结构为struct bio。</p>
<p>7、 submit_bio函数通过generic_make_request转发bio，generic_make_request是一个循环，其通过每个块设备下注册的q-&gt;make_request_fn函数与块设备进行交互。如果访问的块设备是一个有queue的设备，那么会将系统的__make_request函数注册到q-&gt;make_request_fn中；否则块设备会注册一个私有的方法。在私有的方法中，由于不存在queue队列，所以不会处理具体的请求，而是通过修改bio中的方法实现bio的转发，在私有make_request方法中，往往会返回1，告诉generic_make_request继续转发比bio。Generic_make_request的执行上下文可能有两种，一种是用户上下文，另一种为pdflush所在的内核线程上下文。</p>
<p>8、 通过generic_make_request的不断转发，最后请求一定会到一个存在queue队列的块设备上，假设最终的那个块设备是某个scsi disk（/dev/sda）。generic_make_request将请求转发给sda时，调用<strong>make_request，该函数是Linux提供的块设备请求处理函数。在该函数中实现了极其重要的操作，通常所说的IO Schedule就在该函数中实现。在该函数中试图将转发过来的bio merge到一个已经存在的request中，如果可以合并，那么将新的bio请求挂载到一个已经存在request中。如果不能合并，那么分配一个新的request，然后将bio添加到其中。这一切搞定之后，说明通过generic_make_request转发的bio已经抵达了内核的一个站点——request，找到了一个临时归宿。此时，还没有真正启动物理设备的操作。在</strong>make_request退出之前，会判断一个bio中的sync标记，如果该标记有效，说明请求的bio是一个是实时性很强的操作，不能在内核中停留，因此调用了<strong>generic_unplug_device函数，该函数将触发下一阶段的操作；如果该标记无效的话，那么该请求就需要在queue队列中停留一段时间，等到queue队列触发闹钟响了之后，再触发下一阶段的操作。</strong>make_request函数返回0，告诉generic_make_request无需再转发bio了，bio转发结束。</p>
<p>9、 到目前为止，文件系统（pdflush或者address_space_operations）发下来的bio已经merge到request queue中，如果为sync bio，那么直接调用__generic_unplug_device，否则需要在unplug timer的软中断上下文中执行q-&gt;unplug_fn。后继request的处理方法应该和具体的物理设备相关，但是在标准的块设备上如何体现不同物理设备的差异性呢？这种差异性就体现在queue队列的方法上，不同的物理设备，queue队列的方法是不一样的。举例中的sda是一个scsi设备，在scsi middle level将scsi_request_fn函数注册到了queue队列的request_fn方法上。在q-&gt;unplug_fn（具体方法为：generic_unplug_device）函数中会调用request队列的具体处理函数q-&gt;request_fn。Ok，到这一步实际上已经将块设备层与scsi总线驱动层联系在了一起，他们的接口方法为request_fn（具体函数为scsi_request_fn）。</p>
<p>10、明白了第（9）点之后，接下来的过程实际上和具体的scsi总线操作相关了。在scsi_request_fn函数中会扫描request队列，通过elv_next_request函数从队列中获取一个request。在elv_next_request函数中通过scsi总线层注册的q-&gt;prep_rq_fn（scsi层注册为scsi_prep_fn）函数将具体的request转换成scsi驱动所能认识的scsi command。获取一个request之后，scsi_request_fn函数直接调用scsi_dispatch_cmd函数将scsi command发送给一个具体的scsi host。到这一步，有一个问题：scsi command具体转发给那个scsi host呢？秘密就在于q-&gt;queuedata中，在为sda设备分配queue队列时，已经指定了sda块设备与底层的scsi设备（scsi device）之间的关系，他们的关系是通过request queue维护的。</p>
<p>11、 在scsi_dispatch_cmd函数中，通过scsi host的接口方法queuecommand将scsi command发送给scsi host。通常scsi host的queuecommand方法会将接收到的scsi command挂到自己维护的队列中，然后再启动DMA过程将scsi command中的数据发送给具体的磁盘。DMA完毕之后，DMA控制器中断CPU，告诉CPU DMA过程结束，并且在中断上下文中设置DMA结束的中断下半部。DMA中断服务程序返回之后触发软中断，执行SCSI中断下半部。</p>
<p>12、 在SCSi中断下半部中，调用scsi command结束的回调函数，这个函数往往为scsi_done，在scsi_done函数调用blk_complete_request函数结束请求request，每个请求维护了一个bio链，所以在结束请求过程中回调每个请求中的bio回调函数，结束具体的bio。Bio又有文件系统的buffer head生成，所以在结束bio时，回调buffer_head的回调处理函数bio-&gt;bi_end_io（注册为end_bio_bh_io_sync）。自此，由中断引发的一系列回调过程结束，总结一下回调过程如下：scsi_done-&gt;end_request-&gt;end_bio-&gt;end_bufferhead。</p>
<p>13、 回调结束之后，文件系统引发的读写操作过程结束。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx学习]]></title>
      <url>/2017/04/06/nginx%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>##模块<br>按功能划分:</p>
<ol>
<li><p>handles(处理器模块)</p>
</li>
<li><p>filers(过滤器模块)</p>
</li>
<li><p>proxies(代理类模块)</p>
</li>
</ol>
<p><img src="" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[响应码]]></title>
      <url>/2017/04/03/%E5%93%8D%E5%BA%94%E7%A0%81/</url>
      <content type="html"><![CDATA[<p>1XX: 信息<br>2XX: 成功类的状态码<br>3XX: 提示需进一步提供信息的状态码<br>4XX: 客户端错误<br>5XX: 服务端错误</p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用shell]]></title>
      <url>/2017/04/03/%E5%B8%B8%E7%94%A8shell/</url>
      <content type="html"><![CDATA[<p>##查看当前开启的服务</p>
<ol>
<li><pre><code class="shell">ls /etc/rc`runlevel|sed &#39;s/N.//&#39;`.d|awk &#39;!/K/ {print}&#39;|sed &#39;s/S[0-9][0-9]//&#39;
</code></pre>
</li>
<li><pre><code class="shell">sudo service --status-all
</code></pre>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大创构思]]></title>
      <url>/2017/04/02/%E5%A4%A7%E5%88%9B%E6%9E%84%E6%80%9D/</url>
      <content type="html"><![CDATA[<h1 id="更新点"><a href="#更新点" class="headerlink" title="更新点"></a>更新点</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>增加网页IDE,功能</li>
<li>查重功能</li>
<li>分步计分</li>
<li>论坛</li>
<li>天梯训练模式</li>
<li>教学统计查看</li>
<li>当前oj功能完善</li>
</ol>
<h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><ul>
<li><p>网页IDE <code>徐瑶琨</code></p>
</li>
<li><p>论坛 <code>范得良</code></p>
</li>
<li><p>天梯训练模式 <code>马琨</code></p>
</li>
<li><p>教学统计功能,查重,分步计分,当前OJ功能完善,整合 <code>李闯</code></p>
</li>
</ul>
<h1 id="OnlineJudgeOpenAPI文档"><a href="#OnlineJudgeOpenAPI文档" class="headerlink" title="OnlineJudgeOpenAPI文档"></a>OnlineJudgeOpenAPI文档</h1><p>为了方便与Virtual Judge和第三方论坛等进行集成，开放了获取题目详细信息、提交代码、获取代码运行结果和用户SSO单点登录四个API。</p>
<p>在使用API之前，请先申请appkey，在个人设置页面可以看到，如果没有申请过，请联系OJ的管理员在后台开通。</p>
<h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><p>所有的返回值都是<code>{&quot;code&quot;: , data: }</code>的形式，只有code为0的时候代表正常返回了，data为数据内容。其余code表示出现错误，data为错误提示。</p>
<p>所有的POST请求和响应都是json格式的，POST请求的<code>Content-Type</code>确保为<code>application/json</code>。</p>
<h2 id="获取题目详细信息"><a href="#获取题目详细信息" class="headerlink" title="获取题目详细信息"></a>获取题目详细信息</h2><p><strong>request</strong> <code>GET</code> <code>/api/open/problem/?appkey=&amp;problem_id=</code><br><strong>response</strong></p>
<pre><code class="js">{
    &quot;code&quot;: 0,
    &quot;data&quot;: {
        // 题目的id
        &quot;id&quot;: 1,
        // 样例输入和输出
        &quot;samples&quot;: [
            {
                &quot;input&quot;: &quot;1 1&quot;,
                &quot;output&quot;: &quot;2&quot;
            },
            {
                &quot;input&quot;: &quot;1 1&quot;,
                &quot;output&quot;: &quot;2&quot;
            },
            {
                &quot;input&quot;: &quot;1 -1&quot;,
                &quot;output&quot;: &quot;0&quot;
            }
        ],
        // 标签
        &quot;tags&quot;: [
            {
                &quot;id&quot;: 1,
                &quot;name&quot;: &quot;简单&quot;
            }
        ],
        // 创建用户
        &quot;created_by&quot;: {
            &quot;username&quot;: &quot;root&quot;
        },
        // 题目
        &quot;title&quot;: &quot;A + B Problem&quot;,
        // 描述 HTML格式
        &quot;description&quot;: &quot;请计算两个整数的和并输出结果。注意不要有不必要的输出，比如&amp;quot;请输入 a 和 b 的值: &amp;quot;，示例代码见隐藏部分。&quot;,
        // 输入说明
        &quot;input_description&quot;: &quot;两个用空格分开的整数.&quot;,
        // 输出说明
        &quot;output_description&quot;: &quot;两数之和&quot;,
        // 提示 没有提示就是空字符串
        &quot;hint&quot;: &quot;测试题目&quot;,
        // 创建时间
        &quot;create_time&quot;: &quot;2015-09-02T13:02:26Z&quot;,
        // 最后修改时间 如果没有修改过，就是NULL
        &quot;last_update_time&quot;: &quot;2016-02-02T03:43:34.244046Z&quot;,
        // 时间限制 单位ms
        &quot;time_limit&quot;: 1000,
        // 内存限制 单位M
        &quot;memory_limit&quot;: 512,
        // 总共提交次数
        &quot;total_submit_number&quot;: 1128,
        // 总共ac次数
        &quot;total_accepted_number&quot;: 521,
        // 难度 1-3 简单到难
        &quot;difficulty&quot;: 1,
        // 题目来源
        &quot;source&quot;: &quot;经典题目&quot;
    }
}
</code></pre>
<h2 id="提交题目"><a href="#提交题目" class="headerlink" title="提交题目"></a>提交题目</h2><p><strong>request</strong> <code>post</code> <code>/api/open/submission/</code></p>
<pre><code class="js">{
    // appkey 
    &quot;appkey&quot;: &quot;example_appkey&quot;, 
    // 代码 
    &quot;code&quot;: &quot;example code&quot;,
    // 语言 1:C 2:C++ 3:Java 
    &quot;language&quot;: 1,
    // 题目id 
    &quot;problem_id&quot;: 1
}
</code></pre>
<p><strong>response</strong><br>提交代码后，服务器立即返回，并异步判题。</p>
<pre><code class="js">{
    &quot;code&quot;: 0,
    &quot;data&quot;: {
        // 提交id
        &quot;submission_id&quot;: &quot;4e49416e087f79fd3d0822b1899d601c&quot;
    }
}
</code></pre>
<p>要注意的是，每个用户都有自己的提交频率限制。开源代码中，默认使用的TokenBucket进行的限制，每个用户默认有50个token，然后每分钟可以创建2个token，但是也是50个token封顶，每提交一道题就消耗一个token。开始的50个token可以保证一定时间的并发需求，如果超过频率限制将返回错误和需要等待的时间。</p>
<h2 id="获取提交结果"><a href="#获取提交结果" class="headerlink" title="获取提交结果"></a>获取提交结果</h2><p><strong>request</strong> <code>GET</code> <code>/api/open/submission/?appkey=&amp;submission_id=</code></p>
<p><strong>response</strong></p>
<pre><code class="js">{
    &quot;code&quot;: 0,
    &quot;data&quot;: {
        &quot;id&quot;: &quot;9d4610ef9ae6b30e588c650891ba6858&quot;,
        &quot;result&quot;: 0,
        &quot;create_time&quot;: &quot;2016-02-16T03:54:10Z&quot;,
        &quot;language&quot;: 1,
        // info可能是None或者字符串
        // 在编译错误和系统错误的时候info为错误详情，可能会很长，其余的情况为一个json字符串
        &quot;info&quot;: &quot;[{\&quot;cpu_time\&quot;: 0, \&quot;exit_status\&quot;: 0, \&quot;signal\&quot;: 0, \&quot;output_md5\&quot;: \&quot;33d6548e48d4318ceb0e3916a79afc84\&quot;, \&quot;flag\&quot;: 0, \&quot;result\&quot;: 0, \&quot;memory\&quot;: 7602176, \&quot;real_time\&quot;: 4}, {\&quot;cpu_time\&quot;: 0, \&quot;exit_status\&quot;: 0, \&quot;signal\&quot;: 0, \&quot;output_md5\&quot;: \&quot;e4da3b7fbbce2345d7772b0674a318d5\&quot;, \&quot;flag\&quot;: 0, \&quot;result\&quot;: 0, \&quot;memory\&quot;: 7602176, \&quot;real_time\&quot;: 2}]&quot;
    }
}
</code></pre>
<p>result的对应关系</p>
<pre><code class="js">{
    &quot;accepted&quot;: 0,
    &quot;runtime_error&quot;: 1,
    &quot;time_limit_exceeded&quot;: 2,
    &quot;memory_limit_exceeded&quot;: 3,
    &quot;compile_error&quot;: 4,
    &quot;format_error&quot;: 5,
    &quot;wrong_answer&quot;: 6,
    &quot;system_error&quot;: 7,
    &quot;waiting&quot;: 8
}
</code></pre>
<h2 id="SSO单点登录"><a href="#SSO单点登录" class="headerlink" title="SSO单点登录"></a>SSO单点登录</h2><p><strong>request</strong> <code>GET</code> <code>/account/sso/?callback=</code></p>
<p>然后用户确认登录之后，会跳转到<code>http://callback_url?token=</code>上，需要获取token参数，然后</p>
<p><strong>request</strong> <code>POST</code> <code>/account/sso/</code></p>
<pre><code class="js">{
    &quot;appkey&quot;: &quot;example_appkey&quot;,
    &quot;token&quot;: &quot;example_token&quot;
}
</code></pre>
<p><strong>response</strong></p>
<pre><code class="js">{
    &quot;code&quot;: 0,
    &quot;data&quot;: {
        &quot;username&quot;: &quot;root&quot;,
        &quot;admin_type&quot;: 2,
        &quot;id&quot;: 1,
        &quot;avatar&quot;: &quot;/static/img/avatar/avatar-10.png&quot;
    }
}
</code></pre>
<p>注意回调的token和appkey并没有关系，这个token只能一次性使用。</p>
]]></content>
      
        <categories>
            
            <category> 日记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用Git命令清单]]></title>
      <url>/2017/04/01/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库<br><img src="http://function.dearamaze.com/git%E7%BB%93%E6%9E%84.png" alt=""></li>
</ul>
<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><pre><code># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<pre><code># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
</code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre><code># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre><code># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre><code># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre><code># 生成一个可供发布的压缩包
$ git archive
</code></pre><h2 id="使用问题记录"><a href="#使用问题记录" class="headerlink" title="使用问题记录"></a>使用问题记录</h2><p>git pull 出现错误<br>    由于git pull的内容与本地commit的内容产生了冲突。<br>解决方法<br>    产生冲突后，git会自动在本地记录冲突，修改本地的文件后，<code>git add -u</code> <code>git push origin master</code>即可</p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="external">转自</a></p>
]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
            <tag> github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tr命令]]></title>
      <url>/2017/03/31/tr%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>通过使用 tr，您可以非常容易地实现 sed 的许多最基本功能。您可以将 tr 看作为 sed 的（极其）简化的变体：它可以用一个字符来替换另一个字符，或者可以完全除去一些字符。您也可以用它来除去重复字符。这就是所有 tr 所能够做的。 </p>
</blockquote>
<p>tr用来从标准输入中通过替换或删除操作进行字符转换。tr主要用于删除文件中控制字符或进行字符转换。使用tr时要转换两个字符串：字符串1用于查询，字符串2用于处理各种转换。tr刚执行时，字符串1中的字符被映射到字符串2中的字符，然后转换操作开始。</p>
<h2 id="带有最常用选项的tr命令格式为："><a href="#带有最常用选项的tr命令格式为：" class="headerlink" title="带有最常用选项的tr命令格式为："></a>带有最常用选项的tr命令格式为：</h2><p>tr -c -d -s [“string1_to_translate_from”] [“string2_to_translate_to”]  input-file</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>-c 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。
-d 删除字符串1中所有输入字符。
-s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。
input-file是转换文件名。虽然可以使用其他格式输入，但这种格式最常用。
</code></pre><h3 id="字符范围"><a href="#字符范围" class="headerlink" title="字符范围"></a>字符范围</h3><pre><code>指定字符串1或字符串2的内容时，只能使用单字符或字符串范围或列表。
[a-z] a-z内的字符组成的字符串。
[A-Z] A-Z内的字符组成的字符串。
[0-9] 数字串。
\octal 一个三位的八进制数，对应有效的ASCII字符。
[O*n] 表示字符O重复出现指定次数n。因此[O*2]匹配OO的字符串。
tr中特定控制字符的不同表达方式
</code></pre><h3 id="速记符含义八进制方式"><a href="#速记符含义八进制方式" class="headerlink" title="速记符含义八进制方式"></a>速记符含义八进制方式</h3><pre><code>\a Ctrl-G  铃声\007
\b Ctrl-H  退格符\010
\f Ctrl-L  走行换页\014
\n Ctrl-J  新行\012
\r Ctrl-M  回车\015
\t Ctrl-I  tab键\011
\v Ctrl-X  \030
</code></pre><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><p>1.将文件file中出现的”abc”替换为”xyz”</p>
<pre><code>cat file | tr &quot;abc&quot; &quot;xyz&quot; &gt; new_file
</code></pre><p>【注意】这里，凡是在file中出现的”a”字母，都替换成”x”字母，”b”字母替换为”y”字母，”c”字母替换为”z”字母。而不是将字符串”abc”替换为字符串”xyz”。</p>
<p>2.使用tr命令“统一”字母大小写</p>
<pre><code>（小写 --&gt; 大写）
cat file | tr [a-z] [A-Z] &gt; new_file
（大写 --&gt; 小写）
cat file | tr [A-Z] [a-z] &gt; new_file
</code></pre><p>3.把文件中的数字0-9替换为a-j</p>
<pre><code>cat file | tr [0-9] [a-j] &gt; new_file
</code></pre><p>4、删除文件file中出现的”Snail”字符</p>
<pre><code class="shell">cat file | tr -d &quot;Snail&quot; &gt; new_file
</code></pre>
<p>【注意】这里，凡是在file文件中出现的’S’,’n’,’a’,’i’,’l’字符都会被删除！而不是紧紧删除出现的”Snail”字符串。</p>
<p>5、删除文件file中出现的换行’\n’、制表’\t’字符</p>
<pre><code class="shell">cat file | tr -d &quot;\n\t&quot; &gt; new_file
</code></pre>
<p>不可见字符都得用转义字符来表示的，这个都是统一的。</p>
<p>6、删除“连续着的”重复字母，只保留第一个</p>
<pre><code class="shell">cat file | tr -s [a-zA-Z] &gt; new_file
</code></pre>
<p>7、删除空行</p>
<pre><code class="shell">
cat file | tr -s &quot;\n&quot; &gt; new_file
</code></pre>
<p>8、删除Windows文件“造成”的’^M’字符</p>
<pre><code class="shell">
cat file | tr -d &quot;\r&quot; &gt; new_file
或者
cat file | tr -s &quot;\r&quot; &quot;\n&quot; &gt; new_file
</code></pre>
<p>【注意】这里-s后面是两个参数”\r”和”\n”，用后者替换前者</p>
<p>9、用空格符\040替换制表符\011</p>
<pre><code>cat file | tr -s &quot;\011&quot; &quot;\040&quot; &gt; new_file
</code></pre><p>10、把路径变量中的冒号”:”，替换成换行符”\n”</p>
<pre><code>echo $PATH | tr -s &quot;:&quot; &quot;\n&quot;
</code></pre>]]></content>
      
        <categories>
            
            <category> shell </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用apt命令参数]]></title>
      <url>/2017/03/31/%E5%B8%B8%E7%94%A8apt%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>常用的APT命令参数：</p>
<p>apt-cache search package 搜索包</p>
<p>apt-cache show package 获取包的相关信息，如说明、大小、版本等</p>
<p>sudo apt-get install package 安装包</p>
<p>sudo apt-get install package - - reinstall 重新安装包</p>
<p>sudo apt-get -f install 修复安装”-f = ——fix-missing”</p>
<p>sudo apt-get remove package 删除包</p>
<p>sudo apt-get remove package - - purge 删除包，包括删除配置文件等</p>
<p>sudo apt-get update 更新源</p>
<p>sudo apt-get upgrade 更新已安装的包</p>
<p>sudo apt-get dist-upgrade 升级系统</p>
<p>sudo apt-get dselect-upgrade 使用 dselect 升级</p>
<p>apt-cache depends package 了解使用依赖</p>
<p>apt-cache rdepends package 是查看该包被哪些包依赖</p>
<p>sudo apt-get build-dep package 安装相关的编译环境</p>
<p>apt-get source package 下载该包的源代码</p>
<p>sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包</p>
<p>sudo apt-get check 检查是否有损坏的依赖</p>
]]></content>
      
        
        <tags>
            
            <tag> 知识点 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决Ubuntu 16.04 搜狗输入法 只有悬浮窗中文不能自动联想的问题]]></title>
      <url>/2017/03/30/%E8%A7%A3%E5%86%B3Ubuntu-16-04-%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95-%E5%8F%AA%E6%9C%89%E6%82%AC%E6%B5%AE%E7%AA%97%E4%B8%AD%E6%96%87%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E8%81%94%E6%83%B3%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>一直用得好好的，不知道下载了什么更新导致搜狗输入法，在输入中文的时候，只显示一个悬浮窗。打字的时候什么反应都没有。中文也联想不出来。</p>
<p>找了半天，重新安装fcitx/搜狗输入法N次无果，在网上论坛找到了答案，修复了这个问题，记录一下。</p>
<p>直接删除其配置文件：</p>
<pre><code>rm -rf ~/.config/SogouPY* ~/.config/sogou*
</code></pre><p>然后直接在右上角点fcitx图标，下拉列表里面重启fcitx输入法</p>
<p><a href="https://fiture.me/share/linux-ubuntu/1246.html" target="_blank" rel="external">转载自</a></p>
]]></content>
      
        <categories>
            
            <category> Ubuntu使用 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP和UDP套接字C语言实现]]></title>
      <url>/2017/03/28/TCP%E5%92%8CUDP%E5%A5%97%E6%8E%A5%E5%AD%97C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="字符串传输"><a href="#字符串传输" class="headerlink" title="字符串传输"></a>字符串传输</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre><code>#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#define MYPORT  8887
#define BUFFER_SIZE 1024

int main()
{
    ///定义sockfd
    int sock_cli = socket(AF_INET,SOCK_STREAM, 0);

    ///定义sockaddr_in
    struct sockaddr_in servaddr;
    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(MYPORT);  ///服务器端口
    servaddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  ///服务器ip

    ///连接服务器，成功返回0，错误返回-1
    if (connect(sock_cli, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)
    {
        perror(&quot;connect&quot;);
        exit(1);
    }

    char sendbuf[BUFFER_SIZE];
    char recvbuf[BUFFER_SIZE];
    while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
    {
        send(sock_cli, sendbuf, strlen(sendbuf),0); ///发送
        if(strcmp(sendbuf,&quot;exit\n&quot;)==0)
            break;
        recv(sock_cli, recvbuf, sizeof(recvbuf),0); ///接收
        fputs(recvbuf, stdout);

        memset(sendbuf, 0, sizeof(sendbuf));
        memset(recvbuf, 0, sizeof(recvbuf));
    }

    close(sock_cli);
    return 0;
}
</code></pre><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre><code>#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#define MYPORT  8887
#define QUEUE   20
#define BUFFER_SIZE 1024

int main()
{
    ///定义sockfd
    int server_sockfd = socket(AF_INET,SOCK_STREAM, 0);

    ///定义sockaddr_in
    struct sockaddr_in server_sockaddr;
    server_sockaddr.sin_family = AF_INET;
    server_sockaddr.sin_port = htons(MYPORT);
    server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    ///bind，成功返回0，出错返回-1
    if(bind(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(server_sockaddr))==-1)
    {
        perror(&quot;bind&quot;);
        exit(1);
    }

    ///listen，成功返回0，出错返回-1
    if(listen(server_sockfd,QUEUE) == -1)
    {
        perror(&quot;listen&quot;);
        exit(1);
    }

    ///客户端套接字
    char buffer[BUFFER_SIZE];
    struct sockaddr_in client_addr;
    socklen_t length = sizeof(client_addr);

    ///成功返回非负描述字，出错返回-1
    int conn = accept(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length);
    if(conn&lt;0)
    {
        perror(&quot;connect&quot;);
        exit(1);
    }

    while(1)
    {
        memset(buffer,0,sizeof(buffer));
        int len = recv(conn, buffer, sizeof(buffer),0);
        if(strcmp(buffer,&quot;exit\n&quot;)==0)
            break;
        fputs(buffer, stdout);
        for(int i=0;i&lt;len;i++){
            if(buffer[i]&gt;=97&amp;&amp;buffer[i]&lt;=122)buffer[i]-=32;
        }
        send(conn, buffer, len, 0);
    }
    close(conn);
    close(server_sockfd);
    return 0;
}
</code></pre><h3 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h3><p>tcp_client:</p>
<p><img src="http://function.dearamaze.com/tcp_c.png" alt="client"></p>
<p>tcp_server:</p>
<p><img src="http://function.dearamaze.com/tcp_s.png" alt="server"></p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><pre><code>#include 
#include 
#include 
#include 
#include 

#define SERVER_PORT 8888
#define BUFF_LEN 512
#define SERVER_IP &quot;172.0.5.182&quot;


void udp_msg_sender(int fd, struct sockaddr* dst)
{

    socklen_t len;
    char sendbuf[BUFF_LEN];
    char recvbuf[BUFF_LEN];
    struct sockaddr_in src;
    while(fgets(sendbuf,sizeof(sendbuf),stdin)!=NULL){
        len=sizeof(*dst);
        sendto(fd,sendbuf,BUFF_LEN,0,dst,len);
        if(strcmp(sendbuf,&quot;exit\n&quot;)==0)break;
        recvfrom(fd,recvbuf,BUFF_LEN,0,(struct sockaddr*)&amp;src,&amp;len);
        fputs(recvbuf,stdout);

        memset(sendbuf,0,sizeof(sendbuf));
        memset(recvbuf,0,sizeof(recvbuf));
    }
}

/*
    client:
            socket--&gt;sendto--&gt;revcfrom--&gt;close
*/

int main(int argc, char* argv[])
{
    int client_fd;
    struct sockaddr_in ser_addr;

    client_fd = socket(AF_INET, SOCK_DGRAM, 0);
    if(client_fd &lt; 0)
    {
        printf(&quot;create socket fail!\n&quot;);
        return -1;
    }

    memset(&amp;ser_addr, 0, sizeof(ser_addr));
    ser_addr.sin_family = AF_INET;
    //ser_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);  //注意网络序转换
    ser_addr.sin_port = htons(SERVER_PORT);  //注意网络序转换

    udp_msg_sender(client_fd, (struct sockaddr*)&amp;ser_addr);

    close(client_fd);

    return 0;
}
</code></pre><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><pre><code>#include 
#include 
#include 
#include 
#include 

#define SERVER_PORT 8888
#define BUFF_LEN 1024

void handle_udp_msg(int fd)
{
    char buf[BUFF_LEN];  //接收缓冲区，1024字节
    socklen_t len;
    int count;
    struct sockaddr_in clent_addr;  //clent_addr用于记录发送方的地址信息
    while(1)
    {
        memset(buf, 0, BUFF_LEN);
        len = sizeof(clent_addr);
        count = recvfrom(fd, buf, BUFF_LEN, 0, (struct sockaddr*)&amp;clent_addr, &amp;len);  //recvfrom是拥塞函数，没有数据就一直拥塞
        if(count == -1)
        {
            printf(&quot;recieve data fail!\n&quot;);
            return;
        }
        if(strcmp(buf,&quot;exit\n&quot;)==0)break;
        fputs(buf,stdout);
        for(int i=0;i&lt;count;i++){
            if(buf[i]&gt;=97&amp;&amp;buf[i]&lt;=122)buf[i]-=32;
        }
        sendto(fd, buf, BUFF_LEN, 0, (struct sockaddr*)&amp;clent_addr, len);  //发送信息给client，注意使用了clent_addr结构体指针

    }
}


/*
    server:
            socket--&gt;bind--&gt;recvfrom--&gt;sendto--&gt;close
*/

int main(int argc, char* argv[])
{
    int server_fd, ret;
    struct sockaddr_in ser_addr; 

    server_fd = socket(AF_INET, SOCK_DGRAM, 0); //AF_INET:IPV4;SOCK_DGRAM:UDP
    if(server_fd &lt; 0)
    {
        printf(&quot;create socket fail!\n&quot;);
        return -1;
    }

    memset(&amp;ser_addr, 0, sizeof(ser_addr));
    ser_addr.sin_family = AF_INET;
    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY); //IP地址，需要进行网络序转换，INADDR_ANY：本地地址
    ser_addr.sin_port = htons(SERVER_PORT);  //端口号，需要网络序转换

    ret = bind(server_fd, (struct sockaddr*)&amp;ser_addr, sizeof(ser_addr));
    if(ret &lt; 0)
    {
        printf(&quot;socket bind fail!\n&quot;);
        return -1;
    }

    handle_udp_msg(server_fd);   //处理接收到的数据

    close(server_fd);
    return 0;
}
</code></pre><h3 id="运行截图-1"><a href="#运行截图-1" class="headerlink" title="运行截图"></a>运行截图</h3><p>udp_client</p>
<p><img src="http://function.dearamaze.com/udp_c.png" alt="client"></p>
<p>udp_server<br><img src="http://function.dearamaze.com/udp_s.png" alt="server"></p>
<h1 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h1><h2 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h2><h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><pre><code>#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  

#define MAXLINE 1024 

void usage(char *command) 
{ 
    printf(&quot;usage :%s ipaddr portnum filename\n&quot;, command); 
    exit(0); 
} 
int main(int argc,char **argv) 
{ 
    struct sockaddr_in serv_addr; 
    char buf[MAXLINE]; 
    int sock_id; 
    int read_len; 
    int send_len; 
    FILE *fp; 
    int i_ret; 

    if (argc != 4) { 
        usage(argv[0]); 
    } 

    /* open the file to be transported commented by guoqingbo*/ 
    if ((fp = fopen(argv[3],&quot;r&quot;)) == NULL) { 
        perror(&quot;Open file failed\n&quot;); 
        exit(0); 
    } 

    /* create the socket commented by guoqingbo*/ 
    if ((sock_id = socket(AF_INET,SOCK_STREAM,0)) &lt; 0) { 
        perror(&quot;Create socket failed\n&quot;); 
        exit(0); 
    } 

    memset(&amp;serv_addr, 0, sizeof(serv_addr)); 
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(atoi(argv[2])); 
    inet_pton(AF_INET, argv[1], &amp;serv_addr.sin_addr); 

    /* connect the server commented by guoqingbo*/ 
    i_ret = connect(sock_id, (struct sockaddr *)&amp;serv_addr, sizeof(struct sockaddr)); 
    if (-1 == i_ret) { 
        printf(&quot;Connect socket failed\n&quot;); 
       return -1; 
    } 

    /* transported the file commented by guoqingbo*/ 
    bzero(buf, MAXLINE); 
    while ((read_len = fread(buf, sizeof(char), MAXLINE, fp)) &gt;0 ) { 
        send_len = send(sock_id, buf, read_len, 0); 
        if ( send_len &lt; 0 ) { 
            perror(&quot;Send file failed\n&quot;); 
            exit(0); 
        } 
        bzero(buf, MAXLINE); 
    } 

    fclose(fp); 
    close(sock_id); 
    printf(&quot;Send Finish\n&quot;); 
    return 0; 
}
</code></pre><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><pre><code>#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  

#define MAXLINE 1024 

void usage(char *command) 
{ 
    printf(&quot;usage :%s portnum filename\n&quot;, command); 
    exit(0); 
} 
int main(int argc,char **argv) 
{ 
    struct sockaddr_in serv_addr; 
    struct sockaddr_in clie_addr; 
    char buf[MAXLINE]; 
    int sock_id; 
    int link_id; 
    int recv_len; 
    int write_leng; 
    int clie_addr_len; 
    FILE *fp; 

    if (argc != 3) { 
        usage(argv[0]); 
    } 
    if ((fp = fopen(argv[2], &quot;w&quot;)) == NULL) { 
        perror(&quot;Open file failed\n&quot;); 
        exit(0); 
    } 
    if ((sock_id = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { 
        perror(&quot;Create socket failed\n&quot;); 
        exit(0); 
    } 
    /*fill the server sockaddr_in struct commented by guoqingbo*/ 
    memset(&amp;serv_addr, 0, sizeof(serv_addr)); 
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(atoi(argv[1])); 
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); 

    if (bind(sock_id, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0 ) { 
        perror(&quot;Bind socket failed\n&quot;); 
        exit(0); 
    } 

    if (-1 == listen(sock_id, 10)) { 
        perror(&quot;Listen socket failed\n&quot;); 
        exit(0); 
    } 
    /* server part commented by guoqingbo*/ 
    while (1) { 
        clie_addr_len = sizeof(clie_addr); 
        link_id = accept(sock_id, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); 
        if (-1 == link_id) { 
            perror(&quot;Accept socket failed\n&quot;); 
            exit(0); 
        } 
        bzero(buf, MAXLINE); 
        while (recv_len = recv(link_id, buf, MAXLINE, 0)) { 
            /* receiver data part commented by guoqingbo*/ 
            if(recv_len &lt; 0) { 
                printf(&quot;Recieve Data From Server Failed!\n&quot;); 
                break; 
            } 
            printf(&quot;#&quot;); 
            write_leng = fwrite(buf, sizeof(char), recv_len, fp); 
            if (write_leng &lt; recv_len) { 
                printf(&quot;Write file failed\n&quot;); 
                break; 
            } 
            bzero(buf,MAXLINE); 
        } 
        printf(&quot;\nFinish Recieve\n&quot;); 
        fclose(fp); 
        close(link_id); 
    } 
    close(sock_id); 
    return 0; 
}
</code></pre><h3 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h3><p>tcp_file_client</p>
<p><img src="http://function.dearamaze.com/tcp_file_client.png" alt="tcp_file_client"></p>
<p>tcp_file_servier</p>
<p><img src="http://function.dearamaze.com/tcp_file_server.png" alt="tcp_file_servier"></p>
<h2 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h2><h3 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h3><pre><code>#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  

#define FINISH_FLAG &quot;FILE_TRANSPORT_FINISH&quot; 
#define MAXLINE 1024 

void usage(char *command) 
{ 
    printf(&quot;usage :%s ipaddr portnum filename\n&quot;, command); 
    exit(0); 
} 
int main(int argc,char **argv) 
{ 
    FILE *fp; 
    struct sockaddr_in serv_addr; 
    char buf[MAXLINE]; 
    int sock_id; 
    int read_len; 
    int send_len; 
    int serv_addr_len; 
    int i_ret; 
    int i; 

    if (argc != 4) { 
        usage(argv[0]); 
    } 
    /* open the file to be transported commanted by guoqingbo*/ 
    if ((fp = fopen(argv[3],&quot;r&quot;)) == NULL) { 
        perror(&quot;Open file failed\n&quot;); 
        exit(0); 
    } 
    /* create the socket commanted by guoqingbo*/ 
    if ((sock_id = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) { 
        perror(&quot;Create socket failed&quot;); 
        exit(0); 
    } 
    memset(&amp;serv_addr,0,sizeof(serv_addr)); 
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(atoi(argv[2])); 
    inet_pton(AF_INET, argv[1], &amp;serv_addr.sin_addr); 
    serv_addr_len = sizeof(serv_addr); 
    /* connect the server commanted by guoqingbo*/ 
    i_ret = connect(sock_id, (struct sockaddr *)&amp;serv_addr, sizeof(struct sockaddr)); 
    if (-1 == i_ret) { 
        perror(&quot;Connect socket failed!\n&quot;); 
        exit(0); 
    } 
    /* transport the file commented by guoqingbo*/ 
    bzero(buf, MAXLINE); 
    while ( (read_len = fread(buf, sizeof(char), MAXLINE, fp)) &gt; 0 ) { 
        send_len = send(sock_id, buf, read_len, 0); 
        if ( send_len &lt; 0 ) { 
            perror(&quot;Send data failed\n&quot;); 
            exit(0); 
        } 
        bzero(buf, MAXLINE); 
    } 
    fclose(fp); 
    /* send the end_flag commented by guoqingbo*/ 
    bzero(buf, MAXLINE); 
    strcpy(buf, FINISH_FLAG); 
    buf[strlen(buf)] = &#39;\0&#39;; 
    for (i = 1000; i&gt;0; i--) { 
        send_len = send(sock_id, buf, strlen(buf)+1, 0); 
        if ( send_len &lt; 0 ) { 
            printf(&quot;Finish send the end string\n&quot;); 
            break; 
        } 
    } 
    close(sock_id); 
    printf(&quot;Send finish\n&quot;); 
    return 0; 
}
</code></pre><h3 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h3><pre><code class="C">#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  
#include  

#define FINISH_FLAG &quot;FILE_TRANSPORT_FINISH&quot; 
#define MAXLINE 1024 

void usage(char *command) 
{ 
    printf(&quot;usage :%s portnum filename\n&quot;, command); 
    exit(0); 
} 
int main(int argc,char **argv) 
{ 
    struct sockaddr_in serv_addr; 
    struct sockaddr_in clie_addr; 
    char buf[MAXLINE]; 
    int sock_id; 
    int recv_len; 
    int clie_addr_len; 
    FILE *fp; 

    if (argc != 3) { 
        usage(argv[0]); 
    } 
    /* Create the the file commented by guoqingbo*/ 
    if ((fp = fopen(argv[2], &quot;w&quot;)) == NULL) { 
        perror(&quot;Creat file failed&quot;); 
        exit(0); 
    } 
    if ((sock_id = socket(AF_INET,SOCK_DGRAM,0)) &lt; 0) { 
        perror(&quot;Create socket failed\n&quot;); 
        exit(0); 
    } 
    /*fill the server sockaddr_in struct commented by guoqingbo*/ 
    memset(&amp;serv_addr,0,sizeof(serv_addr)); 
    serv_addr.sin_family = AF_INET; 
    serv_addr.sin_port = htons(atoi(argv[1])); 
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); 

    if (bind(sock_id,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)) &lt; 0 ) { 
        perror(&quot;Bind socket faild\n&quot;); 
        exit(0); 
    } 
    /* server part commented by guoqingbo*/ 
    clie_addr_len = sizeof(clie_addr); 
    bzero(buf, MAXLINE); 
    while (recv_len = recvfrom(sock_id, buf, MAXLINE, 0,(struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len)) { 
        if(recv_len &lt; 0) { 
            printf(&quot;Recieve data from client failed!\n&quot;); 
            break; 
        } 
        printf(&quot;#&quot;); 
        if ( strstr(buf, FINISH_FLAG) != NULL ) { 
            printf(&quot;\nFinish receiver finish_flag\n&quot;); 
            break; 
        } 
        int write_length = fwrite(buf, sizeof(char), recv_len, fp); 
        if (write_length &lt; recv_len) { 
            printf(&quot;File write failed\n&quot;); 
            break; 
        } 
        bzero(buf, MAXLINE); 
    } 

    printf(&quot;Finish recieve\n&quot;); 
    fclose(fp); 
    close(sock_id); 
    return 0; 
}
</code></pre>
<h3 id="截图-1"><a href="#截图-1" class="headerlink" title="截图"></a>截图</h3><p>udp_file_client</p>
<p><img src="http://function.dearamaze.com/udp_file_client.png" alt="udp_file_client"></p>
<p>udp_file_server</p>
<p><img src="http://function.dearamaze.com/udp_file_server.png" alt="udp_file_client"></p>
]]></content>
      
        <categories>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux块设备的详解]]></title>
      <url>/2017/03/27/linux%E5%9D%97%E8%AE%BE%E5%A4%87%E7%9A%84%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文讲解linux操作系统的块设备，linux快设备类型的根本区别在于它们是否可以被随机访问——换句话说就是，能否在访问设备时随意地从一个位置跳转到另一个位置。</p>
</blockquote>
<h2 id="linux块设备，字符设备"><a href="#linux块设备，字符设备" class="headerlink" title="linux块设备，字符设备"></a>linux块设备，字符设备</h2><pre><code>字符设备还是块设备的定义属于操作系统的设备访问层，与实际物理设备的特性无必然联系。设备访问层下面是驱动程序，所以只要驱动程序提供的方式，都可以。也就是说驱动程序支持stream方式，那么就可以用这种方式访问，驱动程序如果还支持block方式，那么你想用哪种方式访问都可以，典型的比如硬盘式的裸设备，两种都支持。
</code></pre><h2 id="块设备（blockdevice）"><a href="#块设备（blockdevice）" class="headerlink" title="块设备（blockdevice）"></a>块设备（blockdevice）</h2><blockquote>
<p>是一种具有一定结构的随机存取设备，对这种设备的读写是按块进行的，他使用缓冲区来存放暂时的数据，待条件成熟后，从缓存一次性写入设备或从设备中一次性读出放入到缓冲区，如磁盘和文件系统等</p>
</blockquote>
<h2 id="字符设备（Characterdevice）："><a href="#字符设备（Characterdevice）：" class="headerlink" title="字符设备（Characterdevice）："></a>字符设备（Characterdevice）：</h2><blockquote>
<p>这是一个顺序的数据流设备，对这种设备的读写是按字符进行的，而且这些字符是连续地形成一个数据流。他不具备缓冲区，所以对这种设备的读写是实时的，如终端、磁带机等。</p>
</blockquote>
<p>系统中能够随机（不需要按顺序）访问固定大小数据片（chunks）的设备被称作块设备，这些数据片就称作块。最常见的块设备是硬盘，除此以外，还有软盘驱动器、CD-ROM驱动器和闪存等等许多其他块设备。注意，它们都是以安装文件系统的方式使用的——这也是块设备一般的访问方式。<br>另一种基本的设备类型是字符设备。字符设备按照字符流的方式被有序访问，像串口和键盘就都属于字符设备。如果一个硬件设备是以字符流的方式被访问的话，那就应该将它归于字符设备；反过来，如果一个设备是随机（无序的）访问的，那么它就属于块设备。</p>
<p>linux块设备这两种类型的根本区别在于它们是否可以被随机访问——换句话说就是，能否在访问设备时随意地从一个位置跳转到另一个位置。举个例子，键盘这种设备提供的就是一个数据流，当你敲入“fox”这个字符串时，键盘驱动程序会按照和输入完全相同的顺序返回这个由三个字符组成的数据流。如果让键盘驱动程序打乱顺序来读字符串，或读取其他字符，都是没有意义的。所以键盘就是一种典型的字符设备，它提供的就是用户从键盘输入的字符流。对键盘进行读操作会得到一个字符流，首先是“f”，然后是“o”，最后是“x”，最终是文件的结束(EOF)。当没人敲键盘时，字符流就是空的。硬盘设备的情况就不大一样了。硬盘设备的驱动可能要求读取磁盘上任意块的内容，然后又转去读取别的块的内容，而被读取的块在磁盘上位置不一定要连续，所以说硬盘可以被随机访问，而不是以流的方式被访问，显然它是一个块设备。</p>
<p>内核管理块设备要比管理字符设备细致得多，需要考虑的问题和完成的工作相比字符设备来说要复杂许多。这是因为字符设备仅仅需要控制一个位置—当前位置—而块设备访问的位置必须能够在介质的不同区间前后移动。所以事实上内核不必提供一个专门的子系统来管理字符设备，但是对块设备的管理却必须要有一个专门的提供服务的子系统。不仅仅是因为块设备的复杂性远远高于字符设备，更重要的原因是块设备对执行性能的要求很高；对硬盘每多一分利用都会对整个系统的性能带来提升，其效果要远远比键盘吞吐速度成倍的提高大得多。</p>
]]></content>
      
        <categories>
            
            <category> linux系统知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据重删论文1]]></title>
      <url>/2017/03/27/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%88%A0%E8%AE%BA%E6%96%871/</url>
      <content type="html"><![CDATA[<h1 id="Dmdedup-Device-Mapper-Target-for-Data-Deduplication"><a href="#Dmdedup-Device-Mapper-Target-for-Data-Deduplication" class="headerlink" title="Dmdedup: Device Mapper Target for Data Deduplication"></a><a href="http://www.fsl.cs.sunysb.edu/docs/ols-dmdedup/dmdedup-ols14.pdf" target="_blank" rel="external">Dmdedup: Device Mapper Target for Data Deduplication</a></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>dmdedup这个软件是一个适用于常规应用者和研究人员的,多功能实用性的主存数据重删平台.在块级别进行操作,对应用和系统都是有用的.因为大多数据重删研究,设计和完善了一个后端接口,方便研究人员,构建和评估元数据管理的方法.<br>通过下面三个方式,完善了后端:</p>
<ol>
<li>RAM_TAB:内存中的哈希表</li>
<li>DISK_TAB:磁盘哈希表</li>
<li>基于B树的DISK_TAB:持续的写时拷贝的B树</li>
</ol>
<p>主存重删与数据集备份相比带来的挑战有:</p>
<ol>
<li>访问局部性不太明显；</li>
<li>延迟的限制更严格；</li>
<li>更少的副本是可用的（约2×与备份10×）；</li>
<li>和重复数据删除引擎必须与其他进程竞争CPU和RAM。</li>
</ol>
<p>为了方便在主存储器中的重复数据删除技术的研究，我们开发了，这里提出了一个灵活的、完全可操作的主存储重复数据删除系统，Dmdedup，在Linux内核中实现。除了其吸引人的特性为普通用户，它可以作为实验的重复数据删除算法和研究主存储数据和工作负载的基础平台。</p>
<p>它和RAID , LVM 在同一层对linux内核块设备进行操作.</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="数据重删层面"><a href="#数据重删层面" class="headerlink" title="数据重删层面"></a>数据重删层面</h4><ol>
<li>应用层</li>
<li>文件系统层<br> 实现方式:<pre><code> 1. 修改现有的文件系统,比如EXT3或者WAFL.
 2. 在内核或者利用用户空间文件系统创建一个可折叠的文件系统.
 3. 从零开始实现一个重复数据删除的文件系统,比如,EMC 数据域的文件系统.
</code></pre></li>
<li>block level<br> 缺点:<pre><code> 1. 它必须保持一个额外的映射（超出文件系统的)逻辑和物理块之间的映射；
 2. 文件系统和应用程序有用的上下文丢失.
 3. variable length chunking is more difficult at the block layer. 
</code></pre></li>
</ol>
<h4 id="时效性"><a href="#时效性" class="headerlink" title="时效性"></a>时效性</h4><h3 id="DM-设备映射器"><a href="#DM-设备映射器" class="headerlink" title="DM:设备映射器"></a>DM:设备映射器</h3><p>Device Mapper 是 Linux2.6 内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构.</p>
<h3 id="Dmdedup的组成"><a href="#Dmdedup的组成" class="headerlink" title="Dmdedup的组成"></a>Dmdedup的组成</h3><p><img src="http://function.dearamaze.com/Dmdedup_struct.png" alt="img"></p>
<ol>
<li>数据重删的逻辑,块存储,计算hash值,协调其他部件.</li>
<li>一个hash表,用来索引hash值与块的位置.</li>
<li>逻辑块号到物理块号的映射.</li>
<li>空间管理器,在物理设备上索引空间,定位新的块,维护计数,回收没有引用的块.</li>
<li>块存储.</li>
</ol>
<h3 id="写需求"><a href="#写需求" class="headerlink" title="写需求"></a>写需求</h3><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>Dmdedup软件里的hash值生成方法,它支持30多种哈希函数(内核的加密库),作者实验用的是128位的MD5 hash值.<br>hash值不能太短,容易发生碰撞,不能太长,增加了元数据的大小.<br>磁盘发生错误的概率是10^(-18)—10^(-15),128位的hash串,发生碰撞的概率低于磁盘发生错误的概率.</p>
<h3 id="哈希索引和逻辑块号映射查询"><a href="#哈希索引和逻辑块号映射查询" class="headerlink" title="哈希索引和逻辑块号映射查询"></a>哈希索引和逻辑块号映射查询</h3><ol>
<li>利用hash索引物理块号<em>PBN(new)</em></li>
<li>利用逻辑块号映射物理块号<em>PBN(old)</em></li>
</ol>
<h3 id="元数据更新"><a href="#元数据更新" class="headerlink" title="元数据更新"></a>元数据更新</h3><p><img src="http://function.dearamaze.com/write_request_handling.png" alt="img"></p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收,不是实时的,是一个离线的定时的回收.</p>
<h2 id="读请求控制"><a href="#读请求控制" class="headerlink" title="读请求控制"></a>读请求控制</h2><h2 id="后端元数据"><a href="#后端元数据" class="headerlink" title="后端元数据"></a>后端元数据</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>强制:</p>
<ol>
<li>初始化</li>
<li>销毁</li>
<li>块的定位,查找,插入,删除,关联数的控制</li>
</ol>
<p>可选:</p>
<ol>
<li>垃圾回收</li>
<li>元数据同步写入</li>
</ol>
<h3 id="API类型"><a href="#API类型" class="headerlink" title="API类型"></a>API类型</h3><ol>
<li>线性(linear):Dmdedup uses a linear store (from zero to the size of the Dmdedup device)<br>for LBN mapping</li>
<li>稀疏型(sparse):and a sparse one for the hash index.</li>
</ol>
<h3 id="INRAM"><a href="#INRAM" class="headerlink" title="INRAM"></a>INRAM</h3><ol>
<li>重删的元数据一直存在RAM上</li>
<li>允许我们自定义给多少CPU用于重删.</li>
<li>他能很快算出工作负载的重删率</li>
<li>在电容和电池的支持下可用于生产环境</li>
</ol>
<p>用静态定位的哈希表用于键值存储,用一个数组用于线性存储.</p>
<p>线性映射数组的大小基于目标实例的大小.</p>
<p>用于离散存储的哈希表的大小基于数据设备的大小(预测最多可能有的不同数据块的数目).</p>
<p>用数组记录关联数</p>
<p>用数组定位新的块</p>
<h3 id="DTB"><a href="#DTB" class="headerlink" title="DTB"></a>DTB</h3><p>和INRAM用了相同的数据结构,但是是将数据保存在硬盘上(持久存储体).<br>没有缓冲区的话,每一次操作都是一次IO,严重影响dmdedup的性能. 我们用了Linux的<code>dm-bufio</code>子系统.</p>
<h3 id="CBT"><a href="#CBT" class="headerlink" title="CBT"></a>CBT</h3><p><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="external">Linux写时拷贝技术(copy-on-write)</a></p>
<p><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="external">B树</a></p>
<h3 id="设备大小"><a href="#设备大小" class="headerlink" title="设备大小"></a>设备大小</h3><p>设备逻辑大小可以改变</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验组设置"><a href="#实验组设置" class="headerlink" title="实验组设置"></a>实验组设置</h3><ol>
<li>原生的设备</li>
<li>INRAM</li>
<li>DTB</li>
<li>CBT</li>
</ol>
<p>元数据cache大小设置:<br><code>0.3%</code> <code>25%</code> <code>50%</code> <code>75%</code> <code>100%</code> <code>135%</code></p>
<h3 id="Dmdedup"><a href="#Dmdedup" class="headerlink" title="Dmdedup"></a>Dmdedup</h3><p>通过连续的和随机的读写来测试其性能.</p>
<h4 id="Micro-workloads"><a href="#Micro-workloads" class="headerlink" title="Micro-workloads"></a>Micro-workloads</h4><p>三种工作负载:</p>
<ol>
<li>Unique,独一无二的数据:通过linux的<code>/dev/urandom</code> 设备产生的.</li>
<li>All-duplicates,全是重复的:每个块4kb,重复146GB</li>
<li>linux-kernel : 40个linux内核</li>
</ol>
<p>两种类型:</p>
<ol>
<li>大量的连续写(I/O SIZE: 640KB)</li>
<li>少量的随机写(I/O SIZE: 4KB)</li>
</ol>
<h5 id="Unique"><a href="#Unique" class="headerlink" title="Unique"></a>Unique</h5><p>连续写:</p>
<p>重删率是1,不包括元数据.这种情况下重删系统的性能是最差的,因为重删的工作还得做.INRAM的性能和原生设备的一样(这是在CPU和RAM足够快去做数据重删,没有任何明显的性能影响的情况下),CPU的使用率在65%.</p>
<p>元数据的更新确实是个瓶颈,4M大小的cache下,DTB的性能仅有原生设备的25%,cache大小在75%-100%之间,性能得到了很大的提升,因为100%的cache不需要元数据的读了,135%的cache下,元数据的写也避免了,所以DTB达到了INRAM的性能.</p>
<p>随机写:<br>原生的设备实现了420IOPS,Dmdedup比原生的要好很多,670-11100IOPS,因为他使随机的写变得有序,连续的定位新的块是重删系统的一个一般的策略.</p>
<h4 id="All-duplicates"><a href="#All-duplicates" class="headerlink" title="All-duplicates"></a>All-duplicates</h4><h4 id="Linux-Kernels"><a href="#Linux-Kernels" class="headerlink" title="Linux Kernels"></a>Linux Kernels</h4><h3 id="Trace-Replay"><a href="#Trace-Replay" class="headerlink" title="Trace Replay"></a>Trace Replay</h3><ol>
<li>Web</li>
<li>Mail</li>
<li>Homes </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 数据重删 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据重删 </tag>
            
            <tag> 论文 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[要完成的任务]]></title>
      <url>/2017/03/24/%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<h2 id="终极目标"><a href="#终极目标" class="headerlink" title="终极目标"></a>终极目标</h2><pre><code>阿里,腾讯运维研发岗位
</code></pre><h2 id="要完成的任务"><a href="#要完成的任务" class="headerlink" title="要完成的任务"></a>要完成的任务</h2><ol>
<li>shell精通</li>
<li>python精通</li>
<li>计算机网络,操作系统,数据结构与算法</li>
<li>常用服务器的搭建,配置,调优,监控</li>
</ol>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>网络编程</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Unix环境高级编程</p>
<h3 id="服务器的搭建-配置-调优"><a href="#服务器的搭建-配置-调优" class="headerlink" title="服务器的搭建,配置,调优"></a>服务器的搭建,配置,调优</h3><h3 id="运维软件工具"><a href="#运维软件工具" class="headerlink" title="运维软件工具"></a>运维软件工具</h3><h3 id="虚拟化docker-openstack"><a href="#虚拟化docker-openstack" class="headerlink" title="虚拟化docker,openstack"></a>虚拟化docker,openstack</h3><h3 id="自动化运维-理念-编程"><a href="#自动化运维-理念-编程" class="headerlink" title="自动化运维:理念,编程"></a>自动化运维:理念,编程</h3>]]></content>
      
        <categories>
            
            <category> 日记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Diary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]C++文件操作]]></title>
      <url>/2017/03/15/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<pre><code>string  getFileContext(const string&amp;amp; filename)
{
    string str;
    str.clear();
    char buf[1024];
    char *p;
    p = buf;
    memset(buf, 0, 1024);
    ifstream in;
    in.open(filename);
    while ((*p = in.get()) != EOF)
    {
        p++;
    }
    cout &amp;lt;&amp;lt; &quot;Buf&quot; &amp;lt;&amp;lt; endl;
    puts(buf);
    str += buf;
    cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;
    in.close();
    return str;
}


            作者：qq_27803491 发表于2017/3/15 11:22:40 [原文链接](http://blog.csdn.net/qq_27803491/article/details/62217799)


        阅读：13 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/62217799#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]ubuntu16.04 安装shadowsocks,番羽土啬]]></title>
      <url>/2017/02/27/ubuntu16-04-%E5%AE%89%E8%A3%85shadowsocks-%E7%95%AA%E7%BE%BD%E5%9C%9F%E5%95%AC/</url>
      <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol>
<li>安装shadowsocks-qt5</li>
</ol>
<p><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" target="_blank" rel="external">统一安装教程</a><br>        ubuntu16.04安装,执行如下命令:</p>
<pre><code>sudo add-apt-repository ppa:hzwhuang/ss-qt5
sudo apt-get update
sudo apt-get install shadowsocks-qt5`
`完成之后,在图形界面下找到shadowsocks-qt5的图标启动,或者命令行运行:/usr/bin/ss-qt5
然后配置ss,connection--&amp;gt;add--&amp;gt;manually--&amp;gt;填写相关参数
`
</code></pre><ol>
<li><p>配置chrome浏览器<br>下载chrome插件:<a href="https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.3.21/SwitchyOmega.crx" target="_blank" rel="external">SwitchyOmega2.3.21下载地址</a>   ////分隔符/////     <a href="https://github.com/FelisCatus/SwitchyOmega/releases/" target="_blank" rel="external">SwitchyOmega最新版网址</a>    安装该插件(不会安装,百度crx插件安装办法)    然后配置该插件,参考:</p>
<pre><code>1.  设置代理地址    安装好插件会自动跳到设置选项，有提示你可以跳过。左边新建情景模式-选择代理服务器-比如命名为SS（叫什么无所谓）其他默认之后创建，之后在代理协议选择SOCKS5，地址为127.0.0.1,端口默认1080 。然后保存即应用选项。![1](https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-0.png)![2](https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-1.png)
</code></pre><ol>
<li>设置自动切换    接着点击自动切换 ( Auto switch）上面的不用管，在按照规则列表匹配请求后面选择刚才新建的SS，默认情景模式选择直接连接。点击应用选项保存。再往下规则列表设置选择AutoProxy 然后将这个地址填进去，点击下面的立即更新情景模式，会有提示更新成功！<img src="https://aitanlu.com/wp-content/uploads/2016/04/shadowsocks-2.png" alt="3"> 图片中7填写的是:    <code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code><pre><code>1.  然后就可以成功打开 google.com 了![这里写图片描述](http://img.blog.csdn.net/20170227200806973?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjc4MDM0OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
</code></pre></li>
</ol>
</li>
<li>开机启动<br>运行:<br>`gnome-session-properties</li>
</ol>
<p>打开这个,然后添加<br>    <img src="http://www.afox.cc/wp-content/uploads/2015/07/2015-07-11-171133%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="4"><br>    如下填写后保存退出即可!<br>    <img src="http://www.afox.cc/wp-content/uploads/2015/07/2015-07-11-171220%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="5"></p>
<h2 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h2><ol>
<li><a href="http://www.jianshu.com/p/9b7725d50f4c" target="_blank" rel="external">ubuntu16.04下载安装shadowsocks+配置chrome的过程记录</a></li>
<li><a href="https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html" target="_blank" rel="external">linux-ubuntu使用shadowsocks客户端配置</a></li>
<li><p><a href="http://www.afox.cc/archives/83" target="_blank" rel="external">ubuntu 使用图形化配置 shadowsocks -qt5 开机自动启动（配置开机启动）</a></p>
<pre><code>        作者：qq_27803491 发表于2017/2/27 20:11:34 [原文链接](http://blog.csdn.net/qq_27803491/article/details/58233565)
</code></pre></li>
</ol>
<pre><code>        阅读：20 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/58233565#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]C申请内存函数]]></title>
      <url>/2017/02/23/C%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<pre><code>#include &amp;lt;iostream&amp;gt;
using namespace std;

//传值调用
void GetMemory( char **p )
{
    *p = (char *) malloc( 100 );
}
//引用调用
void GetMemory_1(char *&amp;amp;p)
{
    p = (char *) malloc (100);
}

int main()
{
    char *str = NULL;
    char *str1 = NULL;
    GetMemory( &amp;amp;str );
    GetMemory_1( str1 );
    strcpy( str, &quot;hello world&quot; );
    strcpy( str1, &quot;hello world1&quot; );
    cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;str1&amp;lt;&amp;lt;endl;
    free(str);
    free(str1);
    return 0;

}


            作者：qq_27803491 发表于2017/2/23 18:04:15 [原文链接](http://blog.csdn.net/qq_27803491/article/details/56677396)


        阅读：20 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/56677396#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]markdown 语法]]></title>
      <url>/2017/02/08/markdown-%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="欢迎使用Markdown编辑器写博客"><a href="#欢迎使用Markdown编辑器写博客" class="headerlink" title="欢迎使用Markdown编辑器写博客"></a>欢迎使用Markdown编辑器写博客</h1><p>本Markdown编辑器使用[StackEdit][6]修改而来，用它写博客，将会带来全新的体验哦：</p>
<ul>
<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>
<li><strong>代码块高亮</strong></li>
<li><strong>图片链接和图片上传</strong></li>
<li><strong><em>LaTex</em>数学公式</strong></li>
<li><strong>UML序列图和流程图</strong></li>
<li><strong>离线写博客</strong></li>
<li><strong>导入导出Markdown文件</strong></li>
<li><strong>丰富的快捷键</strong></li>
</ul>
<hr>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>加粗    <code>Ctrl + B</code><em>   斜体    <code>Ctrl + I</code></em>   引用    <code>Ctrl + Q</code></li>
<li>插入链接    <code>Ctrl + L</code></li>
<li>插入代码    <code>Ctrl + K</code></li>
<li>插入图片    <code>Ctrl + G</code></li>
<li>提升标题    <code>Ctrl + H</code></li>
<li>有序列表    <code>Ctrl + O</code></li>
<li>无序列表    <code>Ctrl + U</code></li>
<li>横线    <code>Ctrl + R</code></li>
<li>撤销    <code>Ctrl + Z</code></li>
<li>重做    <code>Ctrl + Y</code></li>
</ul>
<h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external"> [ 维基百科 ]</a></p>
</blockquote>
<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net" target="_blank" rel="external">链接</a>等，详细语法参考帮助？。</p>
<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra" target="_blank" rel="external">Github</a>.  </p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>
<p>  项目<br>  价格</p>
<p>  Computer<br>  $1600</p>
<p>  Phone<br>  $12</p>
<p>  Pipe<br>  $1</p>
<p>可以使用冒号来定义对齐方式：</p>
<p>  项目<br>  价格<br>  数量</p>
<p>  Computer<br>  1600 元<br>  5</p>
<p>  Phone<br>  12 元<br>  12</p>
<p>  Pipe<br>  1 元<br>  234</p>
<h3 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>定义 A</p>
<p>定义 B</p>
<p>项目３<br>定义 C</p>
<p>定义 D</p>
<blockquote>
<p>定义D内容</p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>
<pre><code>@requires_authorization
def somefunc(param1=&#39;&#39;, param2=0):
    &#39;&#39;&#39;A docstring&#39;&#39;&#39;
    if param1 &amp;gt; param2: # interesting
        print &#39;Greater&#39;
    return (param2 - param1 + 1) or None
class SomeClass:
    pass
&amp;gt;&amp;gt;&amp;gt; message = &#39;&#39;&#39;interpreter
... prompt&#39;&#39;&#39;
</code></pre><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>生成一个脚注<a href="#fn:footnote" title="See footnote">1</a>.</p>
<ul>
<li><p><a href="#欢迎使用markdown编辑器写博客">欢迎使用Markdown编辑器写博客</a></p>
<pre><code>*   [快捷键](#快捷键)
</code></pre><ul>
<li><p><a href="#markdown及扩展">Markdown及扩展</a></p>
<pre><code>    *   [表格](#表格)
</code></pre><ul>
<li><a href="#定义列表">定义列表</a></li>
<li><a href="#代码块">代码块</a></li>
<li><a href="#脚注">脚注</a></li>
<li><a href="#数学公式">数学公式</a></li>
<li><p><a href="#uml-图">UML 图</a></p>
</li>
<li><p><a href="#离线写博客">离线写博客</a></p>
</li>
</ul>
</li>
<li><a href="#浏览器兼容">浏览器兼容</a></li>
</ul>
</li>
</ul>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/" target="_blank" rel="external">math.stackexchange.com</a>.</p>
<ul>
<li>行内公式，数学公式为：Γ(n)=(n−1)!∀n∈N\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N。</li>
<li>块级公式：</li>
</ul>
<p>x=−b±b2−4ac−−−−−−−√2a    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} </p>
<p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">这儿</a>.</p>
<h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p>
<p>Created with Raphaël 2.1.0张三张三李四李四嘿，小四儿, 写博客了没?李四愣了一下，说：忙得吐血，哪有时间写。</p>
<p>或者流程图：</p>
<p>Created with Raphaël 2.1.0开始我的操作确认？结束yesno</p>
<ul>
<li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">这儿</a>,</li>
<li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">这儿</a>.</li>
</ul>
<h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor" target="_blank" rel="external">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>
<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>
<p>博客发表后，本地缓存将被删除。　</p>
<p>用户可以选择  把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>
</blockquote>
<h2 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h2><ol>
<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>
<li>IE９以下不支持</li>
<li><p>IE９，１０，１１存在以下问题</p>
<pre><code>1.  不支持离线功能
</code></pre><ol>
<li>IE9不支持文件导入导出</li>
<li>IE10不支持拖拽文件导入</li>
</ol>
</li>
</ol>
<hr>
<hr>
<ol>
<li><p>这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>
<p>目录</p>
<p>用 <code>[TOC]</code>来生成目录：<br>[6]: <a href="https://github.com/benweet/stackedit" target="_blank" rel="external">https://github.com/benweet/stackedit</a> <a href="#fnref:footnote" title="Return to article">↩</a></p>
<pre><code>        作者：qq_27803491 发表于2017/2/8 22:19:58 [原文链接](http://blog.csdn.net/qq_27803491/article/details/54933885)
</code></pre></li>
</ol>
<pre><code>        阅读：19 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/54933885#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]大三寒假(2017.1.18)]]></title>
      <url>/2017/01/18/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87-2017-1-18/</url>
      <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol>
<li>shell脚本精通,linux命令行与shell脚本编程大全,linux shell脚本攻略,awk&amp;sed,ABS(1h/day)</li>
<li>linux环境编程(15*4h=60h)</li>
<li>docker(10h)</li>
<li>高性能linux服务器构建实战(14*4=56h)</li>
<li>英语六级(0.5h/day)</li>
<li>每日编程(1h/day)</li>
<li>CCNA考试认证(1h/day)</li>
<li>考驾照,练车</li>
</ol>
<p>3.5*30=105+60+10+56=231+60=291h</p>
<pre><code>每天10h,吃饭2h,睡觉10h,加油,得良!!!


            作者：qq_27803491 发表于2017/1/18 13:59:53 [原文链接](http://blog.csdn.net/qq_27803491/article/details/54600137)


        阅读：17 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/54600137#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]高斯消元（混合颜料）]]></title>
      <url>/2017/01/05/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%88%E6%B7%B7%E5%90%88%E9%A2%9C%E6%96%99%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="题目（网易2017内推编程题（二）的第一题）"><a href="#题目（网易2017内推编程题（二）的第一题）" class="headerlink" title="题目（网易2017内推编程题（二）的第一题）"></a>题目（网易2017内推编程题（二）的第一题）</h2><p>你就是一个画家！你现在想绘制一幅画，但是你现在没有足够颜色的颜料。为了让问题简单，我们用正整数表示不同颜色的颜料。你知道这幅画需要的n种颜色的颜料，你现在可以去商店购买一些颜料，但是商店不能保证能供应所有颜色的颜料，所以你需要自己混合一些颜料。混合两种不一样的颜色A和颜色B颜料可以产生(A XOR B)这种颜色的颜料(新产生的颜料也可以用作继续混合产生新的颜色,XOR表示异或操作)。本着勤俭节约的精神，你想购买更少的颜料就满足要求，所以兼职程序员的你需要编程来计算出最少需要购买几种颜色的颜料？  </p>
<p>输入描述: </p>
<p>第一行为绘制这幅画需要的颜色种数n (1 ≤ n ≤ 50) </p>
<p>第二行为n个数xi(1 ≤ xi ≤ 1,000,000,000)，表示需要的各种颜料.</p>
<p>输出描述: </p>
<p>输出最少需要在商店购买的颜料颜色种数，注意可能购买的颜色不一定会使用在画中，只是为了产生新的颜色。</p>
<p>输入例子: </p>
<p>3 </p>
<p>1 7 3</p>
<p>输出例子: </p>
<p>3</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><pre><code>该题是利用行列式解决异或问题，通过求行列式的秩来求最少需要多少种颜色，没接触过这种题目的同学应该很难将它们联系到一块，不过仔细想想：
化简行列式的过程与本题求解的过程，这道题，你上来如果暴力的话，复杂度O(n^3),而且可能会涉及到重复的计算。利用行列式化简（高斯消元）的方法，就是利用到了：
7：0111
3：0011
2：0010
1：0001
这样的话，7是不可能被异或得出来的，因为他的最高位为1，其他数的最高位为0，而行列式化简，化简成上三角行列式也相同的过程。
本题中只涉及到二进制的异或化简，所以利用高斯消元法较为简单。
`

## 代码

`
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;vector&amp;gt;

using namespace std;
int getbit(int x)
{
    int cnt=0;
    while(x){
        x&amp;gt;&amp;gt;=1;
        cnt++;
    }
    return cnt;
 } 
bool cmp(const int&amp;amp; a,const int&amp;amp; b)
{
    return a&amp;gt;b;
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;,&amp;amp;n)!=EOF){
        vector&amp;lt;int&amp;gt; v;
        int ans=0;
        for(int i=0;i&amp;lt;n;i++){
            int a;
            scanf(&quot;%d&quot;,&amp;amp;a);
            v.push_back(a);
        }
        while(v.size()&amp;gt;=1){
            sort(v.begin(),v.end(),cmp);
            if(v[0]==0){
                ans+=v.size();
                break;
            }
            vector&amp;lt;int&amp;gt;::iterator it=v.begin();
            int fnb=getbit(v[0]);
            for(++it;it!=v.end();it++){
                if(getbit(*it)==fnb){
                    (*it)=(*it)^v[0];
                }
                else break;
            }
            v.erase(v.begin());
        }
        cout&amp;lt;&amp;lt;n-ans&amp;lt;&amp;lt;endl;
    }
    return 0;
}
/*
15
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
*/
</code></pre><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ol>
<li>熟悉了高斯消元法求解化简行列式，高斯（约当）消元法：就是每次把要消去位上含有最大的元素的行调到最高的地方。</li>
<li><p>了解了异或运算与行列式化简的联系。</p>
<pre><code>        作者：qq_27803491 发表于2017/1/5 12:33:55 [原文链接](http://blog.csdn.net/qq_27803491/article/details/54091966)
</code></pre></li>
</ol>
<pre><code>        阅读：31 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/54091966#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]googleSRE运维——减少琐事]]></title>
      <url>/2016/12/29/googleSRE%E8%BF%90%E7%BB%B4%E2%80%94%E2%80%94%E5%87%8F%E5%B0%91%E7%90%90%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="琐事的属性"><a href="#琐事的属性" class="headerlink" title="琐事的属性"></a>琐事的属性</h2><ol>
<li>手动性的</li>
<li>重复性的</li>
<li>可以被自动化的</li>
<li>战术性的（不是太懂，原文是这样的）：琐事是突然出现的、对应式的工作，而非策略驱动和主动安排的。处理紧急警报是琐事。我们可能永远都无法完全消除这种类型的工作，但我们必须继续努力减少它。</li>
<li>没有持久价值</li>
<li>与服务同步线性增长</li>
</ol>
<h2 id="琐事过多的危害"><a href="#琐事过多的危害" class="headerlink" title="琐事过多的危害"></a>琐事过多的危害</h2><ol>
<li>职业停滞</li>
<li>士气低落</li>
<li>造成误解</li>
<li>进展缓慢</li>
<li>开创先例：如果SRE过于愿意承担琐事，研发同事就更倾向于加入更多的琐事，有时候甚至将本来研发团队应承担的运维工作转给SRE来承担。其他团队也会开始指望SRE来接受这样的工作，这显然是不好的。</li>
<li>促进摩擦产生</li>
<li>违反承诺</li>
</ol>
<h2 id="宗旨"><a href="#宗旨" class="headerlink" title="宗旨"></a>宗旨</h2><pre><code>    通过工程工作（符合长期战略的会对你的服务进行长久性的改善的工作）消除一点点的琐事，就可以持续行地整顿服务。我们可以将更多的力量投入到扩大服务规模的工程工作上去，或者是进行下一代的服务的架构设计，又或者是建立一套跨SRE使用的工具链。
    多做创新，少干琐事。
</code></pre><h2 id="对生或中琐事的思考（待续，过一个有条理的生活，因为对我来说，有条理就是自信、充实）"><a href="#对生或中琐事的思考（待续，过一个有条理的生活，因为对我来说，有条理就是自信、充实）" class="headerlink" title="对生或中琐事的思考（待续，过一个有条理的生活，因为对我来说，有条理就是自信、充实）"></a>对生或中琐事的思考（待续，过一个有条理的生活，因为对我来说，有条理就是自信、充实）</h2><h3 id="生活中的琐事"><a href="#生活中的琐事" class="headerlink" title="生活中的琐事"></a>生活中的琐事</h3><ol>
<li>刷空间</li>
<li>刷朋友圈</li>
</ol>
<h3 id="生活中的不可避免的事情"><a href="#生活中的不可避免的事情" class="headerlink" title="生活中的不可避免的事情"></a>生活中的不可避免的事情</h3><ol>
<li>日常洗漱</li>
<li>睡觉</li>
<li>吃饭</li>
<li>学习</li>
<li>工作</li>
</ol>
<h3 id="生活中有意义的能够使自己变得优秀的事情"><a href="#生活中有意义的能够使自己变得优秀的事情" class="headerlink" title="生活中有意义的能够使自己变得优秀的事情"></a>生活中有意义的能够使自己变得优秀的事情</h3><ol>
<li>看书</li>
<li>跑步</li>
<li>看一些有意义的电影</li>
<li><p>拍照发现生活中细小的美</p>
<pre><code>        作者：qq_27803491 发表于2016/12/29 17:37:17 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53930796)
</code></pre></li>
</ol>
<pre><code>        阅读：68 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53930796#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]运维之下 笔记 三（运维平台）]]></title>
      <url>/2016/12/22/%E8%BF%90%E7%BB%B4%E4%B9%8B%E4%B8%8B-%E7%AC%94%E8%AE%B0-%E4%B8%89%EF%BC%88%E8%BF%90%E7%BB%B4%E5%B9%B3%E5%8F%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="两大运维平台："><a href="#两大运维平台：" class="headerlink" title="两大运维平台："></a>两大运维平台：</h2><pre><code> 1\. 资产管理平台
         负责记录基础的物理信息；
         主要用户是系统运维工程师，他们关注设备的出入、维修等管理工作，交付资源给上层业务；
 2\. 服务管理平台 
         记录业务运维所需要的逻辑信息，提供一个基于树状结构（服务树）和权限绑定的管理模式。
         用户主要是应用运维工程师、研发工程师和测试工程师，他们关注服务运行的相关数据。

3.
资产管理平台负责底层的物理信息管理，提供API供服务管理平台查询和同步。服务管理平台通过API获取新交付的服务器列表及其详细信息，将它们归属到服务树产品线节点，分配对应的权限。应用运维工程师在服务树上领取空闲服务器，进行一系列的环境初始化、服务部署、监控添加等工作。应用运维工程师在服务管理平台提交报修申请、服务器归还等操作，通过API将信息推送到资产管理平台，由系统运维工程师进行相应处理。


            作者：qq_27803491 发表于2016/12/22 17:09:37 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53817172)


        阅读：119 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53817172#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]python3.4 验证码识别]]></title>
      <url>/2016/12/20/python3-4-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>需要安装 </p>
<p>pillow、pytesseract、tesseract-ocr</p>
<pre><code>import pytesseract
from PIL import Image
image = Image.open(&#39;C:/Users/Dear/Pictures/code_img/2.jpg&#39;)
vcode = pytesseract.image_to_string(image)
print (vcode)


            作者：qq_27803491 发表于2016/12/20 22:40:29 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53770867)


        阅读：147 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53770867#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]python3.4 信息门户登录请求]]></title>
      <url>/2016/12/20/python3-4-%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E7%99%BB%E5%BD%95%E8%AF%B7%E6%B1%82/</url>
      <content type="html"><![CDATA[<h2 id="python-post请求"><a href="#python-post请求" class="headerlink" title="python  post请求"></a>python  post请求</h2><pre><code>import requests
url = &#39;http://xx.xxxx.edu.cn/userPasswordValidate.portal&#39;
user=20160001
parms={
    &#39;Login.Token1&#39;: user,
    &#39;Login.Token2&#39;: &#39;123456&#39;,
    &#39;captchaField&#39;: &#39;485c&#39;
}

headers = {
    &#39;Connection&#39;:&#39;keep-alive&#39;,
    &#39;Content-Length&#39;: &#39;174&#39;,
    &#39;Cache-Control&#39;: &#39;max-age=0&#39;,
    &#39;Origin&#39;: &#39;http://xx.xxxx.edu.cn&#39;,
    &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,
    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#39;,
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#39;,
    &#39;Referer&#39;: &#39;http://xx.xxxx.edu.cn/&#39;,
    &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,
    &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8&#39;,
    &#39;Cookie&#39;: &#39;JSESSIONID=0000O1UhImqKAdSpqQwJ6Nz9Tow:17kv91lok&#39;
}

resp = requests.post(url, data=parms, headers=headers)
text = resp.text
print(text)


            作者：qq_27803491 发表于2016/12/20 22:31:02 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53770779)


        阅读：51 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53770779#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]python字符串方法基础]]></title>
      <url>/2016/12/20/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<pre><code>#FIND
mystr=&#39;xxxSPAMxxx&#39;
site=mystr.find(&#39;SPAM&#39;)
print(site)

#replace
mystr=&#39;xxaaxxaa&#39;
print(mystr.replace(&#39;aa&#39;,&#39;SPAM&#39;))

#in
mystr=&quot;xxxspamxxx&quot;
print(&#39;spam&#39; in mystr)

#strip
mystr=&#39;\t Ni\n&#39;
print(mystr)
print(mystr.strip())
print(mystr.rstrip())
print(mystr.lstrip())

#lower
mystr=&#39;SHRUBBERY&#39;
print(mystr.lower())

#isalpha
print(mystr.isalpha())

#isdigit
print(mystr.isdigit())

#split
mystr=&#39;aaa,bbb,ccc&#39;
print(mystr.split(&#39;,&#39;))
#split 默认分隔符为泛空格符
mystr=&#39;a b\nc\n d &#39;
print(mystr.split())

#join
delim=&#39;ni&#39;
print(delim.join([&#39;aaa&#39;,&#39;bbb&#39;,&#39;ccc&#39;]))
print(&#39; &#39;.join([&#39;aaa&#39;,&#39;bbb&#39;,&#39;ccc&#39;]))

#list
chars=list(&#39;lorreta&#39;)
print(chars)

chars.append(&#39;!&#39;)
print(&#39;&#39;.join(chars))

#整形和字符串类型转换
int(&quot;42&quot;)
eval(&quot;42&quot;)

str(42)
repr(42)

print(&quot;%d&quot; %42)
print(&#39;{:d}&#39;.format(42))


            作者：qq_27803491 发表于2016/12/20 12:45:17 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53761679)


        阅读：34 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53761679#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]Linux文件压缩及归档]]></title>
      <url>/2016/11/19/Linux%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%8F%8A%E5%BD%92%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h1 id="压缩-解压缩命令"><a href="#压缩-解压缩命令" class="headerlink" title="压缩  解压缩命令"></a>压缩  解压缩命令</h1><h2 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式:"></a>压缩格式:</h2><pre><code>gz,bz2,xz,zip,
压缩算法不同,压缩比也会不同;
`

## 压缩命令

`*不支持压缩目录*
`

### 早期:compress:FILENAME.Z

`    umcompress
`

### gzip: .gz

`    gzip /PATH/TO/SOURCEFILE 压缩完成后会删除原文件
        -d:解压
        -#:(1-9)指定压缩比,默认为6;

    gunzip:
        gunzip /PATH/TO/SOMEFILE.gz :解压完成后会删除原文件
        zcat /PATH/TO/SOMEFILE.gz 表示在不解压的情况下,查看文本文件的内容
`

### bzip2: .bz2

`    比gzip有着更强大的压缩比的压缩工具,使用格式类似
    -d:
    -#:(1-9)
    -k:压缩时保留原文件

    bunzip2:解压

    bzcat:同zcat
`

### xz: .xz

`    压缩比更大,用法同bzip2

    unxz:解压
    xzdec,解压.xz压缩文件,
    xzcat:
`

### zip:(压缩比较小)(归档而且压缩)

`    $:zip FILENAME.zip file1 file2 ... : 压缩,且不删除原文件
    unzip:
        unzip FILENAME.zip
`

## archive:归档,归档本身并不意味着压缩

### tar:(归档工具)

`    -c :创建归档文件
    -f FILE.tar : 操作的归档文件
    -x :展开归档
    --xattrs:归档时保留其扩展属性信息
    $:tar -cf FILE.tar file1 file2 ... (归档命令)
    $:tar -xf FILE.tar (展开归档命令)
    $:tar -tf FILE.tar (不展开文件,查看归档了哪些文件)
    -zcf:归档并调用gzip压缩
    -zxf:调用gzip解压并展开压缩文件(解压时,z选项可省略,下面的解压,j,J都可省略)

    -jcf:调用bzip2
    -jxf:

    -Jcf:调用xz
    -Jxf:
`

### cpio:归档工具

## 补充

### read命令

`read:
    后面加上要输入的变量名
    -p:打印内容,并输入
        $:read -p &quot;打印的内容&quot; a b ...
`

### echo

`echo:
    -n:不换行
`

### 压缩文件的小脚本

`#!/bin/bash

read -p &quot;Please input files&#39; name,which you want to compress:&quot; FILENAME
read -p &quot;Please input Destination:&quot; DEST 
read -p &quot;Please input the compress type :&quot; TYPE 

case $TYPE in 
gzip)
    tar -zcf ${DEST}.tar.gz ${FILENAME} 
    ;;
bzip2)
    tar -jcf ${DEST}.tar.bz2 ${FILENAME}
    ;;
xz)
    tar -Jcf ${DEST}.tar.xz ${FILENAME} 
    ;;
*)
    echo &quot;Unknown TYPE!&quot;
    exit 9
    ;;
esac


            作者：qq_27803491 发表于2016/11/19 17:17:50 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53232202)


        阅读：132 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53232202#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]2016.11.16周三]]></title>
      <url>/2016/11/16/2016-11-16%E5%91%A8%E4%B8%89/</url>
      <content type="html"><![CDATA[<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p><em>距离找工作还有32周,实际学习时间还有26周</em></p>
<h3 id="六级考试-这次说什么也要过了六级-没时间了-come-on-得良"><a href="#六级考试-这次说什么也要过了六级-没时间了-come-on-得良" class="headerlink" title="六级考试(这次说什么也要过了六级,没时间了,come on!得良)"></a>六级考试(这次说什么也要过了六级,没时间了,come on!得良)</h3><ol>
<li>每天百词斩完成任务</li>
<li>闲时听英语听力</li>
<li>两天背一篇作文,一篇听力</li>
<li>一天两篇阅读</li>
</ol>
<h3 id="工作准备"><a href="#工作准备" class="headerlink" title="工作准备"></a>工作准备</h3><pre><code>07_01_vim编辑器详解.rar
07_02_bash脚本编程之六 使用脚本选项及组合条件测试.rar
07_03_Linux文件查找详解.rar
07_04_特殊权限SUID等详解.rar
08_01_facl及用户及Linux终端.rar
08_02_bash脚本编程之七 case语句及脚本选项进阶.rar
08_03_磁盘及文件系统管理详解之一.rar
08_04_磁盘及文件系统管理详解之二.rar
09_01_磁盘及文件系统管理详解之三.rar
09_02_磁盘及文件系统管理详解之五.rar
09_03_磁盘及文件系统管理详解之五.rar
09_04_Linux压缩及归档.rar
10_01_Raid及mdadm命令之一.rar
10_02_Raid及mdadm命令之二.rar
10_03_LVM之一.rar
10_04_LVM之二.rar
10_05_脚本编程之八 脚本完成磁盘分区格式化.rar
11_01_Linux网络配置之一.rar
11_02_Linux网络配置之二 IP报文.rar
11_03_Linux网络配置之三 TCP报文.rar
11_04_Linux网络配置之四 ifconfig及ip命令详解.rar
12_01_Linux软件管理之一 rpm.rar
12_02_Linux软件管理之二 rpm.rar
12_03_Linux软件管理之三 yum.rar
12_04_Linux软件管理之四 yum.rar
13_01_bash脚本编程之九 while循环.rar
13_02_bash脚本编程之十 函数.rar
13_03_Linux进程管理之一.rar
13_04_Linux进程管理之二.rar
14_01_Linux系统启动流程详解之一 运行级别及grub.rar
14_02_Linux系统启动流程之二 内核及init.rar
14_03_bash脚本编程之十一(Linux启动流程之三) SysV服务脚本.rar
14_04_Linux内核编译及系统裁减之一.rar
15_01_bash脚本编程之十二(Linux系统裁减之二) 系统函数库.rar
15_02_bash脚本编程之十三(Linux系统裁减之三) 系统函数库.rar
15_03_Linux系统裁减之四 自定义内核及busybox完成系统定制.rar
16_01_bash脚本编程之十四 信号捕捉及系统管理之任务计划.rar
16_02_Linux系统裁减之五.rar
16_03_Linux日志系统syslog.rar
16_04_Linux系统裁减之六 为系统添加ssh服务.rar
</code></pre><h2 id="打卡"><a href="#打卡" class="headerlink" title="打卡"></a>打卡</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们离理想中的自己越来越远,很大程度上是因为我们一点点的辜负自己. </p>
<p> 六级没有考过,任务没有完成,有些东西是靠积累得来的,不要被各种事情扰乱了生活,要在各种事情之间生活的游刃有余.</p>
<pre><code>            作者：qq_27803491 发表于2016/11/16 18:08:45 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53189469)


        阅读：70 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53189469#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]邮件服务器]]></title>
      <url>/2016/11/15/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="Mail-Server"><a href="#Mail-Server" class="headerlink" title="Mail Server"></a>Mail Server</h2><ol>
<li>SMTP(监听tcp25号端口)：发邮件</li>
<li>ESMTP</li>
<li>POP3：收邮件</li>
<li>IMAP4</li>
<li>UUCP:Unix主机复制文件的协议</li>
<li>C/S smtpd,smtp</li>
<li>MUA：邮件用户代理，</li>
</ol>
<p>Outlook，Foxmail<br>    Thundbird<br>    evolution<br>    mutt</p>
<ol>
<li>MTA:邮件传输代理，smtp服务器，sendmail，uucp，</li>
</ol>
<p>qmail,<br>    postfix:模块化设计，安全，与sendmail兼容性好，投递效率<br>    exim：<br>    exchange：（windows，异步消息协作平台）</p>
<ol>
<li>MDA</li>
</ol>
<p>procmail：<br>    maildrop：</p>
<ol>
<li>MRA：邮件取回代理（pop3，IMAP4）</li>
</ol>
<p>cyrus-imap<br>    dovecot</p>
<ol>
<li><p>SASL：简单认证安全层<br>只是一个框架，需要依靠控件来完成认证<br>cyrus-sasl<br>courier-authlib</p>
</li>
<li><p>Webmail:</p>
</li>
</ol>
<p>Openwebmail（perl）<br>    Squirrelmail    （php）<br>    Extmail（Extman）</p>
<ol>
<li><p>LDAP:Lightweight dirctory Access protocol:轻量级目录访问协议:读取速度快，写入速度慢（读快mysql一个数量级，写慢mysql一个数量级）</p>
</li>
<li><p>mysql：</p>
</li>
<li>虚拟用户：仅用于访问某服务的数字表示</li>
<li>用户：字符串，凭证</li>
</ol>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><ol>
<li>Postfix+SASL(courier-authlib)+Mysql</li>
<li>Dovecot+MySQL</li>
<li>webmail：Extmail+Extman+httpd</li>
<li><p>Postfix配置文件：<br>模块化：</p>
<pre><code>master：/etc/postfix/master.cf
mail：/etc/postfix/main.cf
</code></pre><p>postconf：配置postfix<br>-d:显示默认的配置<br>-n:修改了的配置<br>-m:显示支持的查找表类型<br>-A:显示支持的sasl客户端插件类型<br>-e:PARMATER=VALUE :更改某参数配置信息，并保存到main.cf文件中</p>
<pre><code>        作者：qq_27803491 发表于2016/11/15 21:38:12 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53177971)
</code></pre></li>
</ol>
<pre><code>        阅读：64 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53177971#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]poj3169（差分约束系统）]]></title>
      <url>/2016/11/08/poj3169%EF%BC%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>网址：<a href="http://poj.org/problem?id=3169" target="_blank" rel="external">http://poj.org/problem?id=3169</a></li>
<li>大概题意：有N个点，其中有ml个限制条件：点a，点b，的最长距离为d，有md个限制条件，点a,点b，的最短距离为d；点按序号顺序排，求第一个点到最后一个点的最长距离。</li>
<li>解题思路：差分约束，其实我也不太清楚什么是差分约束，大概就是将各种限制条件，逐个加入，先假设N个点间的距离都为无穷大，然后，按下列顺序，（循环）N（N，ml，md），依次加入限制条件，就可以了，加入第一种限制时，点b的原距离与a点距离加上d，比较，取最小值为b点的最新距离,,min(b(原)，a+d)。加入第二种限制时，已知b求a，min（a（原），b-d）;</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;string&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define INF 0x3f3f3f3f
using namespace std;
int d[1010];
struct MLD{
    int a,b,d;
}ML[10010];
struct MDD{
    int a,b,d;
}MD[10010];

int main()
{
    memset(d,INF,sizeof(d));
    memset(ML,0,sizeof(ML));
    memset(MD,0,sizeof(MD));
    int n,ml,md;
    scanf(&quot;%d%d%d&quot;,&amp;amp;n,&amp;amp;ml,&amp;amp;md);
    d[0]=0;
    for(int i=0;i&amp;lt;ml;i++){
        scanf(&quot;%d%d%d&quot;,&amp;amp;ML[i].a,&amp;amp;ML[i].b,&amp;amp;ML[i].d);
    }
    for(int i=0;i&amp;lt;md;i++){
        scanf(&quot;%d%d%d&quot;,&amp;amp;MD[i].a,&amp;amp;MD[i].b,&amp;amp;MD[i].d);
    }
    for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;n;j++){
            if(d[j+1]&amp;lt;INF)d[j]=min(d[j],d[j+1]);
        }
        for(int j=0;j&amp;lt;ml;j++){
            if(d[ML[j].a-1]&amp;lt;INF){
                d[ML[j].b-1]=min(d[ML[j].a-1]+ML[j].d,d[ML[j].b-1]);
            }
        }
        for(int j=0;j&amp;lt;md;j++){
            if(d[MD[j].b-1]&amp;lt;INF){
                d[MD[j].a-1]=min(d[MD[j].b-1]-MD[j].d,d[MD[j].a-1]);
            }
        }
    }
    if(d[0]&amp;lt;0)printf(&quot;-1\n&quot;);
    else if(d[n-1]==INF)printf(&quot;-2\n&quot;);
    else {
        printf(&quot;%d\n&quot;,d[n-1]);
    }

    return 0;
}


            作者：qq_27803491 发表于2016/11/8 12:24:18 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53080973)


        阅读：61 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53080973#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]细节（水）题codeforce#378C]]></title>
      <url>/2016/11/04/%E7%BB%86%E8%8A%82%EF%BC%88%E6%B0%B4%EF%BC%89%E9%A2%98codeforce-378C/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p><a href="http://codeforces.com/contest/733/problem/C" target="_blank" rel="external">http://codeforces.com/contest/733/problem/C</a></p>
<h3 id="大概题意"><a href="#大概题意" class="headerlink" title="大概题意"></a>大概题意</h3><p>给你N个数，然后再给你经过合并操作后的K个数，求中间合并操作？</p>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iomanip&amp;gt;
#define m0(a) memset(a,0,sizeof(a))
#define mm(a) memset(a,0x3f,sizeof(a))
#define m_1(a) memset(a,-1,sizeof(a))
#define f(i,a,b) for(i = a;i&amp;lt;=b;i++)
#define fi(i,a,b) for(i = a;i&amp;gt;=b;i--)
#define lowbit(a) ((a)&amp;amp;(-a))
#define FFR freopen(&quot;data.in&quot;,&quot;r&quot;,stdin)
#define FFW freopen(&quot;data.out&quot;,&quot;w&quot;,stdout)
#define INF 0x3f3f3f3f
#define DEBUG printf
typedef long long ll;
typedef long double ld;

const ld PI = acos(-1.0);

using namespace std;
#define SIZE 550

int a[SIZE];
int b[SIZE];

struct Chuan{
    int c_start;
    int c_end;
    int c_max;
};
struct Print{
    int num;
    char dire;
};
vector&amp;lt;Chuan&amp;gt; chuan;
queue&amp;lt;Print&amp;gt; print;
int main()
{
    int n,k;
    scanf(&quot;%d&quot;,&amp;amp;n);
    int i;
    f(i,1,n){
        scanf(&quot;%d&quot;,&amp;amp;a[i]);
    }
    scanf(&quot;%d&quot;,&amp;amp;k);
    int site=1;
    bool flag=0;
    f(i,1,k){
        scanf(&quot;%d&quot;,&amp;amp;b[i]);
        if(flag)continue;
        ll all=0;
        Chuan onechuan;
        onechuan.c_start=site;
        onechuan.c_max=0;
        int max_ele=0;
        while(all&amp;lt;b[i]){
            if(a[site]&amp;gt;max_ele){
                max_ele=a[site];
                onechuan.c_max=site;
            }
            else if(a[site]==max_ele){
                if(site-1&amp;gt;=onechuan.c_start&amp;amp;&amp;amp;a[site]&amp;gt;a[site-1]){
                    onechuan.c_max=site;
                }
                else if(site+1&amp;lt;=n&amp;amp;&amp;amp;all+a[site]+a[site+1]&amp;lt;=b[i]&amp;amp;&amp;amp;a[site]&amp;gt;a[site+1]){
                    onechuan.c_max=site;
                }
            }
            all+=a[site++];
        }
        onechuan.c_end=site-1;
        if(all!=b[i])flag=1;
        chuan.push_back(onechuan);
        //DEBUG(&quot;%d %d %d \n&quot;,onechuan.c_start,onechuan.c_max,onechuan.c_end);
    }
    if(flag){
        printf(&quot;NO\n&quot;);
        return 0;
    }
    if(site!=n+1){
        printf(&quot;NO\n&quot;);
        return 0;
    }
    i=0;
    while(!print.empty()){
        print.pop();
    }
    for(vector&amp;lt;Chuan&amp;gt;::iterator it=chuan.begin();it&amp;lt;chuan.end();it++){
        i++;
        if(it-&amp;gt;c_start==it-&amp;gt;c_end)continue;
        int pointer=it-&amp;gt;c_max;
        if(pointer-1&amp;gt;=it-&amp;gt;c_start&amp;amp;&amp;amp;a[pointer]&amp;gt;a[pointer-1]){
            while(pointer&amp;gt;it-&amp;gt;c_start){
                Print oneprint;
                oneprint.num=i+pointer-it-&amp;gt;c_start;
                pointer--;
                oneprint.dire=&#39;L&#39;;
                print.push(oneprint);
            }
            pointer=it-&amp;gt;c_max;
            while(pointer&amp;lt;it-&amp;gt;c_end){
                Print oneprint;
                oneprint.num=i;
                pointer++;
                oneprint.dire=&#39;R&#39;;
                print.push(oneprint);
            }

        }
        else if(pointer+1&amp;lt;=it-&amp;gt;c_end&amp;amp;&amp;amp;a[pointer]&amp;gt;a[pointer+1]){
            while(pointer&amp;lt;it-&amp;gt;c_end){
                Print oneprint;
                oneprint.num=i+it-&amp;gt;c_max-it-&amp;gt;c_start;
                //DEBUG(&quot;hello world!\n&quot;);
                pointer++;
                oneprint.dire=&#39;R&#39;;
                print.push(oneprint);
            }
            pointer=it-&amp;gt;c_max;
            while(pointer&amp;gt;it-&amp;gt;c_start){
                Print oneprint;
                oneprint.num=i+pointer-it-&amp;gt;c_start;
                pointer--;
                oneprint.dire=&#39;L&#39;;
                print.push(oneprint);
            }
        }
        else {
            printf(&quot;NO\n&quot;);
            while(!print.empty()){
                print.pop();
            }
            return 0;
        }
        //DEBUG(&quot;%d %d %d\n&quot;,it-&amp;gt;c_start,it-&amp;gt;c_max,it-&amp;gt;c_end);
    }
    puts(&quot;YES&quot;);
    while(!print.empty()){
        Print oneprint=print.front();
        print.pop();
        printf(&quot;%d %c\n&quot;,oneprint.num,oneprint.dire);
    }
    return 0;
}
</code></pre><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol>
<li>你离AC还差N个细节！</li>
<li>其实还是心不够静，思维跟不上，静下来后，你的智商会变高！</li>
<li><p>仔细阅读题意，然后注意关掉DEBUG！</p>
<pre><code>        作者：qq_27803491 发表于2016/11/4 1:17:06 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53029288)
</code></pre></li>
</ol>
<pre><code>        阅读：89 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53029288#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]AC必备]]></title>
      <url>/2016/11/03/AC%E5%BF%85%E5%A4%87/</url>
      <content type="html"><![CDATA[<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;sstream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iomanip&amp;gt;
#define m0(a) memset(a,0,sizeof(a))
#define mm(a) memset(a,0x3f,sizeof(a))
#define m_1(a) memset(a,-1,sizeof(a))
#define f(i,a,b) for(int i = a;i&amp;lt;=b;i++)
#define fi(i,a,b) for(int i = a;i&amp;gt;=b;i--)
#define lowbit(a) ((a)&amp;amp;(-a))
#define FFR freopen(&quot;data.in&quot;,&quot;r&quot;,stdin)
#define FFW freopen(&quot;data.out&quot;,&quot;w&quot;,stdout)
#define INF 0x3f3f3f3f
#define DEBUG //printf
typedef long long ll;
typedef long double ld;

const ld PI = acos(-1.0);

using namespace std;
#define SIZE (1)

int aa[SIZE];

int main()
{

    return 0;
}
</code></pre><p>写每道题都会用到，把他们做成模版，每次就没必要都打一遍了，节省了时间。</p>
<pre><code>            作者：qq_27803491 发表于2016/11/3 23:50:06 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53028318)


        阅读：66 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53028318#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]2016-11-3 周四]]></title>
      <url>/2016/11/03/2016-11-3-%E5%91%A8%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h2 id="计划（这周和下周）"><a href="#计划（这周和下周）" class="headerlink" title="计划（这周和下周）"></a>计划（这周和下周）</h2><p>这两周，事情比较多，搞事情嘛，就是要有事做才好，不怕事，喜~事 </p>
<p>1. 下周四数据库期中考试(10号) </p>
<p>2. 下周六、日ACM-ICPC北京赛区比赛（12、13号） </p>
<p>3. 下下周一操作系统考试（14号） </p>
<p>4. 周日复习操作系统和数据库。 </p>
<p>5. 每天至少2到中级难度的题，有算法的能写到博客上的。 </p>
<p>6. 面试时会考的算法掌握好。（不只是面试时，基本的算法掌握，熟练）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>时间：11.14</p>
<ol>
<li>acm_reginal 北京没有拿奖，真的差的很远，水平好差，要专注的去搞一件事情，用尽全力，否则，只有努力，没有成果，白受苦。</li>
<li>操作系统考的很差，数据库考的还可以。</li>
</ol>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><pre><code>为什么   “后悔没有早点知道”  ，就算你知道的早了，你没有亲身体验过，你相信么，好了，现在亲身体验了，后果自己也吃了。所以，要变的优秀，要想成功，就得去坚信那些道理，因为那是前人总结出来的经验，这样才能少走弯路。


            作者：qq_27803491 发表于2016/11/3 20:25:06 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53025252)


        阅读：54 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53025252#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]hdu5912 简单公式迭代]]></title>
      <url>/2016/11/02/hdu5912-%E7%AE%80%E5%8D%95%E5%85%AC%E5%BC%8F%E8%BF%AD%E4%BB%A3/</url>
      <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5912" target="_blank" rel="external">http://acm.hdu.edu.cn/showproblem.php?pid=5912</a></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;

#define ll long long
#define DEBUG printf

using namespace std;
ll GCD(ll aa,ll bb)
{
    ll i,t;
    if(aa&amp;lt;bb){
        t=aa;
        aa=bb;
        bb=t;
    }
    while(aa%bb!=0){
        i=aa%bb;
        if(bb&amp;gt;i){
            aa=bb;
            bb=i;
        }
        else aa=i;
    }
    return bb;
 }
void solve(ll &amp;amp;mu,ll &amp;amp;zi,int *a,int *b,int n){
    for(int i=n-1;i&amp;gt;=1;i--){
        ll tmp_mu=mu,tmp_zi=zi;
        mu=tmp_zi+tmp_mu*a[i];
        zi=tmp_mu*b[i];
        ll yueshu=GCD(mu,zi);
        mu/=yueshu;
        zi/=yueshu;
        //DEBUG(&quot;%d:%lld/%lld\n&quot;,i,zi,mu);
    }
}

int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;amp;t);
    for(int tt=1;tt&amp;lt;=t;tt++){
        int a[11],b[11],n;
        scanf(&quot;%d&quot;,&amp;amp;n);
        memset(a,0,sizeof(a));
        memset(b,0,sizeof(b));
        for(int i=1;i&amp;lt;=n;i++){
            scanf(&quot;%d&quot;,&amp;amp;a[i]);
        }
        for(int i=1;i&amp;lt;=n;i++){
            scanf(&quot;%d&quot;,&amp;amp;b[i]);
        }
        ll mu=a[n],zi=b[n];
        solve(mu,zi,a,b,n);
        int yueshu = GCD(mu,zi);
        mu/=yueshu;
        zi/=yueshu;
        printf(&quot;Case #%d: %lld %lld\n&quot;,tt,zi,mu);
    }
    return 0;
 }
/*
1
8
1 2 3 4 5 6 7 8
9 8 7 6 5 4 3 2

*/


            作者：qq_27803491 发表于2016/11/2 10:41:53 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53005481)


        阅读：48 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53005481#comments)
</code></pre>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[[原]51nod 1416两点DFS]]></title>
      <url>/2016/11/01/51nod-1416%E4%B8%A4%E7%82%B9DFS/</url>
      <content type="html"><![CDATA[<h2 id="题目网址"><a href="#题目网址" class="headerlink" title="题目网址"></a>题目网址</h2><p><a href="http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1416" target="_blank" rel="external">http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1416</a></p>
<p>简单的深搜</p>
<h2 id="直接上代码"><a href="#直接上代码" class="headerlink" title="直接上代码"></a>直接上代码</h2><pre><code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;

#define ll long long  
#define DEBUG print
using namespace std;

bool hash[51][51];
char tu[55][55];
int path[55][55];
bool dfs(int n,int m,int i,int j,int count,char c)
{
//  DEBUG(&quot;%c %d %d\n&quot;,c,i,j);
    hash[i][j]=0;
    path[i][j]=count;
    if(j+1&amp;lt;m&amp;amp;&amp;amp;tu[i][j+1]==c){
        if(path[i][j+1]&amp;lt;0){
            if(dfs(n,m,i,j+1,count+1,c))return true;
        }
        else {
            if(path[i][j]-path[i][j+1]&amp;gt;=3)return true;
        } 
    }
    if(i+1&amp;lt;n&amp;amp;&amp;amp;tu[i+1][j]==c){
        if(path[i+1][j]&amp;lt;0){
            if(dfs(n,m,i+1,j,count+1,c))return true;
        }
        else {
            if(path[i][j]-path[i+1][j]&amp;gt;=3)return true;
        } 
    }
    if(j-1&amp;gt;=0&amp;amp;&amp;amp;tu[i][j-1]==c){
        if(path[i][j-1]&amp;lt;0){
            if(dfs(n,m,i,j-1,count+1,c))return true;
        }
        else {
            if(path[i][j]-path[i][j-1]&amp;gt;=3)return true;
        } 
    }
    if(i-1&amp;gt;=0&amp;amp;&amp;amp;tu[i-1][j]==c){
        if(path[i-1][j]&amp;lt;0){
            if(dfs(n,m,i-1,j,count+1,c))return true;
        }
        else {
            if(path[i][j]-path[i-1][j]&amp;gt;=3)return true;
        } 
    }
    return false;
}
int main()
{
//  memset(hash,1,sizeof(hash));

    memset(tu,0,sizeof(tu));
//  memset(path,-1,sizeof(path));
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    getchar();
    for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;m;j++){
            hash[i][j]=1;
        }
    }
    for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;m;j++){
            path[i][j]=-1;
        }
    }
    for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;m;j++){
            scanf(&quot;%c&quot;,&amp;amp;tu[i][j]);
        }
        getchar();
    }
    bool ansflag=0;
    for(int i=0;i&amp;lt;n;i++){
        for(int j=0;j&amp;lt;m;j++){
            if(!hash[i][j])continue;
            else {
                if(dfs(n,m,i,j,0,tu[i][j])){
                    ansflag=1;
                    break;
                }
            }
        }
        if(ansflag)break;
    }

    if(ansflag)printf(&quot;Yes\n&quot;);
    else printf(&quot;No\n&quot;);
 } 


            作者：qq_27803491 发表于2016/11/1 21:25:29 [原文链接](http://blog.csdn.net/qq_27803491/article/details/53000918)


        阅读：49 评论：0 [查看评论](http://blog.csdn.net/qq_27803491/article/details/53000918#comments)
</code></pre>]]></content>
      
        
    </entry>
    
  
  
</search>
